{
  final DTree[] ktrees=new DTree[_nclass];
  int[] leaves=new int[_nclass];
  new ComputePredAndRes().doAll(_train,_parms._build_tree_one_node);
  growTrees(ktrees,leaves,_rand);
  GammaPass gp=new GammaPass(ktrees,leaves,_parms._distribution).doAll(_train);
  if (_parms._distribution == Distribution.Family.laplace) {
    fitBestConstantsQuantile(ktrees,0.5);
  }
 else   if (_parms._distribution == Distribution.Family.quantile) {
    fitBestConstantsQuantile(ktrees,_parms._quantile_alpha);
  }
 else {
    fitBestConstants(ktrees,leaves,gp);
  }
  if (_parms._distribution == Distribution.Family.gamma || _parms._distribution == Distribution.Family.poisson || _parms._distribution == Distribution.Family.tweedie) {
    assert(_nclass == 1);
    DTree tree=ktrees[0];
    int firstLeafIndex=leaves[0];
    if (firstLeafIndex < tree.len())     truncatePreds(tree,firstLeafIndex,_parms._distribution,new ComputeMinMax(firstLeafIndex,tree.len()).doAll(_train));
  }
  new AddTreeContributions(ktrees).doAll(_train);
  _model._output.addKTrees(ktrees);
}
