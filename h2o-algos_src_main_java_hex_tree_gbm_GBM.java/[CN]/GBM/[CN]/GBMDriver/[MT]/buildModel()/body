{
  if (hasOffset() && _parms._distribution == GBMModel.GBMParameters.Family.bernoulli) {
    Log.info("Running Newton-Raphson iteration to find the initial value since offsets are specified.");
    Log.info("Iteration 0: initial value: " + _initialPrediction + " (starting value)");
    double delta;
    int count=0;
    int N=100;
    _initialPrediction=0;
    do {
      double newInit=new NewtonRaphson(_initialPrediction).doAll(_train).value();
      delta=Math.abs(_initialPrediction - newInit);
      _initialPrediction=newInit;
      Log.info("Iteration " + ++count + ": initial value: "+ _initialPrediction);
    }
 while (delta > 1e-6 || count > N);
    if (count > N)     Log.warn("Newton-Raphson iteration didn't converge after " + count + " iterations.");
 else     Log.info("Newton-Raphson iteration converged. Final residual: " + delta);
  }
  _model._output._init_f=_initialPrediction;
  if (_initialPrediction != 0.0) {
    final double init=_initialPrediction;
    new MRTask(){
      @Override public void map(      Chunk tree){
        for (int i=0; i < tree._len; i++)         tree.set(i,init);
      }
    }
.doAll(vec_tree(_train,0),_parms._build_tree_one_node);
  }
  if (_parms._checkpoint) {
    Timer t=new Timer();
    new ResidualsCollector(_ncols,_nclass,(hasOffset() ? 1 : 0) + (hasWeights() ? 1 : 0),_model._output._treeKeys).doAll(_train,_parms._build_tree_one_node);
    Log.info("Reconstructing tree residuals stats from checkpointed model took " + t);
  }
  for (int tid=0; tid < _parms._ntrees; tid++) {
    if (tid != 0 || !_parms._checkpoint) {
      double training_r2=doScoringAndSaveModel(false,false,_parms._build_tree_one_node);
      if (training_r2 >= _parms._r2_stopping)       return;
    }
    new ComputeProb().doAll(_train,_parms._build_tree_one_node);
    new ComputeRes().doAll(_train,_parms._build_tree_one_node);
    Timer kb_timer=new Timer();
    buildNextKTrees();
    Log.info((tid + 1) + ". tree was built in " + kb_timer.toString());
    GBM.this.update(1);
    if (!isRunning())     return;
  }
  doScoringAndSaveModel(true,false,_parms._build_tree_one_node);
}
