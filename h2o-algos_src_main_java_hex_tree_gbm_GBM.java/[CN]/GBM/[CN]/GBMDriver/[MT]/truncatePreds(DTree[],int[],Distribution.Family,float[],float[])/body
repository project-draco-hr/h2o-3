{
  Log.info("Number of leaf nodes: " + minValues.length);
  Log.info("Min: " + java.util.Arrays.toString(minValues));
  Log.info("Max: " + java.util.Arrays.toString(maxValues));
  assert(_nclass == 1);
  final DTree tree=ktrees[0];
  assert(tree != null);
  for (int i=0; i < tree._len - leafs[0]; i++) {
    final LeafNode node=((LeafNode)tree.node(leafs[0] + i));
    int nidx=node.nid();
    float nodeMin=minValues[nidx - leafs[0]];
    float nodeMax=maxValues[nidx - leafs[0]];
    double val=node._pred;
    if (dist == Distribution.Family.gamma || dist == Distribution.Family.tweedie)     val+=nodeMax;
    if (val > MAX_LOG_TRUNC) {
      Log.warn("Truncating large positive leaf prediction (log): " + node._pred + " to "+ (MAX_LOG_TRUNC - nodeMax));
      node._pred=(float)(MAX_LOG_TRUNC - nodeMax);
    }
    val=node._pred;
    if (dist == Distribution.Family.gamma || dist == Distribution.Family.tweedie)     val+=nodeMin;
    if (val < MIN_LOG_TRUNC) {
      Log.warn("Truncating large negative leaf prediction (log): " + node._pred + " to "+ (MIN_LOG_TRUNC - nodeMin));
      node._pred=(float)(MIN_LOG_TRUNC - nodeMin);
    }
    if (node._pred < MIN_LOG_TRUNC && node._pred > MAX_LOG_TRUNC) {
      Log.warn("Terminal node prediction outside of allowed interval in log-space: " + node._pred + " (should be in "+ MIN_LOG_TRUNC+ "..."+ MAX_LOG_TRUNC+ ").");
    }
  }
}
