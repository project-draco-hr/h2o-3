{
  Chunk ys=chk_resp(chks);
  Chunk offset=hasOffset() ? chk_offset(chks) : new C0DChunk(0,chks[0]._len);
  if (_parms._distribution == GBMModel.GBMParameters.Family.bernoulli) {
    Chunk tr=chk_tree(chks,0);
    Chunk wk=chk_work(chks,0);
    for (int row=0; row < ys._len; row++)     wk.set(row,1.0f / (1f + Math.exp(tr.atd(row) + offset.atd(row))));
  }
 else   if (_nclass > 1) {
    double fs[]=new double[_nclass + 1];
    for (int row=0; row < ys._len; row++) {
      double weight=hasWeights() ? chk_weight(chks).atd(row) : 1;
      double sum=score1(chks,weight,0.0,fs,row);
      if (Double.isInfinite(sum))       for (int k=0; k < _nclass; k++)       chk_work(chks,k).set(row,Double.isInfinite(fs[k + 1]) ? 1.0f : 0.0f);
 else       for (int k=0; k < _nclass; k++)       chk_work(chks,k).set(row,(float)(fs[k + 1] / sum));
    }
  }
 else {
    Chunk tr=chk_tree(chks,0);
    Chunk wk=chk_work(chks,0);
    if (_parms._distribution == GBMModel.GBMParameters.Family.gaussian) {
      for (int row=0; row < ys._len; row++)       wk.set(row,(float)(tr.atd(row) + offset.atd(row)));
    }
 else     if (_parms._distribution == GBMModel.GBMParameters.Family.poisson) {
      for (int row=0; row < ys._len; row++)       wk.set(row,(float)Math.max(1e-19,Math.min(1e19,Math.exp((tr.atd(row) + offset.atd(row))))));
    }
  }
}
