{
  Vec vec=null;
  try {
    Futures fs=new Futures();
    AppendableVec av=new AppendableVec(Vec.newKey());
    NewChunk nv=new NewChunk(av,0);
    nv._ls=new long[]{0,0,0,0};
    nv._xs=new int[]{0,0,0,0};
    nv._len=nv._len2=nv._ls.length;
    nv.close(0,fs);
    vec=av.close(fs);
    assertEquals(nv._len2,vec.length());
    Chunk c0=vec.chunkForChunkIdx(0);
    assertTrue("Found chunk class " + c0.getClass() + " but expected C0LChunk",c0 instanceof C0LChunk);
    for (int i=0; i < nv._ls.length; i++)     assertEquals(0,c0.at0(i),c0.at0(i) * EPSILON);
    vec.set(0,0);
    assertEquals(0,vec.at8(0));
    Chunk c1=vec.chunkForChunkIdx(0);
    assertTrue("Found chunk class " + c1.getClass() + " but expected C0LChunk",c1 instanceof C0LChunk);
    c1.set(1,1);
    assertEquals(1,vec.at8(1));
    c1.close(0,fs);
    Chunk c2=vec.chunkForChunkIdx(0);
    assertTrue("Found chunk class " + c2.getClass() + " but expected CBSChunk",c2 instanceof CBSChunk);
    c2.set(2,2);
    c2.close(0,fs);
    assertEquals(2,vec.at8(2));
    Chunk c3=vec.chunkForChunkIdx(0);
    assertTrue("Found chunk class " + c3.getClass() + " but expected C1NChunk",c3 instanceof C1NChunk);
    c3.set(3,3);
    c3.close(0,fs);
    assertEquals(3,vec.at8(3));
    Chunk c4=vec.chunkForChunkIdx(0);
    assertTrue("Found chunk class " + c4.getClass() + " but expected C1NChunk",c4 instanceof C1NChunk);
    fs.blockForPending();
  }
  finally {
    if (vec != null)     vec.remove();
  }
}
