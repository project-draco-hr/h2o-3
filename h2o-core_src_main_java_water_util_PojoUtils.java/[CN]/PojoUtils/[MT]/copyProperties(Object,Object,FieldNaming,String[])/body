{
  if (null == dest || null == origin)   return;
  Field[] dest_fields=Weaver.getWovenFields(dest.getClass());
  Field[] orig_fields=Weaver.getWovenFields(origin.getClass());
  for (  Field f : orig_fields) {
    String origin_name=f.getName();
    if (skip_fields != null & ArrayUtils.contains(skip_fields,origin_name))     continue;
    String dest_name=null;
    if (field_naming == FieldNaming.CONSISTENT) {
      dest_name=origin_name;
    }
 else     if (field_naming == FieldNaming.DEST_HAS_UNDERSCORES) {
      dest_name="_" + origin_name;
    }
 else     if (field_naming == FieldNaming.ORIGIN_HAS_UNDERSCORES) {
      dest_name=origin_name.substring(1);
    }
    if (skip_fields != null & ArrayUtils.contains(skip_fields,dest_name))     continue;
    try {
      Field dest_field=null;
      for (      Field fd : dest_fields) {
        if (fd.getName().equals(dest_name)) {
          dest_field=fd;
          break;
        }
      }
      if (dest_field != null) {
        dest_field.setAccessible(true);
        f.setAccessible(true);
        if (null == f.get(origin)) {
          dest_field.set(dest,null);
        }
 else         if (dest_field.getType().isArray() && f.getType().isArray() && (dest_field.getType().getComponentType() != f.getType().getComponentType())) {
          if (dest_field.getType().getComponentType() == int.class && f.getType().getComponentType() == Integer.class) {
            int[] copy=(int[])f.get(origin);
            dest_field.set(dest,copy);
          }
 else           if (dest_field.getType().getComponentType() == Integer.class && f.getType().getComponentType() == int.class) {
            Integer[] copy=(Integer[])f.get(origin);
            dest_field.set(dest,copy);
          }
 else           if (Schema.class.isAssignableFrom(dest_field.getType().getComponentType()) && ((Schema)dest_field.get(dest)).getImplClass().isAssignableFrom(f.getType().getComponentType())) {
            Class dest_component_class=dest_field.getType().getComponentType();
            Schema[] translation=(Schema[])Array.newInstance(dest_component_class,Array.getLength(f.get(origin)));
            int i=0;
            for (            Iced impl : ((Iced[])f.get(origin))) {
              translation[i]=((Schema)dest_field.getType().newInstance()).fillFromImpl(impl);
            }
            dest_field.set(dest,translation);
          }
 else           if (Schema.class.isAssignableFrom(f.getType().getComponentType()) && Iced.class.isAssignableFrom(dest_field.getType().getComponentType())) {
            Class dest_component_class=dest_field.getType().getComponentType();
            Iced[] translation=(Iced[])Array.newInstance(dest_component_class,Array.getLength(f.get(origin)));
            int i=0;
            for (            Schema s : ((Schema[])f.get(origin))) {
              translation[i]=s.createImpl();
            }
            dest_field.set(dest,translation);
          }
 else {
            throw H2O.fail("Don't know how to cast an array of: " + f.getType().getComponentType() + " to an array of: "+ dest_field.getType().getComponentType());
          }
        }
 else         if (dest_field.getType() == Key.class && Keyed.class.isAssignableFrom(f.getType())) {
          dest_field.set(dest,((Keyed)f.get(origin))._key);
        }
 else         if (f.getType() == Key.class && Keyed.class.isAssignableFrom(dest_field.getType())) {
          Value v=DKV.get((Key)f.get(origin));
          dest_field.set(dest,(null == v ? null : v.get()));
        }
 else         if (dest_field.getType() == Pattern.class && String.class.isAssignableFrom(f.getType())) {
          dest_field.set(dest,Pattern.compile((String)f.get(origin)));
        }
 else         if (f.getType() == Pattern.class && String.class.isAssignableFrom(dest_field.getType())) {
          dest_field.set(dest,f.get(origin).toString());
        }
 else         if (Enum.class.isAssignableFrom(dest_field.getType()) && String.class.isAssignableFrom(f.getType())) {
          Class<Enum> dest_class=(Class<Enum>)dest_field.getType();
          dest_field.set(dest,Enum.valueOf(dest_class,(String)f.get(origin)));
        }
 else         if (Enum.class.isAssignableFrom(f.getType()) && String.class.isAssignableFrom(dest_field.getType())) {
          dest_field.set(dest,f.get(origin).toString());
        }
 else         if (Schema.class.isAssignableFrom(dest_field.getType()) && ((Schema)dest_field.get(dest)).getImplClass().isAssignableFrom(f.getType())) {
          dest_field.set(dest,((Schema)dest_field.getType().newInstance()).fillFromImpl((Iced)f.get(origin)));
        }
 else         if (Schema.class.isAssignableFrom(f.getType()) && ((Schema)f.get(origin)).getImplClass().isAssignableFrom(dest_field.getType())) {
          dest_field.set(dest,((Schema)f.get(origin)).createImpl());
        }
 else {
          dest_field.set(dest,f.get(origin));
        }
      }
    }
 catch (    IllegalAccessException e) {
      Log.err("Illegal access exception trying to copy field: " + origin_name + " of class: "+ origin.getClass()+ " to field: "+ dest_name+ " of class: "+ dest.getClass());
    }
catch (    InstantiationException e) {
      Log.err("Instantiation exception trying to copy field: " + origin_name + " of class: "+ origin.getClass()+ " to field: "+ dest_name+ " of class: "+ dest.getClass());
    }
  }
}
