def _do_it(self):
    '\n    External API for eager; called by all top-level demanders (e.g. print)\n    This may trigger (recursive) big-data evaluation.\n    :return: None\n    '
    if self.is_computed():
        return
    assign_vec = (self._left._left if ((self._op == '=') and (self._left._op == '[')) else None)
    cnt = (sys.getrefcount(self) - 1)
    py_tmp = ((cnt != 4) and (self._len > 1) and (not assign_vec))
    global __CMD__
    skip = False
    if py_tmp:
        self._data = frame.H2OFrame.py_tmp_key()
        __CMD__ += (('(= !' + self._data) + ' ')
    if (self._op != ','):
        __CMD__ += (('(' + self._op) + ' ')
    left = self._do_child(self._left)
    if (py_tmp and self._left._is_key() and (self._op == ',')):
        skip = True
        __CMD__ += ')'
    rite = self._do_child(self._rite)
    if (self._op in ['+', '&', '|', '-', '*', '/', '^', 'n', 'N', 'g', 'G', 'l', 'L']):
        rapids_dict = {'+': '+', '&': '&', '|': '|', '-': '-', '*': '*', '/': '/', '^': '**', 'n': '==', 'N': '!=', 'g': '>', 'G': '>=', 'l': '<', 'L': '<=', }
        if isinstance(left._data, (int, float, str)):
            if isinstance(rite._data, (int, float, str)):
                self._data = eval((('left ' + rapids_dict[self._op]) + ' rite'))
            elif rite.is_local():
                self._data = eval((('[left ' + rapids_dict[self._op]) + ' x for x in rite._data]'))
            else:
                pass
        elif isinstance(rite._data, (int, float, str)):
            if left.is_local():
                self._data = eval((('[x' + self._op) + ' rite for x in left._data]'))
            else:
                pass
        elif (left.is_local() and rite.is_local()):
            self._data = eval((('[x ' + self._op) + ' y for x, y in zip(left._data, rite._data)]'))
        elif ((left.is_remote() or (left._data is None)) and (rite.is_remote() or (rite._data is None))):
            pass
        else:
            raise NotImplementedError
    elif (self._op == '['):
        if isinstance(rite._data, tuple):
            pass
        elif left.is_local():
            self._data = left._data[rite._data]
        else:
            __CMD__ += ' "null"'
    elif (self._op == '='):
        if left.is_local():
            raise NotImplementedError
        elif (rite is None):
            __CMD__ += '#NaN'
    elif (self._op in ['floor', 'abs']):
        if left.is_local():
            self._data = eval((('[' + self._op) + '(x) for x in left._data]'))
        else:
            pass
    elif (self._op == 'not'):
        if left.is_local():
            self._data = [(not x) for x in left._data]
        else:
            pass
    elif (self._op == 'sign'):
        if left.is_local():
            self._data = [cmp(x, 0) for x in left._data]
        else:
            pass
    elif (self._op in ['cos', 'sin', 'tan', 'acos', 'asin', 'atan', 'cosh', 'sinh', 'tanh', 'acosh', 'asinh', 'atanh', 'sqrt', 'trunc', 'log', 'log10', 'log1p', 'exp', 'expm1', 'gamma', 'lgamma']):
        if left.is_local():
            self._data = eval((('[math.' + self._op) + '(x) for x in left._data]'))
        else:
            pass
    elif (self._op in ['cospi', 'sinpi', 'tanpi', 'ceiling', 'log2', 'digamma', 'trigamma']):
        if left.is_local():
            if (self._op == 'cospi'):
                self._data = eval('[math.cos(math.pi*x) for x in left._data]')
            elif (self._op == 'sinpi'):
                self._data = eval('[math.sin(math.pi*x) for x in left._data]')
            elif (self._op == 'tanpi'):
                self._data = eval('[math.tan(math.pi*x) for x in left._data]')
            elif (self._op == 'ceiling'):
                self._data = eval('[math.ceil(x) for x in left._data]')
            elif (self._op == 'log2'):
                self._data = eval('[math.log(x,2) for x in left._data]')
            elif (self._op == 'digamma'):
                self._data = eval('[scipy.special.polygamma(0,x) for x in left._data]')
            elif (self._op == 'trigamma'):
                self._data = eval('[scipy.special.polygamma(1,x) for x in left._data]')
        else:
            pass
    elif (self._op == 'month'):
        if left.is_local():
            raise NotImplementedError
        else:
            pass
    elif (self._op == 'dayOfWeek'):
        if left.is_local():
            raise NotImplementedError
        else:
            pass
    elif (self._op in ['min', 'max', 'sum', 'median']):
        if left.is_local():
            raise NotImplementedError
        else:
            __CMD__ += '%FALSE'
    elif (self._op == 'cbind'):
        if left.is_local():
            for v in left._data:
                __CMD__ += (("'" + str(v._expr._data)) + "'")
        else:
            pass
    elif (self._op == 'mean'):
        if left.is_local():
            self._data = (sum(left._data) / len(left._data))
        else:
            __CMD__ += ' #0 %TRUE'
    elif (self._op in ['var', 'sd']):
        if left.is_local():
            mean = (sum(left._data) / len(left._data))
            sum_of_sq = sum((((x - mean) ** 2) for x in left._data))
            num_obs = len(left._data)
            var = (sum_of_sq / (num_obs - 1))
            self._data = (var if (self._op == 'var') else (var ** 0.5))
        else:
            __CMD__ += (' () %TRUE "everything"' if (self._op == 'var') else ' %TRUE')
    elif (self._op == 'is.factor'):
        if left.is_local():
            raise NotImplementedError
        else:
            pass
    elif (self._op in ['as.factor', 'h2o.runif', 'is.na']):
        if left.is_local():
            self._data = map(str, left._data)
        else:
            pass
    elif (self._op == 'quantile'):
        if left.is_local():
            raise NotImplementedError
        else:
            rapids_series = (('(dlist #' + ' #'.join([str(x) for x in rite._data])) + ')')
            __CMD__ += (rapids_series + ' ')
    elif (self._op == 'mktime'):
        if left.is_local():
            raise NotImplementedError
        else:
            pass
    elif (self._op == ','):
        pass
    else:
        raise NotImplementedError(self._op)
    if (self._op != ','):
        __CMD__ += ')'
    if (py_tmp and (not skip)):
        __CMD__ += ')'
    self._left = None
    self._rite = None
    if assign_vec:
        self._left = assign_vec
        self._data = assign_vec._data
