def _do_it(self):
    '\n    External API for eager; called by all top-level demanders (e.g. print)\n    This may trigger (recursive) big-data evaluation.\n    :return: None\n    '
    if self.is_computed():
        return
    assign_vec = (self._left._left if ((self._op == '=') and (self._left._op == '[')) else None)
    cnt = (sys.getrefcount(self) - 1)
    py_tmp = ((cnt != 4) and (self._len > 1) and (not assign_vec))
    global __CMD__
    if py_tmp:
        self._data = frame.H2OFrame.py_tmp_key()
        __CMD__ += (('(= !' + self._data) + ' ')
    __CMD__ += (('(' + self._op) + ' ')
    left = self._do_child(True)
    rite = self._do_child(False)
    if (self._op == '+'):
        if isinstance(left._data, (int, float)):
            if isinstance(rite._data, (int, float)):
                self._data = (left + rite)
            elif rite.is_local():
                self._data = [(left + x) for x in rite._data]
            else:
                pass
        elif isinstance(rite._data, (int, float)):
            if left.is_local():
                self._data = [(x + rite) for x in left._data]
            else:
                pass
        elif (left.is_local() and rite.is_local()):
            self._data = [(x + y) for (x, y) in zip(left._data, rite._data)]
        elif ((left.is_remote() or (left._data is None)) and (rite.is_remote() or (rite._data is None))):
            pass
        else:
            raise NotImplementedError
    elif (self._op == '&'):
        if isinstance(left._data, (int, float)):
            if isinstance(rite._data, (int, float)):
                self._data = (left & rite)
            elif rite.is_local():
                self._data = [(left & x) for x in rite._data]
            else:
                pass
        elif isinstance(rite._data, (int, float)):
            if left.is_local():
                self._data = [(x & rite) for x in left._data]
            else:
                pass
        elif (left.is_local() and rite.is_local()):
            self._data = [(x + y) for (x, y) in zip(left._data, rite._data)]
        elif ((left.is_remote() or (left._data is None)) and (rite.is_remote() or (rite._data is None))):
            pass
        else:
            raise NotImplementedError
    elif (self._op == '*'):
        if isinstance(left._data, (int, float)):
            if isinstance(rite._data, (int, float)):
                self._data = (left * rite)
            elif rite.is_local():
                self._data = [(left * x) for x in rite._data]
            else:
                pass
        elif isinstance(rite._data, (int, float)):
            if left.is_local():
                self._data = [(x * rite) for x in left._data]
            else:
                pass
        elif (left.is_local() and rite.is_local()):
            self._data = [(x * y) for (x, y) in zip(left._data, rite._data)]
        elif ((left.is_remote() or (left._data is None)) and (rite.is_remote() or (rite._data is None))):
            pass
        else:
            raise NotImplementedError
    elif (self._op == '/'):
        if isinstance(left._data, (int, float)):
            if isinstance(rite._data, (int, float)):
                self._data = (left / rite)
            elif rite.is_local():
                self._data = [(left / x) for x in rite._data]
            else:
                pass
        elif isinstance(rite._data, (int, float)):
            if left.is_local():
                self._data = [(x / rite) for x in left._data]
            else:
                pass
        elif (left.is_local() and rite.is_local()):
            self._data = [(x / y) for (x, y) in zip(left._data, rite._data)]
        elif ((left.is_remote() or (left._data is None)) and (rite.is_remote() or (rite._data is None))):
            pass
        else:
            raise NotImplementedError
    elif (self._op == '=='):
        if isinstance(left._data, (int, float)):
            raise NotImplementedError
        elif isinstance(rite._data, (int, float)):
            if left.is_local():
                self._data = [(x == rite._data) for x in left._data]
            else:
                pass
        else:
            raise NotImplementedError
    elif (self._op == '<'):
        if isinstance(left._data, (int, float)):
            raise NotImplementedError
        elif isinstance(rite._data, (int, float)):
            if left.is_local():
                self._data = [(x < rite._data) for x in left._data]
            else:
                pass
        else:
            raise NotImplementedError
    elif (self._op == '>='):
        if isinstance(left._data, (int, float)):
            raise NotImplementedError
        elif isinstance(rite._data, (int, float)):
            if left.is_local():
                self._data = [(x >= rite._data) for x in left._data]
            else:
                pass
        else:
            raise NotImplementedError
    elif (self._op == '['):
        if left.is_local():
            self._data = left._data[rite._data]
        else:
            __CMD__ += ' "null"'
    elif (self._op == '='):
        if left.is_local():
            raise NotImplementedError
        elif (rite is None):
            __CMD__ += '#NaN'
    elif (self._op == 'floor'):
        if left.is_local():
            self._data = [math.floor(x) for x in left._data]
        else:
            pass
    elif (self._op == 'month'):
        if left.is_local():
            raise NotImplementedError
        else:
            pass
    elif (self._op == 'dayOfWeek'):
        if left.is_local():
            raise NotImplementedError
        else:
            pass
    elif (self._op == 'mean'):
        if left.is_local():
            self._data = (sum(left._data) / len(left._data))
        else:
            __CMD__ += ' #0 %TRUE'
    elif (self._op == 'as.factor'):
        if left.is_local():
            self._data = map(str, left._data)
        else:
            pass
    elif (self._op == 'h2o.runif'):
        if left.is_local():
            self._data = map(str, left._data)
        else:
            pass
    elif (self._op == 'quantile'):
        if left.is_local():
            raise NotImplementedError
        else:
            rapids_series = (('{' + ';'.join([str(x) for x in rite._data])) + '}')
            __CMD__ += (rapids_series + ' %FALSE #7')
    else:
        raise NotImplementedError(self._op)
    __CMD__ += ')'
    if py_tmp:
        __CMD__ += ')'
    self._left = None
    self._rite = None
    if assign_vec:
        if (assign_vec._op != 'rawdata'):
            raise NotImplementedError
        self._left = assign_vec
        self._data = assign_vec._data
