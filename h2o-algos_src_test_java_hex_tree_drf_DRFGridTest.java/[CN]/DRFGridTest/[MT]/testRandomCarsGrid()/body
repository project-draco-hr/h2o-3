{
  Grid grid=null;
  DRFModel drfRebuilt=null;
  Frame fr=null;
  try {
    fr=parse_test_file("smalldata/junit/cars.csv");
    fr.remove("name").remove();
    Vec old=fr.remove("economy (mpg)");
    fr.add("economy (mpg)",old);
    DKV.put(fr);
    HashMap<String,Object[]> hyperParms=new HashMap<>();
    long seed=System.nanoTime();
    Random rng=new Random(seed);
    Integer ntreesDim=rng.nextInt(4) + 1;
    Integer maxDepthDim=rng.nextInt(4) + 1;
    Integer mtriesDim=rng.nextInt(4) + 1;
    Integer sampleRateDim=rng.nextInt(4) + 1;
    Integer[] ntreesArr=new Integer[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50};
    ArrayList<Integer> ntreesList=new ArrayList<Integer>(Arrays.asList(ntreesArr));
    Collections.shuffle(ntreesList);
    Integer[] ntreesSpace=new Integer[ntreesDim];
    for (int i=0; i < ntreesDim; i++) {
      ntreesSpace[i]=ntreesList.get(i);
    }
    Integer[] maxDepthArr=new Integer[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};
    ArrayList<Integer> maxDepthList=new ArrayList<Integer>(Arrays.asList(maxDepthArr));
    Collections.shuffle(maxDepthList);
    Integer[] maxDepthSpace=new Integer[maxDepthDim];
    for (int i=0; i < maxDepthDim; i++) {
      maxDepthSpace[i]=maxDepthList.get(i);
    }
    Integer[] mtriesArr=new Integer[]{1,2,3,4,5,6};
    ArrayList<Integer> mtriesList=new ArrayList<Integer>(Arrays.asList(mtriesArr));
    Collections.shuffle(mtriesList);
    Integer[] mtriesSpace=new Integer[mtriesDim];
    for (int i=0; i < mtriesDim; i++) {
      mtriesSpace[i]=mtriesList.get(i);
    }
    Float[] sampleRateArr=new Float[]{0.01f,0.02f,0.03f,0.04f,0.05f,0.06f,0.07f,0.08f,0.09f,0.1f,0.11f,0.12f,0.13f,0.14f,0.15f,0.16f,0.17f,0.18f,0.19f,0.2f,0.21f,0.22f,0.23f,0.24f,0.25f,0.26f,0.27f,0.28f,0.29f,0.3f,0.31f,0.32f,0.33f,0.34f,0.35f,0.36f,0.37f,0.38f,0.39f,0.4f,0.41f,0.42f,0.43f,0.44f,0.45f,0.46f,0.47f,0.48f,0.49f,0.5f,0.51f,0.52f,0.53f,0.54f,0.55f,0.56f,0.57f,0.58f,0.59f,0.6f,0.61f,0.62f,0.63f,0.64f,0.65f,0.66f,0.67f,0.68f,0.69f,0.7f,0.71f,0.72f,0.73f,0.74f,0.75f,0.76f,0.77f,0.78f,0.79f,0.8f,0.81f,0.82f,0.83f,0.84f,0.85f,0.86f,0.87f,0.88f,0.89f,0.9f,0.91f,0.92f,0.93f,0.94f,0.95f,0.96f,0.97f,0.98f,0.99f};
    ArrayList<Float> sampleRateList=new ArrayList<Float>(Arrays.asList(sampleRateArr));
    Collections.shuffle(sampleRateList);
    Float[] sampleRateSpace=new Float[sampleRateDim];
    for (int i=0; i < sampleRateDim; i++) {
      sampleRateSpace[i]=sampleRateList.get(i);
    }
    hyperParms.put("_ntrees",ntreesSpace);
    hyperParms.put("_max_depth",maxDepthSpace);
    hyperParms.put("_mtries",mtriesSpace);
    hyperParms.put("_sample_rate",sampleRateSpace);
    DRFModel.DRFParameters params=new DRFModel.DRFParameters();
    params._train=fr._key;
    params._response_column="economy (mpg)";
    GridSearch gs=GridSearch.startGridSearch(params,hyperParms,DRF_MODEL_FACTORY);
    grid=(Grid)gs.get();
    System.out.println("Test seed: " + seed);
    System.out.println("ntrees search space: " + Arrays.toString(ntreesSpace));
    System.out.println("max_depth search space: " + Arrays.toString(maxDepthSpace));
    System.out.println("mtries search space: " + Arrays.toString(mtriesSpace));
    System.out.println("sample_rate search space: " + Arrays.toString(sampleRateSpace));
    Model[] ms=grid.getModels();
    Integer numModels=ms.length;
    System.out.println("Grid consists of " + numModels + " models");
    assertTrue("Number of models should match hyper space size",numModels == ntreesDim * maxDepthDim * sampleRateDim* mtriesDim);
    HashMap<String,Object[]> randomHyperParms=new HashMap<>();
    Integer ntreeVal=ntreesSpace[rng.nextInt(ntreesSpace.length)];
    randomHyperParms.put("_ntrees",new Integer[]{ntreeVal});
    Integer maxDepthVal=maxDepthSpace[rng.nextInt(maxDepthSpace.length)];
    randomHyperParms.put("_max_depth",maxDepthSpace);
    Integer mtriesVal=mtriesSpace[rng.nextInt(mtriesSpace.length)];
    randomHyperParms.put("_max_depth",mtriesSpace);
    Float sampleRateVal=sampleRateSpace[rng.nextInt(sampleRateSpace.length)];
    randomHyperParms.put("_sample_rate",sampleRateSpace);
    params._ntrees=ntreeVal;
    params._max_depth=maxDepthVal;
    params._mtries=mtriesVal;
    DRF job=null;
    try {
      job=new DRF(params);
      drfRebuilt=job.trainModel().get();
    }
  finally {
      if (job != null) {
        job.remove();
      }
    }
    assertTrue(job._state == water.Job.JobState.DONE);
    double rebuiltMSE=drfRebuilt._output._scored_train[drfRebuilt._output._ntrees]._mse;
    System.out.println("The rebuilt model's MSE: " + rebuiltMSE);
  }
  finally {
    if (fr != null) {
      fr.remove();
    }
    if (grid != null) {
      grid.remove();
    }
    if (drfRebuilt != null) {
      drfRebuilt.remove();
    }
  }
}
