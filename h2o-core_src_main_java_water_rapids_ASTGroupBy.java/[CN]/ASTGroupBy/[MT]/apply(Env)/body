{
  Frame fr=e.popAry();
  if (_gbCols == null)   _gbCols=_gbColsDelayed == null ? findCols(fr,_gbColsDelayedByName) : findCols(fr,_gbColsDelayed);
  computeCols(_agg,fr);
  for (  AGG a : _agg)   if (a._type == AGG.T_MODE)   a._domainsForMode=fr.domains()[a._c];
  long s=System.currentTimeMillis();
  GBTask p1=new GBTask(_gbCols,_agg).doAll(fr);
  Log.info("Group By Task done in " + (System.currentTimeMillis() - s) / 1000. + " (s)");
  int nGrps=p1._g.size();
  G[] tmpGrps=p1._g.keySet().toArray(new G[nGrps]);
  while (tmpGrps[nGrps - 1] == null)   nGrps--;
  final G[] grps=new G[nGrps];
  System.arraycopy(tmpGrps,0,grps,0,nGrps);
  ParallelPostGlobal t;
  H2O.submitTask(t=new ParallelPostGlobal(grps,nGrps,_orderByCols)).join();
  final String[][] modeDomains=t._modeDomain == null ? null : new String[t._modeDomain.length][];
  if (t._modeDomain != null) {
    for (int i=0; i < t._modeDomain.length; ++i) {
      modeDomains[i]=t._modeDomain[i].toArray(new String[t._modeDomain[i].size()]);
      Arrays.sort(modeDomains[i]);
    }
  }
  if (_orderByCols != null)   Arrays.sort(grps);
  final int nCols=_gbCols.length + _agg.length;
  Vec v=Vec.makeZero(nGrps);
  String[] names=new String[nCols];
  String[][] domains=new String[nCols][];
  for (int i=0; i < _gbCols.length; ++i) {
    names[i]=fr.name((int)_gbCols[i]);
    domains[i]=fr.domains()[(int)_gbCols[i]];
  }
  if (modeDomains != null) {
    int a=0;
    for (int i=_gbCols.length; i < nCols; ++i)     domains[i]=_agg[a]._type == AGG.T_MODE ? modeDomains[a++] : null;
  }
  System.arraycopy(AGG.names(_agg),0,names,_gbCols.length,_agg.length);
  final AGG[] agg=_agg;
  Frame f=new MRTask(){
    @Override public void map(    Chunk[] c,    NewChunk[] ncs){
      int start=(int)c[0].start();
      for (int i=0; i < c[0]._len; ++i) {
        G g=grps[i + start];
        int j=0;
        for (; j < g._ds.length; ++j)         ncs[j].addNum(g._ds[j]);
        for (int a=0; a < agg.length; ++a) {
          byte type=agg[a]._type;
switch (type) {
case AGG.T_N:
            ncs[j++].addNum(g._N);
          break;
case AGG.T_AVG:
        ncs[j++].addNum(g._avs[a]);
      break;
case AGG.T_MIN:
    ncs[j++].addNum(g._min[a]);
  break;
case AGG.T_MAX:
ncs[j++].addNum(g._max[a]);
break;
case AGG.T_VAR:
ncs[j++].addNum(g._vars[a]);
break;
case AGG.T_SD:
ncs[j++].addNum(g._sdevs[a]);
break;
case AGG.T_SUM:
ncs[j++].addNum(g._sum[a]);
break;
case AGG.T_SS:
ncs[j++].addNum(g._ss[a]);
break;
case AGG.T_ND:
ncs[j++].addNum(g._ND[a]);
break;
case AGG.T_F:
ncs[j++].addNum(g._f[a]);
break;
case AGG.T_L:
ncs[j++].addNum(g._l[a]);
break;
case AGG.T_MODE:
ncs[j++].addNum(Arrays.asList(modeDomains[a]).indexOf(g._mode[a]));
break;
default :
throw new IllegalArgumentException("Unsupported aggregation type: " + type);
}
}
}
}
}
.doAll(nCols,v).outputFrame(names,domains);
p1._g=null;
Keyed.remove(v._key);
e.pushAry(f);
}
