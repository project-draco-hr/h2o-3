{
  byte type;
  int col;
  for (int i=0; i < agg.length; ++i) {
    col=agg[i]._c;
    if (c != null) {
      if (c[col].isNA(chkRow))       setNA(g,1L,i);
    }
 else {
      setNA(g,that._NA[i],i);
    }
    if ((type=agg[i]._type) == AGG.T_N)     continue;
    if (c != null)     if (!agg[i].isAll() && c[col].isNA(chkRow))     continue;
    long bits=-1;
    if (c != null) {
      if (c[col].isNA(chkRow))       continue;
      bits=Double.doubleToRawLongBits(c[col].atd(chkRow));
    }
    if (type == AGG.T_ND) {
      continue;
    }
switch (type) {
case AGG.T_AVG:
case AGG.T_SUM:
      setSum(g,c == null ? Double.doubleToRawLongBits(that._sum[i]) : bits,i);
    break;
case AGG.T_MIN:
  setMin(g,c == null ? Double.doubleToRawLongBits(that._min[i]) : bits,i);
break;
case AGG.T_MAX:
setMax(g,c == null ? Double.doubleToRawLongBits(that._max[i]) : bits,i);
break;
case AGG.T_VAR:
case AGG.T_SD:
setSum(g,c == null ? Double.doubleToRawLongBits(that._sum[i]) : bits,i);
case AGG.T_SS:
setSS(g,c == null ? Double.doubleToRawLongBits(that._ss[i]) : bits,i,c == null);
break;
case AGG.T_F:
setFirst(g,c == null ? that._f[i] : chkRow + rowOffset,i);
break;
case AGG.T_L:
setLast(g,c == null ? that._l[i] : chkRow + rowOffset,i);
break;
default :
throw new IllegalArgumentException("Unsupported aggregation type: " + type);
}
}
}
