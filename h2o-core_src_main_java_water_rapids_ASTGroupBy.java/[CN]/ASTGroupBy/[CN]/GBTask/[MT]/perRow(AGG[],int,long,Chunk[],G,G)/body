{
  byte type;
  int col;
  long vals[]=new long[6];
  for (int i=0; i < agg.length; ++i) {
    col=agg[i]._c;
    if (c != null) {
      if (c[col].isNA(chkRow))       setNA(g,1L,i);
    }
 else {
      setNA(g,that._NA[i],i);
    }
    if ((type=agg[i]._type) == AGG.T_N)     continue;
    if (c != null)     if (!agg[i].isAll() && c[col].isNA(chkRow))     continue;
    long bits=-1;
    if (c != null) {
      if (c[col].isNA(chkRow))       continue;
      bits=Double.doubleToRawLongBits(c[col].atd(chkRow));
    }
    vals[0]=c == null ? that._f[i] : chkRow + rowOffset;
    vals[1]=c == null ? that._l[i] : chkRow + rowOffset;
    vals[2]=c == null ? Double.doubleToRawLongBits(that._min[i]) : bits;
    vals[3]=c == null ? Double.doubleToRawLongBits(that._max[i]) : bits;
    vals[4]=c == null ? Double.doubleToRawLongBits(that._sum[i]) : bits;
    vals[5]=c == null ? Double.doubleToRawLongBits(that._ss[i]) : bits;
    if (type == AGG.T_ND) {
      continue;
    }
switch (type) {
case AGG.T_F:
      setFirst(g,vals[0],i);
    break;
case AGG.T_L:
  setLast(g,vals[1],i);
break;
case AGG.T_MIN:
setMin(g,vals[2],i);
break;
case AGG.T_MAX:
setMax(g,vals[3],i);
break;
case AGG.T_AVG:
case AGG.T_SUM:
setSum(g,vals[4],i);
break;
case AGG.T_VAR:
case AGG.T_SD:
case AGG.T_SS:
setSS(g,vals[5],i);
break;
default :
throw new IllegalArgumentException("Unsupported aggregation type: " + type);
}
}
}
