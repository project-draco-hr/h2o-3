{
  if (v.type() == Env.NULL)   return null;
  env.push(v);
  long cols[];
  if (env.isNum()) {
    int col=(int)env.popDbl();
    if (col < 0 && col < -len)     col=0;
    if (col < 0) {
      ValSeries s=new ValSeries(new long[]{col},null);
      s.setSlice(!isCol,isCol);
      return select(len,s,env,isCol);
    }
    return new long[]{col};
  }
  if (env.isSeries()) {
    ValSeries a=env.popSeries();
    if (!a.isValid())     throw new IllegalArgumentException("Cannot mix negative and positive array selection.");
    if (a.isColSelector())     return a.toArray();
    if (a.isNum() && !a.all_neg())     return select(len,new ValNum(a.toNum()),env,isCol);
    Frame ary=env.peekAry();
    Vec v0=a.all_neg() ? ary.anyVec().makeCon(1) : ary.anyVec().makeZero();
    final ValSeries a0=a;
    Frame fr=a0.all_neg() ? new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs._len + cs.start(); ++i)         if (a0.contains(-i))         cs.set((int)(i - cs.start() - 1),0);
      }
    }
.doAll(v0).getResult()._fr : new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs._len + cs.start(); ++i)         if (a0.contains(i))         cs.set((int)(i - cs.start()),i + 1);
      }
    }
.doAll(v0).getResult()._fr;
    return fr;
  }
  if (env.isSpan()) {
    ValSpan a=env.popSpan();
    if (!a.isValid())     throw new IllegalArgumentException("Cannot mix negative and positive array selection.");
    if (a.isColSelector())     return a.toArray();
    Frame ary=env.peekAry();
    final ValSpan a0=a;
    Vec v0=a.all_neg() ? ary.anyVec().makeCon(1) : ary.anyVec().makeZero();
    Frame fr=a0.all_neg() ? new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs._len + cs.start(); ++i)         if (a0.contains(-i))         cs.set((int)(i - cs.start() - 1),0);
      }
    }
.doAll(v0).getResult()._fr : new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs._len + cs.start(); ++i)         if (a0.contains(i))         cs.set((int)(i - cs.start()),i + 1);
      }
    }
.doAll(v0).getResult()._fr;
    return fr;
  }
  Frame ary=env.pop0Ary();
  if (ary.numCols() != 1)   throw new IllegalArgumentException("Selector must be a single column: " + ary.names());
  Vec vec=ary.anyVec();
  if (ary.numRows() == len && vec.min() >= 0 && vec.max() <= 1 && vec.isInt())   return ary;
  if (ary.numRows() > 10000000)   throw H2O.fail("Unimplemented: Cannot explicitly select > 10000000 rows in slice.");
  cols=MemoryManager.malloc8((int)ary.numRows());
  for (int i=0; i < cols.length; ++i) {
    if (vec.isNA(i))     throw new IllegalArgumentException("Can not use NA as index!");
    cols[i]=vec.at8(i);
  }
  return cols;
}
