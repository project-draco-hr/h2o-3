{
  if (v.type() == Env.NULL)   return null;
  env.push(v);
  long cols[];
  if (env.isNum()) {
    int col=(int)env.popDbl();
    if (col < 0 && col < -len)     col=0;
    if (col < 0) {
      ValSeries s=new ValSeries(new long[]{col},null);
      s.setSlice(!isCol,isCol);
      return select(len,s,env,isCol);
    }
    return new long[]{col};
  }
  if (env.isSeries()) {
    ValSeries a=env.popSeries();
    if (!a.isValid())     throw new IllegalArgumentException("Cannot mix negative and positive array selection.");
    if (a.isColSelector())     return a.toArray();
    if (a.isNum() && !a.all_neg())     return select(len,new ValNum(a.toNum()),env,isCol);
    Frame ary=env.peekAry();
    Vec v0=a.all_neg() ? ary.anyVec().makeCon(1) : ary.anyVec().makeZero();
    final ValSeries a0=a;
    Frame fr=a0.all_neg() ? new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs._len + cs.start(); ++i)         if (a0.contains(-i))         cs.set((int)(i - cs.start()),0);
      }
    }
.doAll(v0).getResult()._fr : new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs._len + cs.start(); ++i)         if (a0.contains(i))         cs.set((int)(i - cs.start()),i + 1);
      }
    }
.doAll(v0).getResult()._fr;
    return fr;
  }
  if (env.isSpan()) {
    ValSpan a=env.popSpan();
    if (Double.isNaN(a._max) || a._max > len)     a._max=Math.max(0,len - 1);
    if (!a.isValid())     throw new IllegalArgumentException("Cannot mix negative and positive array selection.");
    if (a.isColSelector())     return a.toArray();
    Frame ary=env.peekAry();
    final ValSpan a0=a;
    Vec v0=a.all_neg() ? ary.anyVec().makeCon(1) : ary.anyVec().makeZero();
    Frame fr=a0.all_neg() ? new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs._len + cs.start(); ++i)         if (a0.contains(-i))         cs.set((int)(i - cs.start() - 1),0);
      }
    }
.doAll(v0).getResult()._fr : new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs._len + cs.start(); ++i)         if (a0.contains(i))         cs.set((int)(i - cs.start()),i + 1);
      }
    }
.doAll(v0).getResult()._fr;
    return fr;
  }
  Frame ary=env.popAry();
  if (ary.numCols() != 1)   throw new IllegalArgumentException("Selector must be a single column: " + AtoS(ary.names()));
  Vec vec=ary.anyVec();
  if (isCol) {
    if (vec.min() != 0 && vec.max() != 1 && !vec.isInt())     throw new IllegalArgumentException("Vec selector must be a single columns of 1s and 0s.");
    final ASTGroupBy.IcedNBHS<IcedInt> hs=new ASTGroupBy.IcedNBHS();
    new MRTask(){
      @Override public void map(      Chunk c){
        int start=(int)c.start();
        for (int i=0; i < c._len; ++i) {
          if (c.at8(i) == 1 && len > (i + start))           hs.add(new IcedInt(start + i));
        }
      }
    }
.doAll(ary);
    cols=new long[(int)Math.min(hs.size(),len)];
    Iterator<IcedInt> it=hs.iterator();
    int j=0;
    while (j < cols.length && it.hasNext())     cols[j++]=it.next()._val;
  }
 else {
    if (ary.numRows() == len && vec.min() >= 0 && vec.max() <= 1 && vec.isInt())     return ary;
    if (ary.numRows() > 10000000)     throw H2O.fail("Unimplemented: Cannot explicitly select > 10000000 rows in slice.");
    cols=MemoryManager.malloc8((int)ary.numRows());
    for (int i=0; i < cols.length; ++i) {
      if (vec.isNA(i))       throw new IllegalArgumentException("Can not use NA as index!");
      cols[i]=vec.at8(i);
    }
  }
  return cols;
}
