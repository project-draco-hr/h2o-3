{
  QuantileModel model=null;
  try {
    Scope.enter();
    _parms.read_lock_frames(Quantile.this);
    init(true);
    model=new QuantileModel(dest(),_parms,new QuantileModel.QuantileOutput(Quantile.this));
    model._output._parameters=_parms;
    model._output._quantiles=new double[_ncols][_parms._probs.length];
    model.delete_and_lock(_key);
    Vec vecs[]=train().vecs();
    for (int n=0; n < _ncols; n++) {
      if (!isRunning())       return;
      Vec vec=vecs[n];
      if (vec.isBad()) {
        model._output._quantiles[n]=new double[_parms._probs.length];
        Arrays.fill(model._output._quantiles[n],Double.NaN);
        continue;
      }
      double sumRows=_weights == null ? vec.length() - vec.naCnt() : new SumWeights().doAll(vec,_weights).sum;
      Histo h1=new Histo(vec.min(),vec.max(),0,sumRows,vec.isInt());
      h1=_weights == null ? h1.doAll(vec) : h1.doAll(vec,_weights);
      for (int p=0; p < _parms._probs.length; p++) {
        double prob=_parms._probs[p];
        Histo h=h1;
        model._output._iterations++;
        while (Double.isNaN(model._output._quantiles[n][p]=h.findQuantile(prob,_parms._combine_method))) {
          h=_weights == null ? h.refinePass(prob).doAll(vec) : h.refinePass(prob).doAll(vec,_weights);
          model._output._iterations++;
        }
        model.update(_key);
        update(1);
      }
      StringBuilder sb=new StringBuilder();
      sb.append("Quantile: iter: ").append(model._output._iterations).append(" Qs=").append(Arrays.toString(model._output._quantiles[n]));
      Log.debug(sb);
    }
    done();
  }
 catch (  Throwable t) {
    Job thisJob=DKV.getGet(_key);
    if (thisJob._state == JobState.CANCELLED) {
      Log.info("Job cancelled by user.");
    }
 else {
      t.printStackTrace();
      failed(t);
      throw t;
    }
  }
 finally {
    updateModelOutput();
    if (model != null)     model.unlock(_key);
    _parms.read_unlock_frames(Quantile.this);
    Scope.exit(model == null ? null : model._key);
  }
  tryComplete();
}
