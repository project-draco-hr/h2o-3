{
  java.util.Arrays.fill(preds,0);
  for (int i=0; i < _effective_n_classes; i++) {
    int k=_nclasses == 1 ? 0 : i + 1;
    for (int j=0; j < _ntrees; j++) {
      try {
        int itree=i * _ntrees + j;
        byte[] tree=_compressed_trees[itree];
        if (tree == null) {
          tree=_reader.getBinaryFile(String.format("trees/t%02d_%03d.bin",i,j));
          _compressed_trees[itree]=tree;
        }
        preds[k]+=scoreTree(tree,data,_nclasses);
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
catch (      Exception e) {
        System.out.println("Exception " + e + " when scoring tree "+ i+ ", "+ j);
        throw e;
      }
    }
  }
  boolean isBinomialModel=_nclasses == 2 && !_binomial_double_trees;
  if (_nclasses == 1) {
    preds[0]/=_ntrees;
  }
 else {
    if (isBinomialModel) {
      preds[1]/=_ntrees;
      preds[2]=1.0 - preds[1];
    }
 else {
      double sum=0;
      for (int i=1; i <= _nclasses; i++) {
        sum+=preds[i];
      }
      if (sum > 0)       for (int i=1; i <= _nclasses; i++) {
        preds[i]/=sum;
      }
    }
    if (_balanceClasses)     GenModel.correctProbabilities(preds,_priorClassDistrib,_modelClassDistrib);
    preds[0]=GenModel.getPrediction(preds,_priorClassDistrib,data,_defaultThreshold);
  }
  return preds;
}
