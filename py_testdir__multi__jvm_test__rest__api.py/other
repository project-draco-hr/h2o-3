import sys, pprint, os
sys.path.insert(1, '..')
sys.path.insert(1, '.')
sys.path.insert(1, os.path.join('..', 'py'))
import h2o, h2o_util
import os
import argparse
import time
import json
import requests
parser = argparse.ArgumentParser(description='Run basic H2O REST API tests.')
parser.add_argument('--verbose', '-v', help='verbose output', action='count')
parser.add_argument('--usecloud', help='ip:port to attach to', default='')
parser.add_argument('--host', help='hostname to attach to', default='localhost')
parser.add_argument('--port', help='port to attach to', type=int, default=54321)
args = parser.parse_args()
verbose = (True if (args.verbose > 0) else False)
verboser = (True if (args.verbose > 1) else False)
verbosest = (True if (args.verbose > 2) else False)
h2o.H2O.verbose = verboser
if (len(args.usecloud) > 0):
    arr = args.usecloud.split(':')
    args.host = arr[0]
    args.port = int(arr[1])
host = args.host
port = args.port
h2o.H2O.verboseprint(('host: ' + str(host)))
h2o.H2O.verboseprint(('port' + str(port)))
pp = pprint.PrettyPrinter(indent=4)
a_node = h2o.H2O(host, port)
algos = ['example', 'kmeans', 'deeplearning', 'drf', 'glm', 'gbm', 'pca', 'naivebayes', 'word2vec', 'quantile', 'grep']
algo_additional_default_params = {'grep': {'regex': '.*', }, 'kmeans': {'k': 2, }, }
clean_up_after = False
h2o.H2O.verboseprint('connected to: ', str(host), ':', str(port))
models = a_node.models()
if h2o.H2O.verbose:
    print 'Models: '
    pp.pprint(models)
models = a_node.models(api_version=92)
if h2o.H2O.verbose:
    print 'ModelsV92: '
    pp.pprint(models)
frames = a_node.frames(row_count=5)
if h2o.H2O.verbose:
    print 'Frames: '
    pp.pprint(frames)
if verbose:
    print 'Testing /Metadata/schemas. . .'
schemas = a_node.schemas(timeoutSecs=240)
assert ('schemas' in schemas), ("FAIL: failed to find 'schemas' field in output of /Metadata/schemas: " + repr(schemas))
assert (type(schemas['schemas']) is list), ("'schemas' field in output of /Metadata/schemas is not a list: " + repr(schemas))
assert (len(schemas['schemas']) > 0), ("'schemas' field in output of /Metadata/schemas is empty: " + repr(schemas))
if verboser:
    print 'Schemas: '
    pp.pprint(schemas)
if verbose:
    print 'Testing /Metadata/schemas/FrameV2. . .'
schemas = a_node.schema(schemaname='FrameV2', timeoutSecs=240)
assert ('schemas' in schemas), ("FAIL: failed to find 'schemas' field in output of /Metadata/schemas/FrameV2: " + repr(schemas))
assert (type(schemas['schemas']) is list), ("'schemas' field in output of /Metadata/schemas/FrameV2 is not a list: " + repr(schemas))
assert (len(schemas['schemas']) == 1), ("'schemas' field in output of /Metadata/schemas/FrameV2 has an unexpected length: " + repr(schemas))
if verboser:
    print 'Schemas: '
    pp.pprint(schemas)
url_prefix = ((('http://' + host) + ':') + str(port))
urls = {'': 'Analytics', '/': 'Analytics', '/index.html': 'Analytics', '/flow/index.html': 'modal', '/LATEST/Cloud.html': 'Ready', }
for (suffix, expected_word) in urls.iteritems():
    url = (url_prefix + suffix)
    h2o.H2O.verboseprint((('Testing ' + url) + '. . .'))
    r = requests.get(url)
    assert r.text.find(expected_word), ((("FAIL: didn't find '" + expected_word) + "' in: ") + url)
if verbose:
    print 'Testing /ModelBuilders. . .'
model_builders = a_node.model_builders(timeoutSecs=240)
if h2o.H2O.verbose:
    print 'ModelBuilders: '
    pp.pprint(model_builders)
for algo in algos:
    assert (algo in model_builders['model_builders']), ('FAIL: Failed to find algo: ' + algo)
    builder = model_builders['model_builders'][algo]
    validate_builder(algo, builder)
if verbose:
    print 'Testing /ModelBuilders/{algo}. . .'
for algo in algos:
    model_builder = a_node.model_builders(algo=algo, timeoutSecs=240)
    assert (algo in model_builder['model_builders']), ('FAIL: Failed to find algo: ' + algo)
    builder = model_builders['model_builders'][algo]
    validate_builder(algo, builder)
if verbose:
    print 'Testing /ModelMetrics. . .'
model_metrics = a_node.model_metrics(timeoutSecs=240)
if h2o.H2O.verbose:
    print 'ModelMetrics: '
    pp.pprint(model_metrics)
if verbose:
    print 'Cleaning up old stuff. . .'
cleanup(a_node)
if verbose:
    print 'Testing /Metadata/endpoints. . .'
endpoints = a_node.endpoints()
assert ('routes' in endpoints), 'FAIL: failed to find routes in the endpoints result.'
assert (type(endpoints['routes']) is list), 'FAIL: routes in the endpoints result is not a list.'
assert (len(endpoints['routes']) > 0), 'FAIL: routes list in the endpoints result is empty.'
assert (type(endpoints['routes'][0]) is dict), 'FAIL: routes[0] in the endpoints result is not a dict.'
assert ('input_schema' in endpoints['routes'][0]), "FAIL: routes[0] in the endpoints result does not have an 'input_schema' field."
if verbose:
    print 'Testing /Metadata/schemas. . .'
schemas = a_node.schemas()
assert ('schemas' in schemas), 'FAIL: failed to find schemas in the schemas result.'
assert (type(schemas['schemas']) is list), 'FAIL: schemas in the schemas result is not a list.'
assert (len(schemas['schemas']) > 0), 'FAIL: schemas list in the schemas result is empty.'
assert (type(schemas['schemas'][0]) is dict), 'FAIL: schemas[0] in the schemas result is not a dict.'
assert ('fields' in schemas['schemas'][0]), "FAIL: schemas[0] in the schemas result does not have an 'fields' field."
if verbose:
    print 'Testing CreateFrame. . .'
created_job = a_node.create_frame(dest='created')
a_node.poll_job(job_key=created_job['key']['name'])
frames = a_node.frames(key='created')['frames']
assert (len(frames) == 1), ("FAIL: expected to find 1 frame called 'created', found: " + str(len(frames)))
assert (frames[0]['key']['name'] == 'created'), ("FAIL: expected to find 1 frame called 'created', found: " + repr(frames))
created = frames[0]
assert ('rows' in created), "FAIL: failed to find 'rows' field in CreateFrame result."
assert (created['rows'] == 10000), ((("FAIL: expected value of 'rows' field in CreateFrame result to be: " + str(10000)) + ', found: ') + str(created['rows']))
assert ('columns' in created), "FAIL: failed to find 'columns' field in CreateFrame result."
assert (len(created['columns']) == 10), ((("FAIL: expected value of 'columns' field in CreateFrame result to be: " + str(10)) + ', found: ') + str(len(created['columns'])))
datasets_to_import = [DatasetSpec('prostate_clustering', '../../smalldata/logreg/prostate.csv', 380, 'Clustering', None, ['ID']), DatasetSpec('prostate_binomial', '../../smalldata/logreg/prostate.csv', 380, 'Binomial', 'CAPSULE', ['ID']), DatasetSpec('prostate_regression', '../../smalldata/logreg/prostate.csv', 380, 'Regression', 'AGE', ['ID']), DatasetSpec('airlines_binomial', '../../smalldata/airlines/allyears2k_headers.zip', 43978, 'Binomial', 'IsDepDelayed', ['IsArrDelayed', 'ArrDelay', 'DepDelay']), DatasetSpec('iris_multinomial', '../../smalldata/iris/iris_wheader.csv', 150, 'Multinomial', 'class', [])]
datasets = {}
for dataset_spec in datasets_to_import:
    dataset = dataset_spec.import_and_validate_dataset(a_node)
    datasets[dataset_spec['dest_key']] = dataset_spec
frames = a_node.frames(row_count=5)['frames']
frames_dict = h2o_util.list_to_dict(frames, 'key/name')
if h2o.H2O.verbose:
    print 'frames: '
    pp.pprint(frames)
if h2o.H2O.verbose:
    print 'frames_dict: '
    pp.pprint(frames_dict)
assert ('prostate_binomial' in frames_dict), (('FAIL: Failed to find ' + 'prostate_binomial') + ' in Frames list.')
assert (not frames_dict['prostate_binomial']['is_text']), 'FAIL: Parsed Frame is is_text'
frames = a_node.frames(key='prostate_binomial', row_count=5)['frames']
frames_dict = h2o_util.list_to_dict(frames, 'key/name')
assert ('prostate_binomial' in frames_dict), 'FAIL: Failed to find prostate.hex in Frames list.'
columns_dict = h2o_util.list_to_dict(frames[0]['columns'], 'label')
assert ('CAPSULE' in columns_dict), 'FAIL: Failed to find CAPSULE in Frames/prostate.hex.'
assert ('AGE' in columns_dict), 'FAIL: Failed to find AGE in Frames/prostate.hex/columns.'
assert ('histogram_bins' in columns_dict['AGE']), 'FAIL: Failed to find bins in Frames/prostate.hex/columns/AGE.'
h2o.H2O.verboseprint(('bins: ' + repr(columns_dict['AGE']['histogram_bins'])))
assert (None is columns_dict['AGE']['histogram_bins']), 'FAIL: Failed to clear bins field.'
frames = a_node.columns(key='prostate_binomial')['frames']
columns_dict = h2o_util.list_to_dict(frames[0]['columns'], 'label')
assert ('ID' in columns_dict), 'FAIL: Failed to find ID in Frames/prostate.hex/columns.'
assert ('AGE' in columns_dict), 'FAIL: Failed to find AGE in Frames/prostate.hex/columns.'
assert ('histogram_bins' in columns_dict['AGE']), 'FAIL: Failed to find bins in Frames/prostate.hex/columns/AGE.'
h2o.H2O.verboseprint(('bins: ' + repr(columns_dict['AGE']['histogram_bins'])))
assert (None is columns_dict['AGE']['histogram_bins']), 'FAIL: Failed to clear bins field.'
frames = a_node.column(key='prostate_binomial', column='AGE')['frames']
columns_dict = h2o_util.list_to_dict(frames[0]['columns'], 'label')
assert ('AGE' in columns_dict), 'FAIL: Failed to find AGE in Frames/prostate.hex/columns.'
assert ('histogram_bins' in columns_dict['AGE']), 'FAIL: Failed to find bins in Frames/prostate.hex/columns/AGE.'
h2o.H2O.verboseprint(('bins: ' + repr(columns_dict['AGE']['histogram_bins'])))
assert (None is columns_dict['AGE']['histogram_bins']), 'FAIL: Failed to clear bins field.'
frames = a_node.summary(key='prostate_binomial', column='AGE')['frames']
columns_dict = h2o_util.list_to_dict(frames[0]['columns'], 'label')
assert ('AGE' in columns_dict), 'FAIL: Failed to find AGE in Frames/prostate.hex/columns/AGE/summary.'
col = columns_dict['AGE']
h2o_util.assertKeysExistAndNonNull(col, '', ['label', 'missing_count', 'zero_count', 'positive_infinity_count', 'negative_infinity_count', 'mins', 'maxs', 'mean', 'sigma', 'type', 'data', 'precision', 'histogram_bins', 'histogram_base', 'histogram_stride', 'percentiles'])
h2o_util.assertKeysExist(col, '', ['domain', 'string_data'])
assert (col['mins'][0] == 43), 'FAIL: Failed to find 43 as the first min for AGE.'
assert (col['maxs'][0] == 79), 'FAIL: Failed to find 79 as the first max for AGE.'
assert (col['mean'] == 66.03947368421052), 'FAIL: Failed to find 66.03947368421052 as the mean for AGE.'
assert (col['sigma'] == 6.527071269173308), 'FAIL: Failed to find 6.527071269173308 as the sigma for AGE.'
assert (col['type'] == 'int'), 'FAIL: Failed to find int as the type for AGE.'
assert (col['data'][0] == 65), 'FAIL: Failed to find 65 as the first data for AGE.'
assert (col['precision'] == (-1)), 'FAIL: Failed to find -1 as the precision for AGE.'
assert (col['histogram_bins'][0] == 1), 'FAIL: Failed to find 1 as the first bin for AGE.'
assert (col['histogram_base'] == 43), 'FAIL: Failed to find 43 as the histogram_base for AGE.'
assert (col['histogram_stride'] == 1), 'FAIL: Failed to find 1 as the histogram_stride for AGE.'
assert (col['percentiles'][0] == 43), ('FAIL: Failed to find 43 as the first percentile for AGE. ' + str(col['percentiles'][0]))
if verbose:
    print 'Testing SplitFrame with named dest_keys. . .'
splits = a_node.split_frame(dataset='prostate_binomial', ratios=[0.8], dest_keys=['bigger', 'smaller'])
frames = a_node.frames()['frames']
validate_frame_exists('bigger', frames)
validate_frame_exists('smaller', frames)
bigger = a_node.frames(key='bigger')['frames'][0]
smaller = a_node.frames(key='smaller')['frames'][0]
assert (bigger['rows'] == 304), ('FAIL: 80/20 SplitFrame yielded the wrong number of rows.  Expected: 304; got: ' + bigger['rows'])
assert (smaller['rows'] == 76), ('FAIL: 80/20 SplitFrame yielded the wrong number of rows.  Expected: 76; got: ' + smaller['rows'])
if verbose:
    print 'Testing SplitFrame with generated dest_keys. . .'
splits = a_node.split_frame(dataset='prostate_binomial', ratios=[0.5])
frames = a_node.frames()['frames']
validate_frame_exists(splits['dest_keys'][0]['name'], frames)
validate_frame_exists(splits['dest_keys'][1]['name'], frames)
first = a_node.frames(key=splits['dest_keys'][0]['name'])['frames'][0]
second = a_node.frames(key=splits['dest_keys'][1]['name'])['frames'][0]
assert (first['rows'] == 190), ('FAIL: 50/50 SplitFrame yielded the wrong number of rows.  Expected: 190; got: ' + first['rows'])
assert (second['rows'] == 190), ('FAIL: 50/50 SplitFrame yielded the wrong number of rows.  Expected: 190; got: ' + second['rows'])
print 'Terminating test before model-building'
sys.exit(0)
models_to_build = [ModelSpec.for_dataset('kmeans_prostate', 'kmeans', datasets['prostate_clustering'], {'k': 2, }), ModelSpec.for_dataset('glm_prostate_regression', 'glm', datasets['prostate_regression'], {'family': 'gaussian', }), ModelSpec.for_dataset('glm_prostate_binomial', 'glm', datasets['prostate_binomial'], {'family': 'binomial', }), ModelSpec.for_dataset('deeplearning_prostate_regression', 'deeplearning', datasets['prostate_regression'], {'epochs': 1, }), ModelSpec.for_dataset('deeplearning_prostate_binomial', 'deeplearning', datasets['prostate_binomial'], {'epochs': 1, 'hidden': [20, 20], }), ModelSpec.for_dataset('deeplearning_airlines_binomial', 'deeplearning', datasets['airlines_binomial'], {'epochs': 1, 'hidden': [10, 10], }), ModelSpec.for_dataset('deeplearning_iris_multinomial', 'deeplearning', datasets['iris_multinomial'], {'epochs': 1, }), ModelSpec.for_dataset('gbm_prostate_regression', 'gbm', datasets['prostate_regression'], {'ntrees': 5, 'family': 'gaussian', }), ModelSpec.for_dataset('gbm_prostate_binomial', 'gbm', datasets['prostate_binomial'], {'ntrees': 5, 'family': 'multinomial', }), ModelSpec.for_dataset('gbm_airlines_binomial', 'gbm', datasets['airlines_binomial'], {'ntrees': 5, 'family': 'multinomial', }), ModelSpec.for_dataset('gbm_iris_multinomial', 'gbm', datasets['iris_multinomial'], {'ntrees': 5, 'family': 'multinomial', })]
built_models = {}
for model_spec in models_to_build:
    model = model_spec.build_and_validate_model(a_node)
    built_models[model_spec['dest_key']] = model
if verbose:
    print 'Testing ModelBuilder default parameters. . .'
model_builders = a_node.model_builders(timeoutSecs=240)['model_builders']
server_algos = model_builders.keys()
assert (len((set(server_algos) - set(algos))) == 0), ((("FAIL: Our set of algos doesn't match what the server knows about.  Ours: " + repr(algos)) + "; server's: ") + repr(server_algos))
for (algo, model_builder) in model_builders.iteritems():
    parameters_list = model_builder['parameters']
    test_parameters = {value['name']: value['default_value'] for value in parameters_list}
    if (algo in algo_additional_default_params):
        test_parameters.update(algo_additional_default_params[algo])
    parameters_validation = a_node.validate_model_parameters(algo=algo, training_frame=None, parameters=test_parameters, timeoutSecs=240)
    assert ('validation_error_count' in parameters_validation), 'FAIL: Failed to find validation_error_count in good-parameters parameters validation result.'
    h2o.H2O.verboseprint('Bad params validation messages: ', repr(parameters_validation))
    expected_count = 1
    if (expected_count != parameters_validation['validation_error_count']):
        print 'validation errors: '
        pp.pprint(parameters_validation)
    assert (expected_count == parameters_validation['validation_error_count']), (('FAIL: ' + str(expected_count)) + ' != validation_error_count in good-parameters parameters validation result.')
    assert ('training_frame' == parameters_validation['validation_messages'][0]['field_name']), 'FAIL: First validation message is about missing training frame.'
model_builder = a_node.model_builders(algo='deeplearning', timeoutSecs=240)['model_builders']['deeplearning']
dl_test_parameters_list = model_builder['parameters']
dl_test_parameters = {value['name']: value['default_value'] for value in dl_test_parameters_list}
parameters_validation = a_node.validate_model_parameters(algo='deeplearning', training_frame=None, parameters=dl_test_parameters, timeoutSecs=240)
assert ('validation_error_count' in parameters_validation), 'FAIL: Failed to find validation_error_count in good-parameters parameters validation result.'
h2o.H2O.verboseprint('Bad params validation messages: ', repr(parameters_validation))
if (1 != parameters_validation['validation_error_count']):
    print 'validation errors: '
    pp.pprint(parameters_validation)
assert (1 == parameters_validation['validation_error_count']), 'FAIL: 1 != validation_error_count in good-parameters parameters validation result.'
assert ('training_frame' == parameters_validation['validation_messages'][0]['field_name']), 'FAIL: First validation message is about missing training frame.'
dl_test_parameters = {'response_column': 'CAPSULE', 'hidden': '[10, 20, 10]', }
parameters_validation = a_node.validate_model_parameters(algo='deeplearning', training_frame=None, parameters=dl_test_parameters, timeoutSecs=240)
assert ('validation_error_count' in parameters_validation), 'FAIL: Failed to find validation_error_count in good-parameters parameters validation result.'
h2o.H2O.verboseprint('Bad params validation messages: ', repr(parameters_validation))
if (1 != parameters_validation['validation_error_count']):
    print 'validation errors: '
    pp.pprint(parameters_validation)
assert (1 == parameters_validation['validation_error_count']), 'FAIL: 1 != validation_error_count in good-parameters parameters validation result.'
assert ('training_frame' == parameters_validation['validation_messages'][0]['field_name']), 'FAIL: First validation message is about missing training frame.'
dl_test_parameters = {'response_column': 'CAPSULE', 'hidden': '[10, 20, 10]', 'input_dropout_ratio': 27, }
parameters_validation = a_node.validate_model_parameters(algo='deeplearning', training_frame=None, parameters=dl_test_parameters, timeoutSecs=240)
assert ('validation_error_count' in parameters_validation), 'FAIL: Failed to find validation_error_count in bad-parameters parameters validation result (input_dropout_ratio).'
h2o.H2O.verboseprint('Good params validation messages: ', repr(parameters_validation))
assert (2 == parameters_validation['validation_error_count']), ('FAIL: 2 != validation_error_count in bad-parameters parameters validation result: ' + repr(parameters_validation))
assert ('training_frame' == parameters_validation['validation_messages'][0]['field_name']), 'FAIL: First validation message is about missing training frame.'
found_expected_error = False
for validation_message in parameters_validation['validation_messages']:
    if ((validation_message['message_type'] == 'ERROR') and (validation_message['field_name'] == 'input_dropout_ratio')):
        found_expected_error = True
assert found_expected_error, 'FAIL: Failed to find error message about input_dropout_ratio in the validation messages.'
dl_test_parameters = {'hidden': '[10, 20, 10]', }
parameters_validation = a_node.validate_model_parameters(algo='deeplearning', training_frame='prostate_binomial', parameters=dl_test_parameters, timeoutSecs=240)
assert ('validation_error_count' in parameters_validation), 'FAIL: Failed to find validation_error_count in bad-parameters parameters validation result (response_column).'
h2o.H2O.verboseprint('Good params validation messages: ', repr(parameters_validation))
assert (1 == parameters_validation['validation_error_count']), ('FAIL: 1 != validation_error_count in bad-parameters parameters validation result: ' + repr(parameters_validation))
assert ('response_column' == parameters_validation['validation_messages'][0]['field_name']), 'FAIL: First validation message is about missing training frame.'
if verbose:
    print 'About to try to build a DeepLearning model with bad parameters. . .'
dl_prostate_bad_parameters = {'response_column': 'CAPSULE', 'hidden': '[10, 20, 10]', 'input_dropout_ratio': 27, }
parameters_validation = a_node.build_model(algo='deeplearning', destination_key='deeplearning_prostate_binomial_bad', training_frame='prostate_binomial', parameters=dl_prostate_bad_parameters, timeoutSecs=240)
validate_validation_messages(parameters_validation, ['input_dropout_ratio'])
assert (parameters_validation['__http_response']['status_code'] == requests.codes.bad_request), ('FAIL: expected 400 Bad Request from a bad build request, got: ' + str(parameters_validation['__http_response']['status_code']))
if verbose:
    print 'Done trying to build DeepLearning model with bad parameters.'
mm = a_node.compute_model_metrics(model='deeplearning_prostate_binomial', frame='prostate_binomial')
assert (mm is not None), ((('FAIL: Got a null result for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + 'prostate_binomial')
assert ('model_category' in mm), (((('FAIL: ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + 'prostate_binomial') + ' does not contain a model_category.')
assert ('Binomial' == mm['model_category']), ((((('FAIL: ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + 'prostate_binomial') + ' model_category is not Binomial, it is: ') + str(mm['model_category']))
assert ('AUC' in mm), ((((('FAIL: ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + 'prostate_binomial') + ' does not contain an AUC element: ') + h2o_util.dump_json(mm))
assert (type(mm['AUC']) is float), ((((('FAIL: ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + 'prostate_binomial') + ' AUC element is not a float: ') + h2o_util.dump_json(mm))
assert ('confusion_matrices' in mm), ((((('FAIL: ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + 'prostate_binomial') + ' does not contain a confusion_matrices element: ') + h2o_util.dump_json(mm))
assert (type(mm['confusion_matrices']) is list), ((((('FAIL: ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + 'prostate_binomial') + ' confusion_matrices element is not a list: ') + h2o_util.dump_json(mm))
h2o.H2O.verboseprint('ModelMetrics for scoring: ', 'deeplearning_prostate_binomial', ' on: ', 'prostate_binomial', ':  ', repr(mm))
mms = a_node.model_metrics()
assert ('model_metrics' in mms), 'FAIL: Failed to find model_metrics in result of /3/ModelMetrics.'
found_mm = False
for mm in mms['model_metrics']:
    assert ('model' in mm), ('FAIL: mm does not contain a model element: ' + repr(mm))
    assert ('name' in mm['model']), ("FAIL: mm[model] isn't a key with a name: " + repr(mm))
    assert ('type' in mm['model']), ('FAIL: mm[model] does not contain a type: ' + repr(mm))
    assert ('Key<Model>' == mm['model']['type']), ('FAIL: mm[model] type is not Key<Model>: ' + repr(mm['model']['type']))
    assert ('frame' in mm), ('FAIL: mm does not contain a frame element: ' + repr(mm))
    assert ('name' in mm['frame']), ('FAIL: mm[frame] does not contain a name: ' + repr(mm))
    assert ('type' in mm['frame']), ('FAIL: mm[frame] does not contain a type: ' + repr(mm))
    assert ('Key<Frame>' == mm['frame']['type']), ('FAIL: mm[frame] type is not Key<Frame>: ' + repr(mm))
    model_key = mm['model']['name']
    frame_key = mm['frame']['name']
    if ((model_key == 'deeplearning_prostate_binomial') and (frame_key == 'prostate_binomial')):
        found_mm = True
assert found_mm, ((('FAIL: Failed to find ModelMetrics object for model: ' + 'deeplearning_prostate_binomial') + ' and frame: ') + 'prostate_binomial')
mms = a_node.model_metrics('deeplearning_prostate_binomial', 'prostate_binomial')
assert (len(mms['model_metrics']) == 1), ('FAIL: expected 1 ModelMetrics, found: ' + str(len(mms['model_metrics'])))
a_node.delete_model_metrics('deeplearning_prostate_binomial', 'prostate_binomial')
mms = a_node.model_metrics('deeplearning_prostate_binomial', 'prostate_binomial')
assert (len(mms['model_metrics']) == 0), ('FAIL: expected 0 ModelMetrics, found: ' + str(len(mms['model_metrics'])))
p = a_node.predict(model='deeplearning_prostate_binomial', frame='prostate_binomial', destination_key='deeplearning_prostate_binomial_predictions')
validate_predictions(p, 'deeplearning_prostate_binomial', 'prostate_binomial', 380, destination_key='deeplearning_prostate_binomial_predictions')
validate_frame_exists('deeplearning_prostate_binomial_predictions')
h2o.H2O.verboseprint('Predictions for scoring: ', 'deeplearning_prostate_binomial', ' on: ', 'prostate_binomial', ':  ', repr(p))
p = a_node.predict(model='deeplearning_prostate_regression', frame='prostate_binomial')
validate_predictions(p, 'deeplearning_prostate_regression', 'prostate_binomial', 380)
h2o.H2O.verboseprint('Predictions for scoring: ', 'deeplearning_prostate_regression', ' on: ', 'prostate_binomial', ':  ', repr(p))
p = a_node.predict(model='gbm_prostate_binomial', frame='prostate_binomial')
validate_predictions(p, 'gbm_prostate_binomial', 'prostate_binomial', 380)
h2o.H2O.verboseprint('Predictions for scoring: ', 'gbm_prostate_binomial', ' on: ', 'prostate_binomial', ':  ', repr(p))
p = a_node.predict(model='gbm_prostate_regression', frame='prostate_binomial')
validate_predictions(p, 'gbm_prostate_regression', 'prostate_binomial', 380)
h2o.H2O.verboseprint('Predictions for scoring: ', 'gbm_prostate_regression', ' on: ', 'prostate_binomial', ':  ', repr(p))
p = a_node.predict(model='kmeans_prostate', frame='prostate_binomial')
validate_predictions(p, 'kmeans_prostate', 'prostate_binomial', 380)
h2o.H2O.verboseprint('Predictions for scoring: ', 'kmeans_prostate', ' on: ', 'prostate_binomial', ':  ', repr(p))
model = a_node.models(key='kmeans_prostate', find_compatible_frames=True)
found_kmeans = False
h2o.H2O.verboseprint('k-means model with find_compatible_frames output: ')
h2o.H2O.verboseprint('/Models/', 'kmeans_prostate', '?find_compatible_frames=true: ', repr(model))
h2o_util.assertKeysExist(model['models'][0], '', ['compatible_frames'])
assert ('prostate_binomial' in model['models'][0]['compatible_frames']), (('FAIL: Failed to find ' + 'prostate_binomial') + ' in compatible_frames list.')
result = a_node.frames(key='prostate_binomial', find_compatible_models=True, row_count=5)
frames = result['frames']
frames_dict = h2o_util.list_to_dict(frames, 'key/name')
assert ('prostate_binomial' in frames_dict), 'FAIL: Failed to find prostate.hex in Frames list.'
compatible_models = result['compatible_models']
models_dict = h2o_util.list_to_dict(compatible_models, 'key/name')
assert ('deeplearning_prostate_binomial' in models_dict), ((('FAIL: Failed to find ' + 'deeplearning_prostate_binomial') + ' in compatible models list: ') + repr(result))
assert ('deeplearning_prostate_binomial' in frames[0]['compatible_models']), 'FAIL: failed to find deeplearning_prostate_binomial in compatible_models for prostate.'
assert ('kmeans_prostate' in frames[0]['compatible_models']), 'FAIL: failed to find kmeans_prostate in compatible_models for prostate.'
h2o.H2O.verboseprint('/Frames/prosate.hex?find_compatible_models=true: ', repr(result))
if verbose:
    print 'Testing /Metadata/schemas again. . .'
schemas = a_node.schemas(timeoutSecs=240)
assert ('schemas' in schemas), ("FAIL: failed to find 'schemas' field in output of /Metadata/schemas: " + repr(schemas))
assert (type(schemas['schemas']) is list), ("'schemas' field in output of /Metadata/schemas is not a list: " + repr(schemas))
assert (len(schemas['schemas']) > 0), ("'schemas' field in output of /Metadata/schemas is empty: " + repr(schemas))
if verboser:
    print 'Schemas: '
    pp.pprint(schemas)
if verbose:
    print 'Testing /Metadata/schemas/FrameV2 again. . .'
schemas = a_node.schema(schemaname='FrameV2', timeoutSecs=240)
assert ('schemas' in schemas), ("FAIL: failed to find 'schemas' field in output of /Metadata/schemas/FrameV2: " + repr(schemas))
assert (type(schemas['schemas']) is list), ("'schemas' field in output of /Metadata/schemas/FrameV2 is not a list: " + repr(schemas))
assert (len(schemas['schemas']) == 1), ("'schemas' field in output of /Metadata/schemas/FrameV2 has an unexpected length: " + repr(schemas))
if verboser:
    print 'Schemas: '
    pp.pprint(schemas)
if clean_up_after:
    cleanup(models=[dl_airlines_model_name, 'deeplearning_prostate_binomial', 'kmeans_prostate'], frames=['prostate_binomial', 'airlines_binomial'])
