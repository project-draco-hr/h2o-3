def __init__(self, nv=None, max_iterations=None, transform=None, seed=None, use_all_factor_levels=None, svd_method=None):
    '\n    Singular value decomposition of an H2OFrame.\n\n    Parameters\n    ----------\n      nv : int\n        The number of right singular vectors to be computed. This must be between 1 and\n        min(ncol(training_frame), snrow(training_frame)) inclusive.\n      max_iterations : int\n        The maximum number of iterations to run each power iteration loop. Must be\n        between 1 and 1e6 inclusive.\n      transform : str\n        A character string that indicates how the training data should be transformed\n        before running SVD. Possible values are\n          "NONE": for no transformation,\n          "DEMEAN": for subtracting the mean of each column,\n          "DESCALE": for dividing by the standard deviation of each column,\n          "STANDARDIZE": for demeaning and descaling, and\n          "NORMALIZE": for demeaning and dividing each column by its range (max - min).\n      seed : int, optional\n        Random seed used to initialize the right singular vectors at the beginning of each\n        power method iteration.\n      use_all_factor_levels : bool, optional\n        A logical value indicating whether all factor levels should be included in each\n        categorical column expansion.\n        If FALSE, the indicator column corresponding to the first factor level of every\n        categorical variable will be dropped. Defaults to TRUE.\n      svd_method : str\n        A character string that indicates how SVD should be calculated.\n        Possible values are\n          "GramSVD": distributed computation of the Gram matrix followed by a local SVD\n                     using the JAMA package,\n        "Power": computation of the SVD using the power iteration method,\n        "Randomized": approximate SVD by projecting onto a random subspace.\n\n    Returns\n    -------\n      Return a new H2OSVD\n    '
    super(H2OSVD, self).__init__()
    self._parms = locals()
    self._parms = {k: v for (k, v) in self._parms.items() if (k != 'self')}
    self._parms['svd_method'] = ('GramSVD' if isinstance(svd_method, tuple) else svd_method)
    self._parms['transform'] = ('NONE' if isinstance(transform, tuple) else transform)
    self._parms['algo'] = 'svd'
    self._parms['_rest_version'] = 99
