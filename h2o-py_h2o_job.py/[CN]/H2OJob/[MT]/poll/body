def poll(self):
    u'\n        Wait until the job finishes.\n\n        This method will continuously query the server about the status of the job, until the job reaches a\n        completion. During this time we will display (in stdout) a progress bar with % completion status.\n\n        Poll timing is the following: first we wait 0.2s, then query the server,\n        '
    if self.__PROGRESS_BAR__:
        print()
    self._polling = True
    poll_interval = 0.2
    start_time = time.time()
    last_poll_time = start_time
    last_display_time = start_time
    last_display_amnt = 0
    width = self._progress_bar_width
    self._update_progress_bar()
    while self._is_running():
        next_poll_time = (last_poll_time + poll_interval)
        current_time = time.time()
        if (self.progress == 0):
            estimated_finish_time = (start_time + 120)
        else:
            estimated_finish_time = (start_time + ((last_poll_time - start_time) / self.progress))
        symbols_remaining = (width - last_display_amnt)
        if (estimated_finish_time > last_display_time):
            display_speed = (symbols_remaining / (estimated_finish_time - last_display_time))
            next_display_time = (last_display_time + (1 / max(min(display_speed, 100), 1)))
        else:
            display_speed = 0
            next_display_time = (next_poll_time + 1)
        if (next_poll_time <= min(current_time, next_display_time)):
            if (next_poll_time > current_time):
                time.sleep((next_poll_time - current_time))
                poll_interval = min(1, (poll_interval + 0.2))
                current_time = time.time()
            last_poll_time = current_time
            self._refresh_job_status()
        else:
            if (next_display_time > current_time):
                time.sleep((next_display_time - current_time))
                current_time = time.time()
            if (self.progress == 1):
                display_incr = symbols_remaining
            else:
                display_incr = min((symbols_remaining - 1), int((((current_time - last_display_time) * display_speed) + 0.1)))
            if (display_incr > 0):
                last_display_amnt += display_incr
                last_display_time = current_time
                self._update_progress_bar(last_display_amnt)
    self._polling = False
    self._update_progress_bar()
    if self.__PROGRESS_BAR__:
        print()
    if self.warnings:
        for w in self.warnings:
            warnings.warn(w)
    if (self.status == u'CANCELLED'):
        raise EnvironmentError(u'Job with key {} was cancelled by the user.'.format(self.job_key))
    if (self.status == u'FAILED'):
        if (isinstance(self.job, dict) and (u'stacktrace' in list(self.job))):
            raise EnvironmentError(u'Job with key {} failed with an exception: {}\nstacktrace: \n{}'.format(self.job_key, self.exception, self.job[u'stacktrace']))
        else:
            raise EnvironmentError((u'Job with key %s failed with an exception: %s' % (self.job_key, self.exception)))
    return self
