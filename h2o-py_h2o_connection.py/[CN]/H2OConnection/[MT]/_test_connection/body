def _test_connection(self, max_retries=5):
    u'\n        Test that the H2O cluster can be reached, and retrieve basic cloud status info.\n\n        :param max_retries: Number of times to try to connect to the cloud (with 0.2s intervals)\n        :return Cloud information (a CloudV3 object)\n        :raise H2OConnectionError, H2OServerError\n        '
    self._print((u'Connecting to H2O server at ' + self._base_url), end=u'..')
    cld = None
    errors = []
    for _ in range(max_retries):
        self._print(u'.', end=u'', flush=True)
        if (self._local_server and (not self._local_server.is_running())):
            raise H2OServerError(u'Local server was unable to start')
        try:
            cld = self.request(u'GET /3/Cloud')
            if (cld.consensus and cld.cloud_healthy):
                self._print(u' successful!')
                return cld
            else:
                if (cld.consensus and (not cld.cloud_healthy)):
                    msg = u'in consensus but not healthy'
                elif ((not cld.consensus) and cld.cloud_healthy):
                    msg = u'not in consensus but healthy'
                else:
                    msg = u'not in consensus and not healthy'
                errors.append((u'Cloud is in a bad shape: %s (size = %d, bad nodes = %d)' % (msg, cld.cloud_size, cld.bad_nodes)))
        except (H2OConnectionError, H2OServerError) as e:
            errors.append((u'[%s.%02d] %s: %s' % (time.strftime(u'%M:%S'), (int((time.time() * 100)) % 100), e.__class__.__name__, e.message)))
        time.sleep(0.2)
    self._print(u' failed.')
    if (cld and (not cld.cloud_healthy)):
        raise H2OServerError(u'Cluster reports unhealthy status')
    if (cld and (not cld.consensus)):
        raise H2OServerError(u'Cluster cannot reach consensus')
    else:
        raise H2OConnectionError((u'Could not establish link to the H2O cloud %s after %d retries\n%s' % (self._base_url, max_retries, u'\n'.join(errors))))
