@staticmethod
@translate_args
def connect(ip=u'localhost', port=54321, https=False, verify_ssl_cert=True, auth=None, proxy=None, cluster_name=None, verbose=True):
    u'\n        Connect to an existing H\u2082O server at address ip:port, either via http or https.\n\n        The connection is not kept alive, so what this method actually does is it attempts to connect to the\n        specified server, checks that the server is healthy and responds to REST API requests, and finally opens a new\n        session on the server. The parameters of the connection are stored so that all subsequent requests do not\n        need to specify them.\n        If the H\u2082O server cannot be reached, an H2OConnectionError will be raised.\n\n        Note: connecting to the server will effectively lock the cloud.\n\n        :param ip: Server\'s IP address, default is "localhost".\n        :param port: Server\'s port, default is 54321.\n        :param https: Set this to True to use https instead of http.\n        :param verify_ssl_cert: Set to False to disable SSL certificate checking; has no effect if https=False.\n        :param auth: Authenticator object (from requests.auth), or a (username, password) tuple.\n        :param proxy: (str) URL address of a proxy server.\n        :param cluster_name: Name of the H\u2082O cluster to connect to. This option is used from Steam only.\n        :param verbose: If True, then connection progress info will be printed to the stdout.\n        :return self\n        :raise H2OConnectionError if the server cannot be reached\n        :raise H2OServerError if the server is in an unhealthy state (although this is a recoverable error, the client\n                itself should decide whether it wants to retry or not)\n        '
    assert isinstance(ip, str), (u'`ip` must be a string, got %r' % ip)
    assert isinstance(port, (str, int)), (u'`port` must be an integer, got %r' % port)
    port = int(port)
    assert (1 <= port <= 65535), (u'Invalid `port` number: %d' % port)
    assert ((https is None) or isinstance(https, bool)), (u'`https` should be boolean, got %r' % https)
    assert ((proxy is None) or isinstance(proxy, str)), (u'`proxy` must be a string, got %r' % proxy)
    assert ((auth is None) or (isinstance(auth, tuple) and (len(auth) == 2)) or isinstance(auth, AuthBase)), (u'Invalid authentication token: %r' % auth)
    assert ((cluster_name is None) or isinstance(cluster_name, str)), (u'`cluster_name` must be a string, got %r' % cluster_name)
    conn = H2OConnection()
    conn._verbose = bool(verbose)
    conn._ip = ip
    conn._port = port
    conn._https = https
    conn._scheme = (u'https' if https else u'http')
    conn._base_url = (u'%s://%s:%d' % (conn._scheme, conn._ip, conn._port))
    conn._verify_ssl_cert = bool(verify_ssl_cert)
    conn._auth = auth
    conn._cluster_name = cluster_name
    conn._proxies = None
    if proxy:
        conn._proxies = {conn._scheme: proxy, }
    elif (proxy is not None):
        for name in os.environ:
            if (name.lower() == (conn._scheme + u'_proxy')):
                warnings.warn((u'Proxy is defined in the environment: %s. This may interfere with your H2O Connection.' % os.environ[name]))
    try:
        conn._stage = 1
        conn._cluster_info = conn._test_connection()
        atexit.register((lambda : conn.close()))
    except Exception:
        conn._stage = 0
        raise
    return conn
