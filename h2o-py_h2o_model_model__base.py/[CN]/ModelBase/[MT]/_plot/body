def _plot(self, timestep, metric, **kwargs):
    try:
        imp.find_module('matplotlib')
        import matplotlib
        if (('server' in list(kwargs.keys())) and kwargs['server']):
            matplotlib.use('Agg', warn=False)
        import matplotlib.pyplot as plt
    except ImportError:
        print('matplotlib is required for this function!')
        return
    scoring_history = self.score_history()
    if (self._model_json['algo'] == 'glm'):
        timestep = 'iteration'
        if (metric == 'AUTO'):
            metric = 'log_likelihood'
        elif (metric not in ('log_likelihood', 'objective')):
            raise ValueError('for GLM, metric must be one of: log_likelihood, objective')
        plt.xlabel(timestep)
        plt.ylabel(metric)
        plt.title('Validation Scoring History')
        plt.plot(scoring_history[timestep], scoring_history[metric])
    elif (self._model_json['algo'] in ('deeplearning', 'drf', 'gbm')):
        if (self._model_json['algo'] in ('gbm', 'drf')):
            if (timestep == 'AUTO'):
                timestep = 'number_of_trees'
            elif (timestep not in ('duration', 'number_of_trees')):
                raise ValueError('timestep for gbm or drf must be one of: duration, number_of_trees')
        else:
            if (scoring_history['samples'][0] == 0):
                scoring_history = scoring_history[1:]
            if (timestep == 'AUTO'):
                timestep = 'epochs'
            elif (timestep not in ('epochs', 'samples', 'duration')):
                raise ValueError('timestep for deeplearning must be one of: epochs, samples, duration')
        training_metric = 'training_{}'.format(metric)
        validation_metric = 'validation_{}'.format(metric)
        if (timestep == 'duration'):
            dur_colname = 'duration_{}'.format(scoring_history['duration'][1].split()[1])
            scoring_history[dur_colname] = [str(x).split()[0] for x in scoring_history['duration']]
            timestep = dur_colname
        if h2o.can_use_pandas():
            valid = (validation_metric in list(scoring_history))
            ylim = ((scoring_history[[training_metric, validation_metric]].min().min(), scoring_history[[training_metric, validation_metric]].max().max()) if valid else (scoring_history[training_metric].min(), scoring_history[training_metric].max()))
        else:
            valid = (validation_metric in scoring_history.col_header)
            ylim = ((min(min(scoring_history[[training_metric, validation_metric]])), max(max(scoring_history[[training_metric, validation_metric]]))) if valid else (min(scoring_history[training_metric]), max(scoring_history[training_metric])))
        if valid:
            plt.xlabel(timestep)
            plt.ylabel(metric)
            plt.title('Scoring History')
            plt.ylim(ylim)
            plt.plot(scoring_history[timestep], scoring_history[training_metric], label='Training')
            plt.plot(scoring_history[timestep], scoring_history[validation_metric], color='orange', label='Validation')
            plt.legend()
        else:
            plt.xlabel(timestep)
            plt.ylabel(training_metric)
            plt.title('Training Scoring History')
            plt.ylim(ylim)
            plt.plot(scoring_history[timestep], scoring_history[training_metric])
    else:
        raise ValueError('Plotting not implemented for this type of model')
    if (('server' not in list(kwargs.keys())) or (not kwargs['server'])):
        plt.show()
