{
  if (isCancelled() || _job != null && _job.stop_requested())   return;
  Connection conn=null;
  Statement stmt=null;
  ResultSet rs=null;
  Chunk c0=cs[0];
  String sqlText="SELECT * FROM " + _table + " LIMIT "+ c0._len+ " OFFSET "+ c0.start();
  try {
    conn=sqlConn.take();
    stmt=conn.createStatement();
    rs=stmt.executeQuery(sqlText);
    while (rs.next()) {
      for (int i=0; i < _sqlColumnTypes.length; i++) {
        Object res=rs.getObject(i + 1);
        if (res == null)         ncs[i].addNA();
 else switch (_sqlColumnTypes[i]) {
case Types.NUMERIC:
case Types.REAL:
case Types.DOUBLE:
case Types.FLOAT:
case Types.DECIMAL:
          ncs[i].addNum((double)res);
        break;
case Types.INTEGER:
case Types.TINYINT:
case Types.SMALLINT:
case Types.BIGINT:
      ncs[i].addNum((long)(int)res,0);
    break;
case Types.BIT:
case Types.BOOLEAN:
  ncs[i].addNum(((boolean)res ? 1 : 0),0);
break;
case Types.VARCHAR:
case Types.NVARCHAR:
case Types.CHAR:
case Types.NCHAR:
case Types.LONGVARCHAR:
case Types.LONGNVARCHAR:
ncs[i].addStr(new BufferedString((String)res));
break;
case Types.DATE:
case Types.TIME:
case Types.TIMESTAMP:
ncs[i].addNum(((Date)res).getTime(),0);
break;
default :
ncs[i].addNA();
}
}
}
}
 catch (SQLException ex) {
throw new RuntimeException("SQLException: " + ex.getMessage() + "\nFailed to read SQL data");
}
catch (InterruptedException e) {
e.printStackTrace();
throw new RuntimeException("Interrupted exception when trying to take connection from pool");
}
 finally {
if (rs != null) {
try {
rs.close();
}
 catch (SQLException sqlEx) {
}
rs=null;
}
if (stmt != null) {
try {
stmt.close();
}
 catch (SQLException sqlEx) {
}
stmt=null;
}
sqlConn.add(conn);
}
if (_job != null) _job.update(1);
}
