{
  ByteVec vec=getByteVec(key);
  byte[] zips=vec.getFirstBytes();
  ZipUtil.Compression cpr=ZipUtil.guessCompressionMethod(zips);
  byte[] bits=ZipUtil.unzipBytes(zips,cpr);
  ParserSetup localSetup=_setup.guessSetup(bits);
  if (localSetup.hasErrors())   return;
  final int chunkStartIdx=_fileChunkOffsets[ArrayUtils.find(_keys,key)];
  try {
switch (cpr) {
case NONE:
      if (localSetup._pType._parallelParseSupported) {
        throw H2O.unimpl();
      }
 else {
        throw H2O.unimpl();
      }
case ZIP:
{
      FileMonitor pmon=new FileMonitor((ParseMonitor)DKV.get(_progress).get());
      ZipInputStream zis=new ZipInputStream(vec.openStream(pmon));
      ZipEntry ze=zis.getNextEntry();
      if (ze != null && !ze.isDirectory())       _dout=streamParse(zis,localSetup,_vecIdStart,chunkStartIdx,pmon);
 else       zis.close();
      chunksAreLocal(vec,chunkStartIdx);
      break;
    }
case GZIP:
  FileMonitor pmon=new FileMonitor((ParseMonitor)DKV.get(_progress).get());
_dout=streamParse(new GZIPInputStream(vec.openStream(pmon)),localSetup,_vecIdStart,chunkStartIdx,pmon);
chunksAreLocal(vec,chunkStartIdx);
break;
}
}
 catch (IOException ioe) {
throw new RuntimeException(ioe);
}
}
