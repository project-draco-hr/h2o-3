def train(self, x=None, y=u'response', training_frame=None, offset_column=None, fold_column=None, weights_column=None, validation_frame=None, max_runtime_secs=None, **params):
    u'\n        Train the H2O model.\n\n        Parameters\n        ----------\n        x : list, None\n            A list of column names or indices indicating the predictor columns.\n\n        y : str, int\n            An index or a column name indicating the response column.\n\n        training_frame : H2OFrame\n            The H2OFrame having the columns indicated by x and y (as well as any\n            additional columns specified by fold, offset, and weights).\n\n        offset_column : str, optional\n            The name or index of the column in training_frame that holds the offsets.\n\n        fold_column : str, optional\n            The name or index of the column in training_frame that holds the per-row fold\n            assignments.\n\n        weights_column : str, optional\n            The name or index of the column in training_frame that holds the per-row weights.\n\n        validation_frame : H2OFrame, optional\n            H2OFrame with validation data to be scored on while training.\n\n        max_runtime_secs : float\n            Maximum allowed runtime in seconds for model training. Use 0 to disable.\n        '
    assert_is_type(training_frame, H2OFrame)
    assert_is_type(y, None, int, str)
    assert_is_type(x, None, int, str, [str, int], {str, int})
    if (x is None):
        x = set(training_frame.ncol)
        if is_type(y, int):
            x -= {training_frame.names[y]}
        if is_type(y, str):
            x -= {y}
    algo_params = locals()
    parms = self._parms.copy()
    if (u'__class__' in parms):
        del parms[u'__class__']
    parms.update({k: v for (k, v) in algo_params.items() if (k not in [u'self', u'params', u'algo_params', u'parms'])})
    tframe = algo_params[u'training_frame']
    if (tframe is None):
        raise ValueError(u'Missing training_frame')
    if (y is not None):
        if isinstance(y, (list, tuple)):
            if (len(y) == 1):
                parms[u'y'] = y[0]
            else:
                raise ValueError(u'y must be a single column reference')
        self._estimator_type = (u'classifier' if tframe[y].isfactor() else u'regressor')
    self.build_model(parms)
