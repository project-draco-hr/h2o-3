{
  Frame fr=stk.track(asts[1].exec(env)).getFrame();
  final int col=(int)asts[2].exec(env).getNum();
  if (col < 0 || col >= fr.numCols())   throw new IllegalArgumentException("Column not in range 0 to " + fr.numCols());
  final Vec vec=fr.vec(col);
  AST method;
switch (asts[3].exec(env).getStr().toUpperCase()) {
case "MEAN":
    method=new ASTMean();
  break;
case "MEDIAN":
method=new ASTMedian();
break;
case "MODE":
method=new ASTMode();
break;
default :
throw new IllegalArgumentException("Method must be one of mean, median or mode");
}
QuantileModel.CombineMethod combine=QuantileModel.CombineMethod.valueOf(asts[4].exec(env).getStr().toUpperCase());
AST ast=asts[5];
ASTNumList by2;
if (ast instanceof ASTNumList) by2=(ASTNumList)ast;
 else if (ast instanceof ASTNum) by2=new ASTNumList(((ASTNum)ast)._v.getNum());
 else if (ast instanceof ASTStrList) {
String[] names=((ASTStrList)ast)._strs;
double[] list=new double[names.length];
int i=0;
for (String name : ((ASTStrList)ast)._strs) list[i++]=fr.find(name);
Arrays.sort(list);
by2=new ASTNumList(list);
}
 else throw new IllegalArgumentException("Requires a number-list, but found a " + ast.getClass());
final ASTNumList by=by2;
final boolean inplace=asts[6].exec(env).getNum() == 1;
if (inplace && fr._key == null) throw new IllegalArgumentException("Can only update in-place named Frames");
IcedHashMap<ASTGroup.GKX,IcedDouble> group_impute_map;
if (by.isEmpty()) {
double res=Double.NaN;
if (method instanceof ASTMean) res=vec.mean();
if (method instanceof ASTMedian) res=ASTMedian.median(stk.track(new Frame(vec)),combine);
if (method instanceof ASTMode) res=ASTMode.mode(vec);
(group_impute_map=new IcedHashMap<>()).put(new ASTGroup.GKX(),new IcedDouble(res));
}
 else {
AST ast_grp=new ASTGroup();
Frame imputes=ast_grp.apply(env,stk,new AST[]{ast_grp,new ASTFrame(fr),by,method,new ASTNumList(col,col + 1),new ASTStr("rm")}).getFrame();
group_impute_map=new Gather().doAll(imputes)._group_impute_map;
imputes.delete();
}
if (!inplace) {
fr=new Frame(fr);
stk.track(fr).replace(col,vec.makeCopy());
}
final IcedHashMap<ASTGroup.GKX,IcedDouble> final_group_impute_map=group_impute_map;
final Frame fr_keys=ASTGroup.gbFrame(fr,by2.expand4());
final int ngbcols=fr_keys.numCols();
new MRTask(){
@Override public void map(Chunk cs[]){
Chunk x=cs[ngbcols + col];
ASTGroup.GKX g=ASTGroup.GKX.init(ngbcols);
for (int row=0; row < x._len; row++) if (x.isNA(row)) x.set(row,final_group_impute_map.get(g.fill(cs,row,0))._val);
}
}
.doAll(fr_keys.add(fr));
return new ValFrame(fr);
}
