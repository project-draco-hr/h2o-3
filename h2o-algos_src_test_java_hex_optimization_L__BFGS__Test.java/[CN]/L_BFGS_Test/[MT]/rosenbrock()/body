{
  final double a=1, b=100;
  GradientSolver gs=new GradientSolver(){
    @Override public GradientInfo[] getGradient(    double[][] betas){
      double[][] grads=new double[betas.length][betas[0].length];
      double[] objs=new double[grads.length];
      for (int i=0; i < grads.length; ++i) {
        final double[] g=grads[i]=grads[i].clone();
        final double x=betas[i][0];
        final double y=betas[i][1];
        final double xx=x * x;
        g[0]=-2 * a + 2 * x - 4 * b * (y * x - x * xx);
        g[1]=2 * b * (y - xx);
        objs[i]=(a - x) * (a - x) + b * (y - xx) * (y - xx);
      }
      GradientInfo[] ginfos=new GradientInfo[betas.length];
      for (int i=0; i < betas.length; ++i)       ginfos[i]=new GradientInfo(objs[i],grads[i]);
      return ginfos;
    }
  }
;
  int fails=0;
  int N=1000;
  for (int i=0; i < N; ++i) {
    L_BFGS_Params parms=new L_BFGS_Params();
    parms._stepDec=.9;
    parms._nBetas=3;
    parms._minStep=1e-18;
    L_BFGS.Result r=L_BFGS.solve(2,gs,parms);
    if (Math.abs(r.ginfo._objVal) > 1e-4)     ++fails;
  }
  assertTrue("too many fails " + fails,fails < 5);
}
