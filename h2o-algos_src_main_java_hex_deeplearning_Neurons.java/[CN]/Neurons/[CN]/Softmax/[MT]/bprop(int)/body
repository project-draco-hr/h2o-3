{
  assert(target != missing_int_value);
  float m=momentum();
  float r=_minfo.adaDelta() ? 0 : rate(_minfo.get_processed_total()) * (1f - m);
  float g;
  final float rows=_a.size();
  for (int row=0; row < rows; row++) {
    final float t=(row == target ? 1f : 0f);
    final float y=_a.get(row);
    if (params._loss == DeepLearningParameters.Loss.CrossEntropy) {
      g=t - y;
    }
 else     if (params._loss == DeepLearningParameters.Loss.Absolute) {
      g=(2 * t - 1) * (1f - y) * y;
    }
 else     if (params._loss == DeepLearningParameters.Loss.MeanSquare) {
      g=(t - y) * (1f - y) * y;
    }
 else     if (params._loss == DeepLearningParameters.Loss.Huber) {
      if (t == 0) {
        if (y < 0.5) {
          g=-4 * y;
        }
 else {
          g=-2;
        }
      }
 else {
        if (y > 0.5) {
          g=4 * (1 - y);
        }
 else {
          g=2;
        }
      }
      g*=(1f - y) * y;
    }
 else     throw H2O.unimpl("Loss " + params._loss + " not implemented for classification.");
    bprop(row,g,r,m);
  }
}
