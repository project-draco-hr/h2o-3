{
  final float rho=(float)params._rho;
  final float eps=(float)params._epsilon;
  final float l1=(float)params._l1;
  final float l2=(float)params._l2;
  final float max_w2=params._max_w2;
  final boolean have_momenta=_minfo.has_momenta();
  final boolean have_ada=_minfo.adaDelta();
  final boolean nesterov=params._nesterov_accelerated_gradient;
  final boolean update_prev=prev_e != null;
  final int cols=prev_a.size();
  final int idx=row * cols;
  double avg_grad2=0;
  int start=prev_a.begin()._idx;
  int end=prev_a.end()._idx;
  for (int it=start; it < end; ++it) {
    final int col=prev_a._indices[it];
    final float weight=_w.get(row,col);
    if (update_prev)     prev_e.add(col,partial_grad * weight);
    final double previous_a=prev_a._values[it];
    assert(previous_a != 0);
    double grad=partial_grad * previous_a - Math.signum(weight) * l1 - weight * l2;
    if (_wEA != null)     throw H2O.unimpl("elastic averaging is not implemented for sparse input handling.");
    final int w=idx + col;
    if (have_ada) {
      assert(!have_momenta);
      final double grad2=grad * grad;
      avg_grad2+=grad2;
      float brate=computeAdaDeltaRateForWeight(grad,w,adaxg,rho,eps);
      _w.raw()[w]+=brate * grad;
    }
 else {
      if (!nesterov) {
        final double delta=rate * grad;
        _w.raw()[w]+=delta;
        if (have_momenta) {
          _w.raw()[w]+=momentum * _wm.raw()[w];
          _wm.raw()[w]=(float)delta;
        }
      }
 else {
        double tmp=grad;
        if (have_momenta) {
          _wm.raw()[w]*=momentum;
          _wm.raw()[w]+=tmp;
          tmp=_wm.raw()[w];
        }
        _w.raw()[w]+=rate * tmp;
      }
    }
  }
  if (max_w2 != Float.POSITIVE_INFINITY)   rescale_weights(_w,row,max_w2);
  if (have_ada)   avg_grad2/=prev_a.nnz();
  assert(_bEA == null);
  update_bias(_b,_bEA,_bm,row,partial_grad,avg_grad2,rate,momentum);
}
