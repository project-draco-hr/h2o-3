{
  String err="Result of function produced more than a single column!";
  final ASTOp FUN=ASTOp.get(_fun);
  Frame fr2=null;
  Frame fr=env.popAry();
  if (_margin == 2) {
    double[] row_result;
    Vec[] vecs_result;
    boolean isRow=false;
    Futures fs=new Futures();
    Key key;
    AppendableVec v=null;
    NewChunk chunk=null;
    Vec[] vecs=new Vec[fr.numCols()];
    for (int i=0; i < fr.numCols(); ++i) {
      ASTFrame f;
      AST[] funargs=new AST[_fun_args == null ? 1 : _fun_args.length + 1];
      funargs[0]=f=new ASTFrame(fr.vec(i)._key.toString());
      if (_fun_args != null)       System.arraycopy(_fun_args,0,funargs,1,_fun_args.length);
      FUN.exec(env,funargs);
      if (i == 0) {
        isRow=env.isNum();
        if (isRow) {
          key=Vec.VectorGroup.VG_LEN1.addVecs(1)[0];
          v=new AppendableVec(key);
          chunk=new NewChunk(v,0);
        }
 else {
          vecs[0]=env.popAry().anyVec();
        }
      }
      if (isRow)       chunk.addNum(env.popDbl());
 else       vecs[i]=env.popAry().anyVec();
    }
    if (isRow) {
      chunk.close(0,fs);
      Vec vec=v.close(fs);
      fs.blockForPending();
      fr2=new Frame(vec);
    }
 else {
      fr2=new Frame(fr.names(),vecs);
    }
  }
  if (_margin == 1) {
    double[] rowin=new double[fr.vecs().length];
    for (int c=0; c < rowin.length; c++)     rowin[c]=fr.vecs()[c].at(0);
    final int outlen=FUN.map(env,rowin,null,_fun_args).length;
    final Env env0=env.capture();
    MRTask mrt=new MRTask(){
      @Override public void map(      Chunk[] cs,      NewChunk[] ncs){
        double rowin[]=new double[cs.length];
        double rowout[]=new double[outlen];
        for (int row=0; row < cs[0]._len; row++) {
          for (int c=0; c < cs.length; c++)           rowin[c]=cs[c].atd(row);
          rowout=FUN.map(env0,rowin,rowout,_fun_args);
          for (int c=0; c < ncs.length; c++)           ncs[c].addNum(rowout[c]);
        }
      }
    }
;
    String[] names=new String[outlen];
    for (int i=0; i < names.length; i++)     names[i]="C" + (i + 1);
    fr2=mrt.doAll(outlen,fr).outputFrame(names,null);
  }
 else   if (_margin != 1 && _margin != 2)   throw new IllegalArgumentException("MARGIN limited to 1 (rows) or 2 (cols)");
  env.pushAry(fr2);
}
