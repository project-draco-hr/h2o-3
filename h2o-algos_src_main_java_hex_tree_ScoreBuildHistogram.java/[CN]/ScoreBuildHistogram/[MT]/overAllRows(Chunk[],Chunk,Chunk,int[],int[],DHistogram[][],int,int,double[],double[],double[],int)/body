{
  Chunk chk=chks[c];
  final DHistogram rh=hcs[n][c];
  if (rh == null)   return;
  double[] rhbins=rh._bins;
  int rhbinslen=rhbins.length;
  final int lo=n == 0 ? 0 : nh[n - 1];
  final int hi=nh[n];
  double min=rh._min2;
  double max=rh._maxIn;
  if (rhbinslen >= binslen) {
    bins=new double[rhbinslen];
    sums=new double[rhbinslen];
    ssqs=new double[rhbinslen];
  }
  for (int xrow=lo; xrow < hi; xrow++) {
    int row=rows[xrow];
    double w=weight.atd(row);
    if (w == 0)     continue;
    double col_data=chk.atd(row);
    if (col_data < min)     min=col_data;
    if (col_data > max)     max=col_data;
    int b=rh.bin(col_data);
    double resp=wrks.atd(row);
    double wy=w * resp;
    bins[b]+=w;
    sums[b]+=wy;
    ssqs[b]+=wy * resp;
  }
  rh.setMin(min);
  rh.setMax(max);
  int len=rhbinslen;
  for (int b=0; b < len; b++) {
    if (bins[b] != 0) {
      AtomicUtils.DoubleArray.add(rhbins,b,bins[b]);
      bins[b]=0;
    }
    if (sums[b] != 0) {
      rh.incr1(b,sums[b],ssqs[b]);
      sums[b]=ssqs[b]=0;
    }
  }
}
