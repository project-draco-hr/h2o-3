{
  final DHistogram hcs[][]=_hcs;
  if (hcs.length == 0)   return;
  double bins[]=new double[Math.max(_nbins,_nbins_cats)];
  double sums[]=new double[Math.max(_nbins,_nbins_cats)];
  double ssqs[]=new double[Math.max(_nbins,_nbins_cats)];
  for (int c=0; c < _ncols; c++) {
    Chunk chk=chks[c];
    for (int n=0; n < hcs.length; n++) {
      final DHistogram rh=((DHistogram)hcs[n][c]);
      if (rh == null)       continue;
      final int lo=n == 0 ? 0 : nh[n - 1];
      final int hi=nh[n];
      float min=rh._min2;
      float max=rh._maxIn;
      if (rh._bins.length >= bins.length) {
        bins=new double[rh._bins.length];
        sums=new double[rh._bins.length];
        ssqs=new double[rh._bins.length];
      }
      for (int xrow=lo; xrow < hi; xrow++) {
        int row=rows[xrow];
        double w=weight.atd(row);
        if (w == 0)         continue;
        float col_data=(float)chk.atd(row);
        if (col_data < min)         min=col_data;
        if (col_data > max)         max=col_data;
        int b=rh.bin(col_data);
        double resp=wrks.atd(row);
        double wy=w * resp;
        bins[b]+=w;
        sums[b]+=wy;
        ssqs[b]+=wy * resp;
      }
      rh.setMin(min);
      rh.setMax(max);
      for (int b=0; b < rh._bins.length; b++) {
        if (bins[b] != 0) {
          AtomicUtils.DoubleArray.add(rh._bins,b,bins[b]);
          bins[b]=0;
        }
        if (sums[b] != 0) {
          rh.incr1(b,sums[b],ssqs[b]);
          sums[b]=ssqs[b]=0;
        }
      }
    }
  }
}
