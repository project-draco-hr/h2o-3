{
  final DHistogram hcs[][]=_hcs;
  if (hcs.length == 0)   return;
  double bins[]=new double[Math.max(_nbins,_nbins_cats)];
  double sums[]=new double[Math.max(_nbins,_nbins_cats)];
  double ssqs[]=new double[Math.max(_nbins,_nbins_cats)];
  int binslen=bins.length;
  int cols=_ncols;
  int hcslen=hcs.length;
  for (int c=0; c < cols; c++) {
    Chunk chk=chks[c];
    for (int n=0; n < hcslen; n++) {
      final DHistogram rh=hcs[n][c];
      if (rh == null)       continue;
      double[] rhbins=rh._bins;
      int rhbinslen=rhbins.length;
      final int lo=n == 0 ? 0 : nh[n - 1];
      final int hi=nh[n];
      float min=rh._min2;
      float max=rh._maxIn;
      if (rhbinslen >= binslen) {
        bins=new double[rhbinslen];
        sums=new double[rhbinslen];
        ssqs=new double[rhbinslen];
      }
      for (int xrow=lo; xrow < hi; xrow++) {
        int row=rows[xrow];
        double w=weight.atd(row);
        if (w == 0)         continue;
        float col_data=(float)chk.atd(row);
        if (col_data < min)         min=col_data;
        if (col_data > max)         max=col_data;
        int b=rh.bin(col_data);
        double resp=wrks.atd(row);
        double wy=w * resp;
        bins[b]+=w;
        sums[b]+=wy;
        ssqs[b]+=wy * resp;
      }
      rh.setMin(min);
      rh.setMax(max);
      int len=rhbinslen;
      for (int b=0; b < len; b++) {
        if (bins[b] != 0) {
          AtomicUtils.DoubleArray.add(rhbins,b,bins[b]);
          bins[b]=0;
        }
        if (sums[b] != 0) {
          rh.incr1(b,sums[b],ssqs[b]);
          sums[b]=ssqs[b]=0;
        }
      }
    }
  }
}
