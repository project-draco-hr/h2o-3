{
  Chunk chk=chks[c];
  final DHistogram rh=hcs[n][c];
  if (rh == null)   return;
  double[] rhbins=rh._bins;
  int rhbinslen=rhbins.length;
  final int lo=n == 0 ? 0 : nh[n - 1];
  final int hi=nh[n];
  double min=rh._min2;
  double max=rh._maxIn;
  if (rhbinslen >= binslen) {
    bins=new double[rhbinslen];
    sums=new double[rhbinslen];
    ssqs=new double[rhbinslen];
  }
  int[] which=new int[hi - lo];
  System.arraycopy(rows,lo,which,0,hi - lo);
  if (hi - lo > ws.length) {
    ws=new double[hi - lo];
    cs=new double[hi - lo];
    ys=new double[hi - lo];
  }
  weight.getDoubles(ws,which);
  chk.getDoubles(cs,which);
  wrks.getDoubles(ys,which);
  for (int k=0; k < hi - lo; ++k) {
    double w=ws[k];
    if (w == 0)     continue;
    double col_data=cs[k];
    if (col_data < min)     min=col_data;
    if (col_data > max)     max=col_data;
    int b=rh.bin(col_data);
    double resp=ys[k];
    double wy=w * resp;
    bins[b]+=w;
    sums[b]+=wy;
    ssqs[b]+=wy * resp;
  }
  rh.setMin(min);
  rh.setMax(max);
  int len=rhbinslen;
  for (int b=0; b < len; b++) {
    if (bins[b] != 0) {
      AtomicUtils.DoubleArray.add(rhbins,b,bins[b]);
      bins[b]=0;
    }
    if (sums[b] != 0) {
      rh.incr1(b,sums[b],ssqs[b]);
      sums[b]=ssqs[b]=0;
    }
  }
}
