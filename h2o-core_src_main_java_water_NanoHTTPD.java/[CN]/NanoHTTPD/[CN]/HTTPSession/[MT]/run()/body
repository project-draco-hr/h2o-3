{
  try (Socket mySocket=this.mySocket){
    InputStream is=new BufferedInputStream(mySocket.getInputStream());
    is.mark(MAX_HEADER_BUFFER_SIZE);
    int bufsize=8192;
    byte[] buf=new byte[bufsize];
    boolean nl=false;
    int rlen=0;
    while (rlen < MAX_HEADER_BUFFER_SIZE) {
      int b=is.read();
      if (b == -1)       return;
      buf[rlen++]=(byte)b;
      if (b == '\n') {
        if (nl)         break;
        nl=true;
      }
 else       if (b != '\r')       nl=false;
      if (rlen == buf.length)       buf=Arrays.copyOf(buf,2 * buf.length);
    }
    if (rlen == MAX_HEADER_BUFFER_SIZE)     sendError(HTTP_TOO_LONG_REQUEST,"Requested URL is too long!");
    ByteArrayInputStream hbis=new ByteArrayInputStream(buf,0,rlen);
    BufferedReader hin=new BufferedReader(new InputStreamReader(hbis));
    Properties pre=new Properties();
    Properties parms=new Properties();
    Properties header=new Properties();
    decodeHeader(hin,pre,parms,header);
    String method=pre.getProperty("method");
    String uri=pre.getProperty("uri");
    long size=0x7FFFFFFFFFFFFFFFl;
    String contentLength=header.getProperty("content-length");
    if (contentLength != null) {
      try {
        size=Integer.parseInt(contentLength);
      }
 catch (      NumberFormatException ex) {
      }
    }
    int splitbyte=0;
    boolean sbfound=false;
    while (splitbyte < rlen) {
      if (buf[splitbyte] == '\r' && buf[++splitbyte] == '\n' && buf[++splitbyte] == '\r' && buf[++splitbyte] == '\n') {
        sbfound=true;
        break;
      }
      splitbyte++;
    }
    splitbyte++;
    is.reset();
    is.skip(splitbyte);
    if (splitbyte < rlen)     size-=rlen - splitbyte + 1;
 else     if (!sbfound || size == 0x7FFFFFFFFFFFFFFFl)     size=0;
    BufferedReader in=new BufferedReader(new InputStreamReader(is));
    if (method.equalsIgnoreCase("POST")) {
      String contentType="";
      String contentTypeHeader=header.getProperty("content-type");
      if (contentTypeHeader == null)       contentTypeHeader="";
      StringTokenizer st=new StringTokenizer(contentTypeHeader,"; ");
      if (st.hasMoreTokens()) {
        contentType=st.nextToken();
      }
      if (contentType.equalsIgnoreCase("multipart/form-data")) {
        if (!st.hasMoreTokens())         sendError(HTTP_BAD_REQUEST,"BAD REQUEST: Content type is multipart/form-data but boundary missing. Usage: GET /example/file.html");
        String boundaryExp=st.nextToken();
        st=new StringTokenizer(boundaryExp,"=");
        if (st.countTokens() != 2)         sendError(HTTP_BAD_REQUEST,"BAD REQUEST: Content type is multipart/form-data but boundary syntax error. Usage: GET /example/file.html");
        st.nextToken();
        String boundary=st.nextToken();
        String paddedMethod=String.format("%-6s",method);
        Log.info("Method: " + paddedMethod,", URI: " + uri + ", route: "+ "(special case)"+ ", parms: "+ parms);
        boolean handled=fileUpload(boundary,is,parms,uri);
        if (handled) {
          return;
        }
      }
 else {
        String postLine="";
        if (size >= 0) {
          char pbuf[]=new char[4096];
          long bytesRead=0;
          long bytesToRead=size;
          StringBuilder sb=new StringBuilder();
          while (bytesRead < bytesToRead) {
            int n=in.read(pbuf);
            if (n < 0) {
              break;
            }
 else             if (n == 0) {
              assert(false);
              break;
            }
            bytesRead+=n;
            sb.append(pbuf,0,n);
          }
          postLine=sb.toString();
        }
 else {
          char pbuf[]=new char[512];
          int read=in.read(pbuf);
          while (read >= 0 && !postLine.endsWith("\r\n")) {
            postLine+=String.valueOf(pbuf,0,read);
            read=in.read(pbuf);
          }
          postLine=postLine.trim();
        }
        if (contentType.equalsIgnoreCase("application/json")) {
          parms.put("_post_body",postLine);
        }
 else {
          decodeParms(postLine,parms);
        }
      }
    }
    Response r=serve(uri,method,header,parms);
    if (r == null)     sendError(HTTP_INTERNAL_ERROR,"SERVER INTERNAL ERROR: Serve() returned a null response.");
 else     sendResponse(r.status,r.mimeType,r.header,r.data);
    in.close();
    is.close();
  }
 catch (  IOException ioe) {
    try {
      sendError(HTTP_INTERNAL_ERROR,"SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
    }
 catch (    Throwable t) {
      Log.err(t);
    }
  }
catch (  InterruptedException e) {
  }
}
