{
  long localParseSize=(long)(double)totalSize / cloudsize;
  long chunkSize=(localParseSize / (cores * 4));
  if (oldHeuristic) {
    if (chunkSize <= (1 << 16)) {
      return DFLT_CHUNK_SIZE;
    }
    chunkSize=1L << MathUtils.log2(chunkSize);
    if (chunkSize < DFLT_CHUNK_SIZE && (localParseSize / chunkSize) * numCols < (1 << 21)) {
      return (int)chunkSize;
    }
    long tmp=(localParseSize * numCols / (1 << 21));
    if (tmp > (1 << 30))     return (1 << 30);
    if (tmp > DFLT_CHUNK_SIZE) {
      chunkSize=1 << MathUtils.log2((int)tmp);
      return (int)chunkSize;
    }
 else     return DFLT_CHUNK_SIZE;
  }
 else {
    final int minNumberRows=10;
    final int perNodeChunkCountLimit=1 << 21;
    final int maxParseChunkSize=1 << 30;
    final long maxParseChunkSizePOJOLimit=(long)numCols * (long)Value.MAX / 2;
    Log.info("ParseSetup heuristic: cloudSize: " + cloudsize + ", cores: "+ cores+ ", numCols: "+ numCols+ ", maxLineLength: "+ maxLineLength+ ", totalSize: "+ totalSize+ ", chunkSize: "+ chunkSize+ ", localParseSize: "+ localParseSize+ ", maxParseChunkSizePOJOLimit: "+ maxParseChunkSizePOJOLimit);
    if (totalSize <= 1 << 16)     return Math.max(DFLT_CHUNK_SIZE,(int)(minNumberRows * maxLineLength));
    chunkSize=1L << MathUtils.log2(chunkSize);
    if (chunkSize < DFLT_CHUNK_SIZE && (localParseSize / chunkSize) * numCols < perNodeChunkCountLimit)     return Math.max((int)chunkSize,(int)(minNumberRows * maxLineLength));
    int chunkCount=cores * 4 * numCols;
    if (chunkCount > perNodeChunkCountLimit) {
      double ratio=1 << Math.max(2,MathUtils.log2((int)(double)chunkCount / perNodeChunkCountLimit));
      chunkSize*=ratio;
    }
    chunkSize=Math.min(maxParseChunkSize,chunkSize);
    if (chunkSize > minNumberRows * maxLineLength && chunkSize < maxParseChunkSizePOJOLimit && (int)chunkSize == chunkSize)     return (int)chunkSize;
    return (int)Math.min(maxParseChunkSizePOJOLimit,Math.max(DFLT_CHUNK_SIZE,Math.min(maxParseChunkSize,minNumberRows * maxLineLength)));
  }
}
