{
  super.init(expensive);
  if (_parms._loading_key == null)   _parms._loading_key=Key.make("GLRMLoading_" + Key.rand());
  if (_parms._gamma < 0)   error("_gamma","gambda must be a non-negative number");
  if (_parms._max_iterations < 1)   error("_max_iterations","max_iterations must be at least 1");
  if (_train == null)   return;
  if (_train.numCols() < 2)   error("_train","_train must have more than one column");
  int k_min=(int)Math.min(_train.numCols(),_train.numRows());
  if (_parms._k < 1 || _parms._k > k_min)   error("_k","_k must be between 1 and " + k_min);
  if (null != _parms._user_points) {
    if (_parms._user_points.get().numCols() != _train.numCols())     error("_user_points","The user-specified points must have the same number of columns (" + _train.numCols() + ") as the training observations");
 else     if (_parms._user_points.get().numRows() != _parms._k)     error("_user_points","The user-specified points must have k = " + _parms._k + " rows");
 else {
      int zero_vec=0;
      Vec[] centersVecs=_parms._user_points.get().vecs();
      for (int c=0; c < _ncolA; c++) {
        if (centersVecs[c].isConst() && centersVecs[c].max() == 0)         zero_vec++;
      }
      if (zero_vec == _ncolA)       error("_user_points","The user-specified points cannot all be zero");
    }
  }
  Vec[] vecs=_train.vecs();
  for (int i=0; i < vecs.length; i++) {
    if (!vecs[i].isNumeric())     throw H2O.unimpl();
  }
  _ncolA=_train.numCols();
  _ncolX=_parms._k;
}
