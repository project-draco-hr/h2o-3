{
  GLRMModel model=null;
  DataInfo dinfo=null, xinfo=null, tinfo=null;
  Frame fr=null, x=null;
  boolean overwriteX=false;
  try {
    init(true);
    _parms.read_lock_frames(GLRM.this);
    if (error_count() > 0)     throw new IllegalArgumentException("Found validation errors: " + validationErrors());
    model=new GLRMModel(dest(),_parms,new GLRMModel.GLRMOutput(GLRM.this));
    model.delete_and_lock(self());
    tinfo=new DataInfo(Key.make(),_train,_valid,0,true,_parms._transform,DataInfo.TransformType.NONE,false,false,false,false,false,false);
    DKV.put(tinfo._key,tinfo);
    model._output._normSub=tinfo._normSub == null ? new double[tinfo._nums] : tinfo._normSub;
    if (tinfo._normMul == null) {
      model._output._normMul=new double[tinfo._nums];
      Arrays.fill(model._output._normMul,1.0);
    }
 else     model._output._normMul=tinfo._normMul;
    model._output._permutation=tinfo._permutation;
    model._output._nnums=tinfo._nums;
    model._output._ncats=tinfo._cats;
    model._output._catOffsets=tinfo._catOffsets;
    model._output._names_expanded=tinfo.coefNames();
    long nobs=_train.numRows() * _train.numCols();
    long na_cnt=0;
    for (int i=0; i < _train.numCols(); i++)     na_cnt+=_train.vec(i).naCnt();
    model._output._nobs=nobs - na_cnt;
    fr=new Frame(_train);
    for (int i=0; i < _ncolX; i++)     fr.add("xcol_" + i,fr.anyVec().makeZero());
    for (int i=0; i < _ncolX; i++)     fr.add("wcol_" + i,fr.anyVec().makeZero());
    dinfo=new DataInfo(Key.make(),fr,null,0,true,_parms._transform,DataInfo.TransformType.NONE,false,false,false,false,false,false);
    DKV.put(dinfo._key,dinfo);
    int weightId=dinfo._weights ? dinfo.weightChunkId() : -1;
    int[] numLevels=tinfo._adaptedFrame.cardinality();
    double[][] yinit=initialXY(tinfo,dinfo._adaptedFrame,na_cnt);
    Archetypes yt=new Archetypes(ArrayUtils.transpose(yinit),true,tinfo._catOffsets,numLevels);
    if (na_cnt == 0 && _parms.hasClosedForm())     initialXClosedForm(dinfo,yt,model._output._normSub,model._output._normMul);
    boolean regX=_parms._regularization_x != GLRMParameters.Regularizer.None && _parms._gamma_x != 0;
    ObjCalc objtsk=new ObjCalc(_parms,yt,_ncolA,_ncolX,dinfo._cats,model._output._normSub,model._output._normMul,weightId,regX).doAll(dinfo._adaptedFrame);
    model._output._objective=objtsk._loss + _parms._gamma_x * objtsk._xold_reg + _parms._gamma_y * _parms.regularize_y(yt._archetypes);
    model._output._iterations=0;
    model._output._avg_change_obj=2 * TOLERANCE;
    model.update(_key);
    update(1);
    double step=_parms._init_step_size;
    int steps_in_row=0;
    while (!isDone(model,steps_in_row,step)) {
      UpdateX xtsk=new UpdateX(_parms,yt,step / _ncolA,overwriteX,_ncolA,_ncolX,dinfo._cats,model._output._normSub,model._output._normMul,weightId);
      xtsk.doAll(dinfo._adaptedFrame);
      UpdateY ytsk=new UpdateY(_parms,yt,step / _ncolA,_ncolA,_ncolX,dinfo._cats,model._output._normSub,model._output._normMul,weightId);
      double[][] yttmp=ytsk.doAll(dinfo._adaptedFrame)._ytnew;
      Archetypes ytnew=new Archetypes(yttmp,true,dinfo._catOffsets,numLevels);
      objtsk=new ObjCalc(_parms,ytnew,_ncolA,_ncolX,dinfo._cats,model._output._normSub,model._output._normMul,weightId).doAll(dinfo._adaptedFrame);
      double obj_new=objtsk._loss + _parms._gamma_x * xtsk._xreg + _parms._gamma_y * ytsk._yreg;
      model._output._avg_change_obj=(model._output._objective - obj_new) / nobs;
      model._output._iterations++;
      if (model._output._avg_change_obj > 0) {
        model._output._archetypes_raw=yt=ytnew;
        model._output._objective=obj_new;
        step*=1.05;
        steps_in_row=Math.max(1,steps_in_row + 1);
        overwriteX=true;
      }
 else {
        step=step / Math.max(1.5,-steps_in_row);
        steps_in_row=Math.min(0,steps_in_row - 1);
        overwriteX=false;
        if (_parms._verbose)         Log.info("Iteration " + model._output._iterations + ": Objective increased to "+ obj_new+ "; reducing step size to "+ step);
      }
      model._output._step_size=step;
      model.update(self());
      update(1);
    }
    Vec[] xvecs=new Vec[_ncolX];
    if (overwriteX) {
      for (int i=0; i < _ncolX; i++)       xvecs[i]=fr.vec(idx_xnew(i,_ncolA,_ncolX));
    }
 else {
      for (int i=0; i < _ncolX; i++)       xvecs[i]=fr.vec(idx_xold(i,_ncolA));
    }
    x=new Frame(_parms._loading_key,null,xvecs);
    xinfo=new DataInfo(Key.make(),x,null,0,true,DataInfo.TransformType.NONE,DataInfo.TransformType.NONE,false,false,false,false,false,false);
    DKV.put(x._key,x);
    DKV.put(xinfo._key,xinfo);
    model._output._step_size=step;
    model._output._loading_key=_parms._loading_key;
    model._output._archetypes_raw=yt;
    model._output._archetypes=yt.buildTable(model._output._names_expanded,false);
    if (_parms._recover_svd)     recoverSVD(model,xinfo);
    model._output._training_metrics=model.scoreMetricsOnly(_parms.train());
    if (_valid != null)     model._output._validation_metrics=model.scoreMetricsOnly(_parms.valid());
    model.update(self());
    done();
  }
 catch (  Throwable t) {
    Job thisJob=DKV.getGet(_key);
    if (thisJob._state == JobState.CANCELLED) {
      Log.info("Job cancelled by user.");
    }
 else {
      t.printStackTrace();
      failed(t);
      throw t;
    }
  }
 finally {
    updateModelOutput();
    _parms.read_unlock_frames(GLRM.this);
    if (model != null)     model.unlock(_key);
    if (tinfo != null)     tinfo.remove();
    if (dinfo != null)     dinfo.remove();
    if (xinfo != null)     xinfo.remove();
    if (fr != null) {
      if (overwriteX) {
        for (int i=0; i < _ncolX; i++)         fr.vec(idx_xold(i,_ncolA)).remove();
      }
 else {
        for (int i=0; i < _ncolX; i++)         fr.vec(idx_xnew(i,_ncolA,_ncolX)).remove();
      }
    }
  }
  tryComplete();
}
