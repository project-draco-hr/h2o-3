{
  long seed=0xDECAF;
  Random rng=new Random(seed);
  String[] datasets=new String[2];
  int[][] responses=new int[datasets.length][];
  datasets[0]="smalldata/logreg/prostate.csv";
  responses[0]=new int[]{1,2,8};
  datasets[1]="smalldata/iris/iris.csv";
  responses[1]=new int[]{4};
  HashSet<Long> checkSums=new LinkedHashSet<>();
  int testcount=0;
  int count=0;
  for (int i=0; i < datasets.length; ++i) {
    final String dataset=datasets[i];
    NFSFileVec nfs=NFSFileVec.make(find_test_file(dataset));
    Frame frame=ParseDataset.parse(Key.make(),nfs._key);
    NFSFileVec vnfs=NFSFileVec.make(find_test_file(dataset));
    Frame vframe=ParseDataset.parse(Key.make(),vnfs._key);
    Scope.enter();
    try {
      for (      int resp : responses[i]) {
        boolean classification=!(i == 0 && resp == 2);
        if (classification && !frame.vec(resp).isEnum()) {
          Scope.track(frame.replace(resp,frame.vec(resp).toEnum())._key);
          DKV.put(frame._key,frame);
        }
        for (        DeepLearningParameters.Loss loss : new DeepLearningParameters.Loss[]{DeepLearningParameters.Loss.CrossEntropy,DeepLearningParameters.Loss.Huber,DeepLearningParameters.Loss.Absolute,DeepLearningParameters.Loss.MeanSquare}) {
          if (!classification && loss == DeepLearningParameters.Loss.CrossEntropy)           continue;
          for (          boolean replicate : new boolean[]{true,false}) {
            for (            DeepLearningParameters.Activation activation : new DeepLearningParameters.Activation[]{DeepLearningParameters.Activation.Tanh,DeepLearningParameters.Activation.TanhWithDropout,DeepLearningParameters.Activation.Rectifier,DeepLearningParameters.Activation.RectifierWithDropout,DeepLearningParameters.Activation.Maxout,DeepLearningParameters.Activation.MaxoutWithDropout}) {
              for (              boolean load_balance : new boolean[]{true,false}) {
                for (                boolean shuffle : new boolean[]{true,false}) {
                  for (                  boolean balance_classes : new boolean[]{true,false}) {
                    for (                    ClassSamplingMethod csm : new ClassSamplingMethod[]{ClassSamplingMethod.Stratified,ClassSamplingMethod.Uniform}) {
                      for (                      int scoretraining : new int[]{200,20,0}) {
                        for (                        int scorevalidation : new int[]{200,20,0}) {
                          for (                          int vf : new int[]{0,1,-1}) {
                            for (                            int n_folds : new int[]{0}) {
                              if (n_folds != 0 && vf != 0)                               continue;
                              for (                              boolean keep_cv_splits : new boolean[]{false}) {
                                for (                                boolean override_with_best_model : new boolean[]{false,true}) {
                                  for (                                  int train_samples_per_iteration : new int[]{-2,-1,0,rng.nextInt(200),500}) {
                                    DeepLearningModel model1=null, model2=null, tmp_model=null;
                                    Key dest, dest_tmp;
                                    count++;
                                    if (fraction < rng.nextFloat())                                     continue;
                                    try {
                                      Scope.enter();
                                      Log.info("**************************)");
                                      Log.info("Starting test #" + count);
                                      Log.info("**************************)");
                                      final double epochs=7 + rng.nextDouble() + rng.nextInt(4);
                                      final int[] hidden=new int[]{1 + rng.nextInt(4),1 + rng.nextInt(6)};
                                      Frame valid=null;
                                      if (vf == 1)                                       valid=frame;
 else                                       if (vf == -1)                                       valid=vframe;
{
                                        Log.info("Using seed: " + seed);
                                        DeepLearningParameters p=new DeepLearningParameters();
                                        p._model_id=Key.make(Key.make().toString() + "first");
                                        dest_tmp=p._model_id;
                                        p._checkpoint=null;
                                        p._train=frame._key;
                                        p._response_column=frame._names[resp];
                                        p._valid=valid == null ? null : valid._key;
                                        p._hidden=hidden;
                                        p._activation=activation;
                                        p._override_with_best_model=override_with_best_model;
                                        p._epochs=epochs;
                                        p._loss=loss;
                                        if (n_folds > 0) {
                                          H2O.unimpl();
                                        }
                                        p._keep_cross_validation_splits=keep_cv_splits;
                                        p._seed=seed;
                                        p._train_samples_per_iteration=train_samples_per_iteration;
                                        p._force_load_balance=load_balance;
                                        p._replicate_training_data=replicate;
                                        p._shuffle_training_data=shuffle;
                                        p._score_training_samples=scoretraining;
                                        p._score_validation_samples=scorevalidation;
                                        p._classification_stop=-1;
                                        p._regression_stop=-1;
                                        p._balance_classes=classification && balance_classes;
                                        p._quiet_mode=true;
                                        p._score_validation_sampling=csm;
                                        DeepLearning dl=new DeepLearning(p);
                                        try {
                                          model1=dl.trainModel().get();
                                          checkSums.add(model1.checksum());
                                        }
 catch (                                        Throwable t) {
                                          throw t;
                                        }
 finally {
                                          dl.remove();
                                        }
                                        Log.info("Trained for " + model1.epoch_counter + " epochs.");
                                        assert(((p._train_samples_per_iteration <= 0 || p._train_samples_per_iteration >= frame.numRows()) && model1.epoch_counter > epochs) || Math.abs(model1.epoch_counter - epochs) / epochs < 0.20);
                                        if (n_folds != 0) {
                                          throw H2O.unimpl();
                                        }
                                      }
                                      DeepLearningParameters p=new DeepLearningParameters();
                                      tmp_model=DKV.get(dest_tmp).get();
                                      Assert.assertTrue(tmp_model.model_info().get_processed_total() >= frame.numRows() * epochs);
                                      assert(tmp_model != null);
                                      p._destination_key=Key.make();
                                      dest=p._destination_key;
                                      p._checkpoint=dest_tmp;
                                      p._valid=valid == null ? null : valid._key;
                                      p._response_column=frame._names[resp];
                                      p._override_with_best_model=override_with_best_model;
                                      p._epochs=epochs;
                                      p._loss=loss;
                                      p._seed=seed;
                                      p._train_samples_per_iteration=train_samples_per_iteration;
                                      p._balance_classes=classification && balance_classes;
                                      p._train=frame._key;
                                      DeepLearning dl=new DeepLearning(p);
                                      try {
                                        model1=dl.trainModel().get();
                                      }
 catch (                                      Throwable t) {
                                        throw t;
                                      }
 finally {
                                        dl.remove();
                                      }
                                      model2=DKV.get(dest).get();
                                      if (valid == null)                                       valid=frame;
                                      double threshold=0;
                                      if (model2._output.isClassifier()) {
                                        Frame pred=null, pred2=null;
                                        try {
                                          pred=model2.score(valid);
                                          Assert.assertTrue(model2.testJavaScoring(valid,pred,1e-6));
                                          hex.ModelMetrics mm=hex.ModelMetrics.getFromDKV(model2,valid);
                                          double error=0;
                                          if (model2._output.nclasses() == 2) {
                                            assert(resp == 1);
                                            threshold=mm.auc().defaultThreshold();
                                            error=mm.auc().defaultErr();
                                            Assert.assertEquals(new ConfusionMatrix(mm.auc().defaultCM(),new String[]{"0","1"}).err(),error,1e-15);
                                            Assert.assertEquals(mm.cm().err(),error,1e-15);
                                          }
                                          pred2=new Frame(Key.make("pred2"),pred.names(),pred.vecs());
                                          pred2.delete_and_lock(null);
                                          pred2.unlock(null);
                                          if (model2._output.nclasses() == 2) {
                                            String ast="(= ([ %pred2 \"null\" #0) (G ([ %pred2 \"null\" #2) #" + threshold + "))";
                                            Env ev=Exec.exec(ast);
                                            try {
                                              pred2=ev.popAry();
                                            }
  finally {
                                              if (ev != null)                                               ev.remove_and_unlock();
                                            }
                                            double threshErr2=buildCM(valid.vecs()[resp].toEnum(),pred2.vecs()[0].toEnum()).err();
                                            Assert.assertEquals(threshErr2,error,1e-2);
                                          }
                                        }
  finally {
                                          if (pred != null)                                           pred.delete();
                                          if (pred2 != null)                                           pred2.delete();
                                        }
                                      }
 else {
                                        Frame pred=model2.score(valid);
                                        Assert.assertTrue(model1.testJavaScoring(frame,pred,1e-6));
                                        pred.delete();
                                      }
                                      Log.info("Parameters combination " + count + ": PASS");
                                      testcount++;
                                    }
 catch (                                    Throwable t) {
                                      t.printStackTrace();
                                      throw new RuntimeException(t);
                                    }
 finally {
                                      if (model1 != null) {
                                        model1.delete_xval_models();
                                        model1.delete();
                                      }
                                      if (model2 != null) {
                                        model2.delete_xval_models();
                                        model2.delete();
                                      }
                                      if (tmp_model != null) {
                                        tmp_model.delete_xval_models();
                                        tmp_model.delete();
                                      }
                                      Scope.exit();
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  finally {
      frame.delete();
      vframe.delete();
      Scope.exit();
    }
  }
  Assert.assertTrue(checkSums.size() == testcount);
  Log.info("\n\n=============================================");
  Log.info("Tested " + testcount + " out of "+ count+ " parameter combinations.");
  Log.info("=============================================");
}
