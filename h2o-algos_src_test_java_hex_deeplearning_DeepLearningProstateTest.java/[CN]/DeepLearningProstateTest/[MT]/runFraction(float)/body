{
  long seed=0xDECAF;
  Random rng=new Random(seed);
  String[] datasets=new String[2];
  int[][] responses=new int[datasets.length][];
  datasets[0]="smalldata/./logreg/prostate.csv";
  responses[0]=new int[]{1,2,8};
  datasets[1]="smalldata/iris/iris.csv";
  responses[1]=new int[]{4};
  int testcount=0;
  int count=0;
  for (int i=0; i < datasets.length; ++i) {
    final String dataset=datasets[i];
    NFSFileVec nfs=NFSFileVec.make(find_test_file(dataset));
    Frame frame=ParseDataset2.parse(Key.make(),nfs._key);
    NFSFileVec vnfs=NFSFileVec.make(find_test_file(dataset));
    Frame vframe=ParseDataset2.parse(Key.make(),vnfs._key);
    try {
      for (      boolean replicate : new boolean[]{true,false}) {
        for (        boolean load_balance : new boolean[]{true,false}) {
          for (          boolean shuffle : new boolean[]{true,false}) {
            for (            boolean balance_classes : new boolean[]{true,false}) {
              for (              int resp : responses[i]) {
                for (                ClassSamplingMethod csm : new ClassSamplingMethod[]{ClassSamplingMethod.Stratified,ClassSamplingMethod.Uniform}) {
                  for (                  int scoretraining : new int[]{200,20,0}) {
                    for (                    int scorevalidation : new int[]{200,20,0}) {
                      for (                      int vf : new int[]{0,1,-1}) {
                        for (                        int n_folds : new int[]{0}) {
                          if (n_folds != 0 && vf != 0)                           continue;
                          for (                          boolean keep_cv_splits : new boolean[]{false}) {
                            for (                            boolean override_with_best_model : new boolean[]{false,true}) {
                              for (                              int train_samples_per_iteration : new int[]{-2,-1,0,rng.nextInt(100),500}) {
                                DeepLearningModel model1=null, model2=null, tmp_model=null;
                                Key dest=null, dest_tmp=null;
                                count++;
                                if (fraction < rng.nextFloat())                                 continue;
                                try {
                                  Log.info("**************************)");
                                  Log.info("Starting test #" + count);
                                  Log.info("**************************)");
                                  final double epochs=7 + rng.nextDouble() + rng.nextInt(4);
                                  final int[] hidden=new int[]{1 + rng.nextInt(4),1 + rng.nextInt(6)};
                                  Frame valid=null;
                                  if (vf == 1)                                   valid=frame;
 else                                   if (vf == -1)                                   valid=vframe;
                                  dest_tmp=Key.make(Key.make().toString() + "first");
{
                                    Log.info("Using seed: " + seed);
                                    DeepLearningParameters p=new DeepLearningParameters();
                                    p.checkpoint=null;
                                    p.source=frame;
                                    p.response_vec=frame.vecs()[resp];
                                    p.validation=valid;
                                    p.hidden=hidden;
                                    if (i == 0 && resp == 2)                                     p.classification=false;
                                    p.override_with_best_model=override_with_best_model;
                                    p.epochs=epochs;
                                    p.n_folds=n_folds;
                                    p.keep_cross_validation_splits=keep_cv_splits;
                                    p.seed=seed;
                                    p.train_samples_per_iteration=train_samples_per_iteration;
                                    p.force_load_balance=load_balance;
                                    p.replicate_training_data=replicate;
                                    p.shuffle_training_data=shuffle;
                                    p.score_training_samples=scoretraining;
                                    p.score_validation_samples=scorevalidation;
                                    p.classification_stop=-1;
                                    p.regression_stop=-1;
                                    p.balance_classes=balance_classes;
                                    p.quiet_mode=true;
                                    p.score_validation_sampling=csm;
                                    DeepLearning dl=new DeepLearning(dest_tmp,p);
                                    try {
                                      model1=dl.train().get();
                                    }
 catch (                                    Throwable t) {
                                      t.printStackTrace();
                                      throw new RuntimeException(t);
                                    }
 finally {
                                      dl.remove();
                                    }
                                    if (n_folds != 0) {
                                      throw H2O.unimpl();
                                    }
                                  }
                                  dest=Key.make();
                                  DeepLearningParameters p=new DeepLearningParameters();
                                  tmp_model=DKV.get(dest_tmp).get();
                                  Assert.assertTrue(tmp_model.model_info().get_processed_total() >= frame.numRows() * epochs);
                                  assert(tmp_model != null);
                                  p.checkpoint=dest_tmp;
                                  p.n_folds=0;
                                  p.source=frame;
                                  p.validation=valid;
                                  p.response_vec=frame.vecs()[resp];
                                  if (i == 0 && resp == 2)                                   p.classification=false;
                                  p.override_with_best_model=override_with_best_model;
                                  p.epochs=epochs;
                                  p.seed=seed;
                                  p.train_samples_per_iteration=train_samples_per_iteration;
                                  DeepLearning dl=new DeepLearning(dest,p);
                                  try {
                                    model1=dl.train().get();
                                  }
 catch (                                  Throwable t) {
                                    t.printStackTrace();
                                    throw new RuntimeException(t);
                                  }
 finally {
                                    dl.remove();
                                  }
                                  model2=DKV.get(dest).get();
                                  if (model2.actual_best_model_key != null) {
                                    final DeepLearningModel best_model=DKV.get(model2.actual_best_model_key).get();
                                    if (override_with_best_model) {
                                      Assert.assertEquals(best_model.error(),model2.error(),0);
                                    }
                                  }
                                  if (valid == null)                                   valid=frame;
                                  double threshold=0;
                                  if (model2._output.isClassifier()) {
                                    Frame pred=null, pred2=null;
                                    try {
                                      pred=model2.score(valid);
                                      StringBuilder sb=new StringBuilder();
                                      AUC auc=new AUC();
                                      double error=0;
                                      if (model2._output.nclasses() == 2) {
                                        auc.actual=valid;
                                        assert(resp == 1);
                                        auc.vactual=valid.vecs()[resp];
                                        auc.predict=pred;
                                        auc.vpredict=pred.vecs()[2];
                                        auc.execImpl();
                                        AUCData aucd=auc.data();
                                        threshold=aucd.threshold();
                                        error=aucd.err();
                                        Log.info(sb);
                                        Assert.assertEquals(new ConfusionMatrix2(auc.data().cm()).err(),error,1e-15);
                                        Assert.assertEquals(model2.calcError(valid,valid.lastVec(),pred,pred,"training",false,0,null,auc,null),error,1e-15);
                                      }
                                      double CMerrorOrig;
{
                                        sb=new StringBuilder();
                                        water.ConfusionMatrix CM=new water.ConfusionMatrix();
                                        CM.actual=valid;
                                        CM.vactual=valid.vecs()[resp];
                                        CM.predict=pred;
                                        CM.vpredict=pred.vecs()[0];
                                        CM.execImpl();
                                        sb.append("\n");
                                        sb.append("Threshold: " + "default\n");
                                        CM.toASCII(sb);
                                        Log.info(sb);
                                      }
                                      pred2=new Frame(Key.make("pred2"),pred.names(),pred.vecs());
                                      pred2.delete_and_lock(null);
                                      pred2.unlock(null);
                                    }
  finally {
                                      if (pred != null)                                       pred.delete();
                                      if (pred2 != null)                                       pred2.delete();
                                    }
                                  }
                                  Log.info("Parameters combination " + count + ": PASS");
                                  testcount++;
                                }
 catch (                                Throwable t) {
                                  t.printStackTrace();
                                  throw new RuntimeException(t);
                                }
 finally {
                                  if (model1 != null) {
                                    model1.delete_xval_models();
                                    model1.delete_best_model();
                                    model1.delete();
                                  }
                                  if (model2 != null) {
                                    model2.delete_xval_models();
                                    model2.delete_best_model();
                                    model2.delete();
                                  }
                                  if (tmp_model != null) {
                                    tmp_model.delete_xval_models();
                                    tmp_model.delete_best_model();
                                    tmp_model.delete();
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  finally {
      frame.delete();
      vframe.delete();
    }
  }
  Log.info("\n\n=============================================");
  Log.info("Tested " + testcount + " out of "+ count+ " parameter combinations.");
  Log.info("=============================================");
}
