{
  if (_compute_p_values && _solver != Solver.AUTO && _solver != Solver.IRLSM)   glm.error("_compute_p_values","P values can only be computed with IRLSM solver, go solver = " + _solver);
  if (_compute_p_values && (_lambda == null || _lambda[0] > 0))   glm.error("_compute_p_values","P values can only be computed with NO REGULARIZATION (lambda = 0)");
  if (_compute_p_values && _family == Family.multinomial)   glm.error("_compute_p_values","P values are currently not supported for family=multinomial");
  if (_compute_p_values && _non_negative)   glm.error("_compute_p_values","P values are currently not supported for family=multinomial");
  if (_weights_column != null && _offset_column != null && _weights_column.equals(_offset_column))   glm.error("_offset_column","Offset must be different from weights");
  if (_lambda_search)   if (glm.nFoldCV())   glm.error("_lambda_search","Lambda search is not currently supported in conjunction with N-fold cross-validation");
  if (_nlambdas == -1)   _nlambdas=100;
 else   _exactLambdas=false;
  if (_obj_reg != -1 && _obj_reg <= 0)   glm.error("obj_reg","Must be positive or -1 for default");
  if (_prior != -1 && _prior <= 0 || _prior >= 1)   glm.error("_prior","Prior must be in (exlusive) range (0,1)");
  if (_family != Family.tweedie) {
    glm.hide("_tweedie_variance_power","Only applicable with Tweedie family");
    glm.hide("_tweedie_link_power","Only applicable with Tweedie family");
  }
  if (_beta_constraints != null) {
    if (_family == Family.multinomial)     glm.error("beta_constraints","beta constraints are not supported for family = multionomial");
    Frame f=_beta_constraints.get();
    if (f == null)     glm.error("beta_constraints","Missing frame for beta constraints");
    Vec v=f.vec("names");
    if (v == null)     glm.error("beta_constraints","Beta constraints parameter must have names column with valid coefficient names");
    v=f.vec("upper_bounds");
    if (v != null && !v.isNumeric())     glm.error("beta_constraints","upper_bounds must be numeric if present");
    v=f.vec("upper_bounds");
    v=f.vec("lower_bounds");
    if (v != null && !v.isNumeric())     glm.error("beta_constraints","lower_bounds must be numeric if present");
    v=f.vec("beta_given");
    if (v != null && !v.isNumeric())     glm.error("beta_constraints","beta_given must be numeric if present");
    v=f.vec("upper_bounds");
    v=f.vec("beta_start");
    if (v != null && !v.isNumeric())     glm.error("beta_constraints","beta_start must be numeric if present");
  }
  if (_family == Family.binomial) {
    Frame frame=DKV.getGet(_train);
    if (frame != null) {
      Vec response=frame.vec(_response_column);
      if (response != null) {
        if (response.min() < 0 || response.max() > 1) {
          glm.error("_response_column","Illegal response for family binomial, must be binary, got min = " + response.min() + ", max = "+ response.max()+ ")");
        }
      }
    }
  }
  if (!_lambda_search) {
    glm.hide("_lambda_min_ratio","only applies if lambda search is on.");
    glm.hide("_nlambdas","only applies if lambda search is on.");
  }
  if (_link != Link.family_default) {
switch (_family) {
case gaussian:
      if (_link != Link.identity && _link != Link.log && _link != Link.inverse)       throw new IllegalArgumentException("Incompatible link function for selected family. Only identity, log and inverse links are allowed for family=gaussian.");
    break;
case binomial:
  if (_link != Link.logit)   throw new IllegalArgumentException("Incompatible link function for selected family. Only logit is allowed for family=binomial. Got " + _link);
break;
case poisson:
if (_link != Link.log && _link != Link.identity) throw new IllegalArgumentException("Incompatible link function for selected family. Only log and identity links are allowed for family=poisson.");
break;
case gamma:
if (_link != Link.inverse && _link != Link.log && _link != Link.identity) throw new IllegalArgumentException("Incompatible link function for selected family. Only inverse, log and identity links are allowed for family=gamma.");
break;
case tweedie:
if (_link != Link.tweedie) throw new IllegalArgumentException("Incompatible link function for selected family. Only tweedie link allowed for family=tweedie.");
break;
case multinomial:
if (_link != Link.multinomial) throw new IllegalArgumentException("Incompatible link function for selected family. Only multinomial link allowed for family=multinomial.");
break;
default :
H2O.fail();
}
}
}
