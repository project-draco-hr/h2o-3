{
  if (_family == Family.binomial) {
    Frame frame=DKV.getGet(_train);
    if (frame != null) {
      Vec response=frame.vec(_response_column);
      if (response != null) {
        if (response.min() != 0 || response.max() != 1) {
          glm.error("_response_column","Illegal response for family binomial, must be binary, got min = " + response.min() + ", max = "+ response.max()+ ")");
        }
      }
    }
  }
  if (_solver == Solver.L_BFGS) {
    glm.hide("_alpha","L1 penalty is currently only available for ADMM solver.");
    glm.hide("_higher_accuracy","only available for ADMM");
    _alpha=new double[]{0};
  }
  if (!_lambda_search) {
    glm.hide("_lambda_min_ratio","only applies if lambda search is on.");
    glm.hide("_nlambdas","only applies if lambda search is on.");
  }
  if (_link != Link.family_default) {
switch (_family) {
case gaussian:
      if (_link != Link.identity && _link != Link.log && _link != Link.inverse)       throw new IllegalArgumentException("Incompatible link function for selected family. Only identity, log and inverse links are allowed for family=gaussian.");
    break;
case binomial:
  if (_link != Link.logit && _link != Link.log)   throw new IllegalArgumentException("Incompatible link function for selected family. Only logit and log links are allowed for family=binomial.");
break;
case poisson:
if (_link != Link.log && _link != Link.identity) throw new IllegalArgumentException("Incompatible link function for selected family. Only log and identity links are allowed for family=poisson.");
break;
case gamma:
if (_link != Link.inverse && _link != Link.log && _link != Link.identity) throw new IllegalArgumentException("Incompatible link function for selected family. Only inverse, log and identity links are allowed for family=gamma.");
break;
case tweedie:
if (_link != Link.tweedie) throw new IllegalArgumentException("Incompatible link function for selected family. Only tweedie link allowed for family=tweedie.");
break;
default :
H2O.fail();
}
}
}
