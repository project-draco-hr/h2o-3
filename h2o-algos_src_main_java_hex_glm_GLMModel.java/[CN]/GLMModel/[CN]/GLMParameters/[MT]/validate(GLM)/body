{
  if (_n_folds < 0)   glm.error("n_folds","must be >= 0");
  if (_n_folds == 1)   _n_folds=0;
  if (_lambda_search && _nlambdas == -1)   _nlambdas=100;
  if (_beta_constraints != null) {
    Frame f=_beta_constraints.get();
    if (f == null)     glm.error("beta_constraints","Missing frame for beta constraints");
    Vec v=f.vec("names");
    if (v == null)     glm.error("beta_constraints","Beta constraints parameter must have names column with valid coefficient names");
    v=f.vec("upper_bounds");
    if (v != null && !v.isNumeric())     glm.error("beta_constraints","upper_bounds must be numeric if present");
    v=f.vec("upper_bounds");
    v=f.vec("lower_bounds");
    if (v != null && !v.isNumeric())     glm.error("beta_constraints","lower_bounds must be numeric if present");
    v=f.vec("beta_given");
    if (v != null && !v.isNumeric())     glm.error("beta_constraints","beta_given must be numeric if present");
    v=f.vec("upper_bounds");
    v=f.vec("beta_start");
    if (v != null && !v.isNumeric())     glm.error("beta_constraints","beta_start must be numeric if present");
  }
  if (_family == Family.binomial) {
    Frame frame=DKV.getGet(_train);
    if (frame != null) {
      Vec response=frame.vec(_response_column);
      if (response != null) {
        if (response.min() != 0 || response.max() != 1) {
          glm.error("_response_column","Illegal response for family binomial, must be binary, got min = " + response.min() + ", max = "+ response.max()+ ")");
        }
      }
    }
  }
  if (!_lambda_search) {
    glm.hide("_lambda_min_ratio","only applies if lambda search is on.");
    glm.hide("_nlambdas","only applies if lambda search is on.");
  }
  if (_link != Link.family_default) {
switch (_family) {
case gaussian:
      if (_link != Link.identity && _link != Link.log && _link != Link.inverse)       throw new IllegalArgumentException("Incompatible link function for selected family. Only identity, log and inverse links are allowed for family=gaussian.");
    break;
case binomial:
  if (_link != Link.logit && _link != Link.log)   throw new IllegalArgumentException("Incompatible link function for selected family. Only logit and log links are allowed for family=binomial.");
break;
case poisson:
if (_link != Link.log && _link != Link.identity) throw new IllegalArgumentException("Incompatible link function for selected family. Only log and identity links are allowed for family=poisson.");
break;
case gamma:
if (_link != Link.inverse && _link != Link.log && _link != Link.identity) throw new IllegalArgumentException("Incompatible link function for selected family. Only inverse, log and identity links are allowed for family=gamma.");
break;
case tweedie:
if (_link != Link.tweedie) throw new IllegalArgumentException("Incompatible link function for selected family. Only tweedie link allowed for family=tweedie.");
break;
default :
H2O.fail();
}
}
}
