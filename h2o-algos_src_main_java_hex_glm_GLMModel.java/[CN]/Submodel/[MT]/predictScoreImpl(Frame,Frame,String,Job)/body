{
  final int nc=_output.nclasses();
  final int ncols=nc == 1 ? 1 : nc + 1;
  String[] names=new String[ncols];
  String[][] domains=new String[ncols][];
  names[0]="predict";
  for (int i=1; i < names.length; ++i) {
    names[i]=_output.classNames()[i - 1];
    try {
      Integer.valueOf(names[i]);
      names[i]="p" + names[i];
    }
 catch (    Throwable t) {
    }
  }
  final boolean computeMetrics=adaptFrm.find(_output.responseName()) >= 0;
  domains[0]=nc == 1 ? null : !computeMetrics ? _output._domains[_output._domains.length - 1] : adaptFrm.lastVec().domain();
  boolean hasWeigths=_parms._weights_column != null && adaptFrm.find(_parms._weights_column) >= 0;
  boolean hasOffset=_parms._offset_column != null && adaptFrm.find(_parms._offset_column) >= 0;
  boolean hasFold=_parms._fold_column != null && adaptFrm.find(_parms._fold_column) >= 0;
  DataInfo dinfo=new DataInfo(adaptFrm.clone(),null,computeMetrics ? 1 : 0,_parms._use_all_factor_levels || _parms._lambda_search,DataInfo.TransformType.NONE,DataInfo.TransformType.NONE,_parms._missing_values_handling == MissingValuesHandling.Skip,false,_parms._missing_values_handling == MissingValuesHandling.MeanImputation,hasWeigths,hasOffset,hasFold);
  GLMScore gs=new GLMScore(j,this,dinfo,domains[0],computeMetrics).doAll(ncols,Vec.T_NUM,dinfo._adaptedFrame);
  if (computeMetrics)   gs._mb.makeModelMetrics(this,fr,adaptFrm,gs.outputFrame());
  return gs.outputFrame((null == destination_key ? Key.make() : Key.make(destination_key)),names,domains);
}
