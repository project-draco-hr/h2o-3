def _doit(self):
    if self.isComputed():
        return
    left = self._left
    rite = self._rite
    if isinstance(rite, Expr):
        rite._doit()
    global _CMD
    _CMD += (('(' + self._op) + ' ')
    if left:
        if left.isPending():
            left._doit()
        elif isinstance(left._data, (int, float)):
            _CMD += ('#' + str(left))
        else:
            _CMD += ('%' + str(left._data))
    _CMD += ' '
    if rite:
        if rite.isPending():
            rite._doit()
        elif isinstance(rite._data, (int, float)):
            _CMD += ('#' + str(rite))
        else:
            _CMD += ('%' + str(rite._data))
    if (self._op == '+'):
        if isinstance(left._data, (int, float)):
            if isinstance(rite._data, (int, float)):
                self._data = (left + rite)
            elif rite.isLocal():
                self._data = [(left + x) for x in rite._data]
            else:
                pass
        elif isinstance(rite._data, (int, float)):
            if left.isLocal():
                self._data = [(x + rite) for x in left._data]
            else:
                pass
        elif left.isLocal():
            self._data = [(x + y) for (x, y) in zip(left._data, rite._data)]
        else:
            pass
    elif (self._op == '['):
        if left.isLocal():
            self._data = left._data[rite._data]
        else:
            _CMD += ' #0'
    elif (self._op == 'mean'):
        if left.isLocal():
            self._data = (sum(left._data) / len(left._data))
        else:
            _CMD += ' #0 %TRUE'
    else:
        raise NotImplementedError
    _CMD += ')'
    self._left = None
    self._rite = None
    return
