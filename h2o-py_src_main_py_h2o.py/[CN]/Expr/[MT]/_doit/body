def _doit(self):
    if self.isComputed():
        return
    left = self._left
    rite = self._rite
    if isinstance(left, Expr):
        left._doit()
    if isinstance(rite, Expr):
        rite._doit()
    if (self._op == '+'):
        if isinstance(left._data, (int, float)):
            if isinstance(rite._data, (int, float)):
                (lname, rname) = (None, None)
                self._data = (left + rite)
            else:
                (lname, rname) = (str(left), rite._name)
                self._data = [(left + x) for x in rite._data]
        elif isinstance(rite._data, (int, float)):
            (lname, rname) = (left._name, str(rite))
            if left.isLocal():
                self._data = [(x + rite) for x in left._data]
            else:
                j = H2OCONN.Rapids((((((('(+ ([ $' + str(left._data)) + ' "null" #') + str(left._left)) + ') #') + str(rite)) + ')'))
                (self._data, left, rite) = (j['key']['name'], 0, '')
        else:
            (lname, rname) = (left._name, rite._name)
            self._data = [(x + y) for (x, y) in zip(left._data, rite._data)]
    elif (self._op == 'mean'):
        (lname, rname) = (left._name, None)
        self._data = (sum(left._data) / len(left._data))
    else:
        raise NotImplementedError
    if lname:
        global _CMD
        _CMD += (((((((self._name + '= ') + lname) + ' ') + self._op) + ' ') + str(rname)) + '; ')
    assert (self._data is not None)
    self._left = None
    self._rite = None
    return
