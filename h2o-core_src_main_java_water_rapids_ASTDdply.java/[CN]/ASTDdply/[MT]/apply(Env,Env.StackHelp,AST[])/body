{
  Frame fr=stk.track(asts[1].exec(env)).getFrame();
  int ncols=fr.numCols();
  ASTNumList groupby=ASTGroup.check(ncols,asts[2]);
  AST fun=asts[3].exec(env).getFun();
  ASTFun scope=env._scope;
  Frame fr_keys=ASTGroup.gbFrame(fr,groupby.expand4());
  final int ngbCols=fr_keys.numCols();
  IcedHashMap<ASTGroup.GKX,String> gs=ASTGroup.findGroups(fr_keys);
  final ASTGroup.GK0[] grps=ASTGroup.sortGroups(gs);
  Vec[] vgrps=new BuildGroup(gs).doAll(gs.size(),fr_keys).close();
  final RemoteRapids[] remoteTasks=new RemoteRapids[gs.size()];
  Futures fs=new Futures();
  for (int i=0; i < remoteTasks.length; i++)   fs.add(RPC.call(vgrps[i]._key.home_node(),remoteTasks[i]=new RemoteRapids(fr,vgrps[i]._key,fun,scope)));
  fs.blockForPending();
  final int res_len=remoteTasks[0]._result.length;
  String[] fcnames=new String[res_len];
  for (int i=0; i < res_len; i++)   fcnames[i]="ddply_C" + (i + 1);
  MRTask mrfill=new MRTask(){
    @Override public void map(    Chunk[] c,    NewChunk[] ncs){
      final int start=(int)c[0].start();
      final int len=c[0]._len;
      for (int i=0; i < len; i++) {
        int gnum=i + start;
        ASTGroup.GKX gkx=grps[gnum];
        gkx.setkey(ncs);
        double[] res=remoteTasks[i + start]._result;
        for (int a=0; a < res.length; a++)         ncs[a + ngbCols].addNum(res[a]);
      }
    }
  }
;
  Frame f=ASTGroup.buildOutput(fr_keys,res_len,fr,fcnames,gs.size(),mrfill);
  return new ValFrame(f);
}
