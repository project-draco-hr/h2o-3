{
  DataInfo qinfo=null;
  Frame u=null;
  final int ncolA=dinfo._adaptedFrame.numCols();
  try {
    Vec[] vecs=new Vec[ncolA + _parms._nv];
    for (int i=0; i < ncolA; i++)     vecs[i]=dinfo._adaptedFrame.vec(i);
    for (int i=0; i < _parms._nv; i++)     vecs[ncolA + i]=qfrm.vec(i);
    Frame aqfrm=new Frame(vecs);
    SMulTask stsk=new SMulTask(ncolA,_ncolExp,model._output._ncats,_parms._nv,model._output._normSub,model._output._normMul,model._output._catOffsets,_parms._use_all_factor_levels);
    stsk.doAll(aqfrm);
    double[][] qta=ArrayUtils.transpose(stsk._atq);
    Matrix qtaJ=new Matrix(qta);
    SingularValueDecomposition svdJ=qtaJ.svd();
    if (!_parms._only_v && _parms._keep_u) {
      model._output._u_key=Key.make(_parms._u_name);
      double[][] svdJ_u=svdJ.getU().getArray();
      qinfo=new DataInfo(Key.make(),qfrm,null,true,DataInfo.TransformType.NONE,false,false,false);
      DKV.put(qinfo._key,qinfo);
      BMulTask btsk=new BMulTask(self(),qinfo,ArrayUtils.transpose(svdJ_u));
      btsk.doAll(_parms._nv,qinfo._adaptedFrame);
      u=btsk.outputFrame(model._output._u_key,null,null);
    }
    model._output._d=svdJ.getSingularValues();
    model._output._v=svdJ.getV().getArray();
  }
 catch (  Throwable t) {
    Job thisJob=DKV.getGet(_key);
    if (thisJob._state == JobState.CANCELLED) {
      Log.info("Job cancelled by user.");
    }
 else {
      t.printStackTrace();
      failed(t);
      throw t;
    }
  }
 finally {
    if (qinfo != null)     qinfo.remove();
  }
  return u;
}
