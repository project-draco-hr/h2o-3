{
  SVDModel model=null;
  DataInfo uinfo=null, dinfo=null;
  Frame fr=null, u=null;
  try {
    _parms.read_lock_frames(SVD.this);
    init(true);
    if (error_count() > 0)     throw new IllegalArgumentException("Found validation errors: " + validationErrors());
    model=new SVDModel(dest(),_parms,new SVDModel.SVDOutput(SVD.this));
    model.delete_and_lock(_key);
    _train.read_lock(_key);
    dinfo=new DataInfo(Key.make(),_train,null,0,false,_parms._transform,DataInfo.TransformType.NONE,true);
    DKV.put(dinfo._key,dinfo);
    model._output._normSub=_normSub=dinfo._normSub == null ? new double[_train.numCols()] : Arrays.copyOf(dinfo._normSub,_train.numCols());
    if (dinfo._normMul == null) {
      model._output._normMul=_normMul=new double[_train.numCols()];
      Arrays.fill(model._output._normMul,1.0);
    }
 else     model._output._normMul=_normMul=Arrays.copyOf(dinfo._normMul,_train.numCols());
    GramTask tsk=new GramTask(self(),dinfo).doAll(dinfo._adaptedFrame);
    double[][] gram=tsk._gram.getXX();
    double[] sigma=new double[_parms._nv];
    double[][] rsvec=new double[_parms._nv][gram.length];
    rsvec[0]=powerLoop(gram,_parms._seed);
    double[][] ivv_sum=new double[gram.length][gram.length];
    for (int i=0; i < gram.length; i++)     ivv_sum[i][i]=1;
    if (!_parms._only_v) {
      Vec[] vecs=new Vec[_ncols + _parms._nv];
      for (int i=0; i < _ncols; i++)       vecs[i]=_train.vec(i);
      for (int i=_ncols; i < vecs.length; i++)       vecs[i]=_train.anyVec().makeZero();
      fr=new Frame(null,vecs);
      uinfo=new DataInfo(Key.make(),fr,null,0,false,_parms._transform,DataInfo.TransformType.NONE,true);
      double[] ivv_vk=ArrayUtils.multArrVec(ivv_sum,rsvec[0]);
      sigma[0]=new CalcSigmaU(ivv_vk).doAll(uinfo._adaptedFrame)._sval;
    }
    double[][] vv=ArrayUtils.outerProduct(rsvec[0],rsvec[0]);
    ivv_sum=sub_symm(ivv_sum,vv);
    double[][] gram_update=ArrayUtils.multArrArr(ArrayUtils.multArrArr(ivv_sum,gram),ivv_sum);
    for (int k=1; k < _parms._nv; k++) {
      rsvec[k]=powerLoop(gram_update,_parms._seed);
      if (!_parms._only_v) {
        double[] ivv_vk=ArrayUtils.multArrVec(ivv_sum,rsvec[k]);
        sigma[k]=new CalcSigmaUNorm(ivv_vk,k,sigma[k - 1]).doAll(uinfo._adaptedFrame)._sval;
      }
      vv=ArrayUtils.outerProduct(rsvec[k],rsvec[k]);
      ivv_sum=sub_symm(ivv_sum,vv);
      double[][] lmat=ArrayUtils.multArrArr(ivv_sum,gram);
      gram_update=ArrayUtils.multArrArr(lmat,ivv_sum);
    }
    model._output._v=ArrayUtils.transpose(rsvec);
    if (!_parms._only_v) {
      model._output._d=sigma;
      final double sigma_last=sigma[_parms._nv - 1];
      new MRTask(){
        @Override public void map(        Chunk cs[]){
          div(chk_u(cs,_parms._nv - 1),sigma_last);
        }
      }
.doAll(uinfo._adaptedFrame);
      Vec[] uvecs=new Vec[_parms._nv];
      for (int i=0; i < _parms._nv; i++)       uvecs[i]=fr.vec(idx_u(i));
      u=new Frame(_parms._ukey,null,uvecs);
      DKV.put(u._key,u);
      model._output._ukey=_parms._ukey;
    }
    done();
  }
 catch (  Throwable t) {
    Job thisJob=DKV.getGet(_key);
    if (thisJob._state == JobState.CANCELLED) {
      Log.info("Job cancelled by user.");
    }
 else {
      t.printStackTrace();
      failed(t);
      throw t;
    }
  }
 finally {
    if (model != null)     model.unlock(_key);
    if (dinfo != null)     dinfo.remove();
    if (uinfo != null)     uinfo.remove();
    _parms.read_unlock_frames(SVD.this);
  }
  tryComplete();
}
