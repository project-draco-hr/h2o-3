{
  double[][] gt=ArrayUtils.gaussianArray(_parms._nv,_ncolExp,seed);
  RandSubInit rtsk=new RandSubInit(self(),dinfo,gt);
  rtsk.doAll(dinfo._adaptedFrame);
  Frame yinit=rtsk.outputFrame(Key.make(),null,null);
  DataInfo yinfo=new DataInfo(Key.make(),yinit,null,true,DataInfo.TransformType.NONE,true,false,false);
  DKV.put(yinfo._key,yinfo);
  GramTask gtsk=new GramTask(self(),yinfo);
  gtsk.doAll(yinfo._adaptedFrame);
  Matrix ygram=new Matrix(gtsk._gram.getXX());
  CholeskyDecomposition chol=new CholeskyDecomposition(ygram);
  final int ncolA=dinfo._adaptedFrame.numCols();
  Vec[] vecs=new Vec[ncolA + _parms._nv];
  for (int i=0; i < ncolA; i++)   vecs[i]=dinfo._adaptedFrame.vec(i);
  for (int i=0; i < _parms._nv; i++)   vecs[ncolA + i]=dinfo._adaptedFrame.anyVec().makeZero();
  Frame aqfrm=new Frame(vecs);
  for (int q=0; q < iters; q++) {
    QRfromChol qrtsk=new QRfromChol(chol,gtsk._nobs,ncolA,_ncolExp,dinfo._cats,_parms._nv,model._output._normSub,model._output._normMul,model._output._catOffsets,_parms._use_all_factor_levels);
    qrtsk.doAll(aqfrm);
    SMulTask stsk=new SMulTask(ncolA,_ncolExp,dinfo._cats,_parms._nv,model._output._normSub,model._output._normMul,model._output._catOffsets,_parms._use_all_factor_levels);
    stsk.doAll(aqfrm);
    Matrix ysmall=new Matrix(stsk._atq);
    QRDecomposition ysmall_qr=new QRDecomposition(ysmall);
    double[][] ysmall_q=ysmall_qr.getQ().getArray();
    BMulTask btsk=new BMulTask(self(),dinfo,ArrayUtils.transpose(ysmall_q));
    btsk.doAll(dinfo._adaptedFrame);
    Frame ybig=btsk.outputFrame(Key.make(),null,null);
    yinfo=new DataInfo(Key.make(),ybig,null,true,DataInfo.TransformType.NONE,true,false,false);
    DKV.put(yinfo._key,yinfo);
    gtsk=new GramTask(self(),yinfo);
    gtsk.doAll(yinfo._adaptedFrame);
    ygram=new Matrix(gtsk._gram.getXX());
    chol=new CholeskyDecomposition(ygram);
  }
  Frame qfrm=aqfrm.extractFrame(ncolA,aqfrm.numCols());
  return qfrm;
}
