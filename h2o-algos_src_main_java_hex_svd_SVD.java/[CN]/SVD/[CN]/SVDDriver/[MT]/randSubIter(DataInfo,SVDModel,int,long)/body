{
  DataInfo yinfo=null;
  Key yinfo_key=Key.make(), ykey=Key.make();
  Frame yinit=null, ybig=null, qfrm=null, ayqfrm=null;
  final int ncolA=dinfo._adaptedFrame.numCols();
  try {
    double[][] gt=ArrayUtils.gaussianArray(_parms._nv,_ncolExp,seed);
    RandSubInit rtsk=new RandSubInit(self(),dinfo,gt);
    rtsk.doAll(_parms._nv,dinfo._adaptedFrame);
    yinit=rtsk.outputFrame(ykey,null,null);
    yinfo=new DataInfo(yinfo_key,yinit,null,true,DataInfo.TransformType.NONE,true,false,false);
    DKV.put(yinfo._key,yinfo);
    GramTask gtsk=new GramTask(self(),yinfo);
    gtsk.doAll(yinfo._adaptedFrame);
    Matrix ygram=new Matrix(gtsk._gram.getXX());
    CholeskyDecomposition chol=new CholeskyDecomposition(ygram);
    ayqfrm=new Frame(dinfo._adaptedFrame);
    ayqfrm.add(yinit);
    for (int i=0; i < _parms._nv; i++)     ayqfrm.add("qcol_" + i,ayqfrm.anyVec().makeZero());
    double[] normSubY=new double[_parms._nv];
    double[] normMulY=new double[_parms._nv];
    Arrays.fill(normMulY,1.0);
    Frame yqfrm=ayqfrm.subframe(ncolA,ayqfrm.numCols());
    QRfromChol qrtsk=new QRfromChol(chol,gtsk._nobs,_parms._nv,_parms._nv,normSubY,normMulY);
    qrtsk.doAll(yqfrm);
    for (int q=0; q < iters; q++) {
      Frame aqfrm=ayqfrm.subframe(0,ncolA);
      aqfrm.add(ayqfrm.subframe(ncolA + _parms._nv,ayqfrm.numCols()));
      SMulTask stsk=new SMulTask(ncolA,_ncolExp,model._output._ncats,_parms._nv,model._output._normSub,model._output._normMul,model._output._catOffsets,_parms._use_all_factor_levels);
      stsk.doAll(aqfrm);
      Matrix ysmall=new Matrix(stsk._atq);
      QRDecomposition ysmall_qr=new QRDecomposition(ysmall);
      double[][] ysmall_q=ysmall_qr.getQ().getArray();
      Frame ayfrm=ayqfrm.subframe(0,ncolA + _parms._nv);
      BMulInPlaceTask tsk=new BMulInPlaceTask(ncolA,ArrayUtils.transpose(ysmall_q));
      tsk.doAll(ayfrm);
      ybig=ayfrm.subframe(ncolA,ayfrm.numCols());
      ybig=new Frame(ykey,ybig.names(),ybig.vecs());
      DKV.put(ybig);
      yinfo=new DataInfo(yinfo_key,ybig,null,true,DataInfo.TransformType.NONE,true,false,false);
      DKV.put(yinfo._key,yinfo);
      gtsk=new GramTask(self(),yinfo);
      gtsk.doAll(yinfo._adaptedFrame);
      ygram=new Matrix(gtsk._gram.getXX());
      chol=new CholeskyDecomposition(ygram);
      yqfrm=ayqfrm.subframe(ncolA,ayqfrm.numCols());
      qrtsk=new QRfromChol(chol,gtsk._nobs,_parms._nv,_parms._nv,normSubY,normMulY);
      qrtsk.doAll(yqfrm);
    }
    qfrm=ayqfrm.extractFrame(ncolA + _parms._nv,ayqfrm.numCols());
    qfrm=new Frame(Key.make(),qfrm.names(),qfrm.vecs());
    DKV.put(qfrm);
  }
 catch (  Throwable t) {
    Job thisJob=DKV.getGet(_key);
    if (thisJob._state == JobState.CANCELLED) {
      Log.info("Job cancelled by user.");
    }
 else {
      t.printStackTrace();
      failed(t);
      throw t;
    }
  }
 finally {
    if (yinfo != null)     yinfo.remove();
    if (yinit != null)     yinit.delete();
    if (ybig != null)     ybig.delete();
    if (ayqfrm != null) {
      for (int i=ncolA; i < ncolA + _parms._nv; i++)       ayqfrm.vec(i).remove();
    }
  }
  return qfrm;
}
