import sys, pprint
sys.path.extend(['.', '..', 'py'])
import h2o, h2o_util
import os
print 'ARGV is:', sys.argv
ip = '127.0.0.1'
port = 54321
parse_arguments(sys.argv)
print 'ip:', ip
print 'port', port
pp = pprint.PrettyPrinter(indent=4)
'\nValidate that a model builder seems to have a well-formed parameters list.\n'
'\nValidate that a model build result has no parameter validation errors, and that it has a Job with a Key.\n'
'\nCheck that we got the expected ERROR validation messages for a model build or validation check with bad parameters.\n'
'\nValidate that a given model key is found in the models list.\n'
'\nValidate that the returned parameters list for a model build contains all the values we passed in as input.\n'
'\nValidate a /Predictions result.\n'
'\nDELETE the specified models and frames from H2O.\n'
"\nDictionary which specifies all that's needed to build and validate a model.\n"
a_node = h2o.H2O(ip, port)
algos = ['example', 'kmeans', 'deeplearning', 'glm', 'gbm']
clean_up_after = False
h2o.H2O.verbose = False
h2o.H2O.verboseprint('connected to: ', '127.0.0.1', 54321)
models = a_node.models()
if h2o.H2O.verbose:
    print 'Models: '
    pp.pprint(models)
frames = a_node.frames(len=5)
if h2o.H2O.verbose:
    print 'Frames: '
    pp.pprint(frames)
print 'Testing /ModelBuilders. . .'
model_builders = a_node.model_builders(timeoutSecs=240)
if h2o.H2O.verbose:
    print 'ModelBuilders: '
    pp.pprint(model_builders)
for algo in algos:
    assert (algo in model_builders['model_builders']), ('Failed to find algo: ' + algo)
    builder = model_builders['model_builders'][algo]
    validate_builder(builder)
print 'Testing /ModelBuilders/{algo}. . .'
for algo in algos:
    model_builder = a_node.model_builders(algo=algo, timeoutSecs=240)
    assert (algo in model_builder['model_builders']), ('Failed to find algo: ' + algo)
    builder = model_builders['model_builders'][algo]
    validate_builder(builder)
print 'Testing /ModelMetrics. . .'
model_metrics = a_node.model_metrics(timeoutSecs=240)
if h2o.H2O.verbose:
    print 'ModelMetrics: '
    pp.pprint(model_metrics)
print 'Cleaning up old stuff. . .'
cleanup(a_node)
print 'Importing and parsing: prostate.csv'
import_result = a_node.import_files(path=os.path.realpath('../../smalldata/logreg/prostate.csv'))
if h2o.H2O.verbose:
    print 'import_result: '
    pp.pprint(import_result)
    print 'frames: '
    pp.pprint(a_node.frames(key=import_result['keys'][0], len=5))
frames = a_node.frames(key=import_result['keys'][0], len=5)['frames']
assert frames[0]['isText'], 'Raw imported Frame is not isText'
parse_result = a_node.parse(key=import_result['keys'][0])
prostate_key = parse_result['frames'][0]['key']['name']
frames = a_node.frames(len=5)['frames']
frames_dict = h2o_util.list_to_dict(frames, 'key/name')
if h2o.H2O.verbose:
    print 'frames: '
    pp.pprint(frames)
if h2o.H2O.verbose:
    print 'frames_dict: '
    pp.pprint(frames_dict)
assert (prostate_key in frames_dict), (('Failed to find ' + prostate_key) + ' in Frames list.')
assert (not frames_dict[prostate_key]['isText']), 'Parsed Frame is isText'
frames = a_node.frames(key=prostate_key, len=5)['frames']
frames_dict = h2o_util.list_to_dict(frames, 'key/name')
assert (prostate_key in frames_dict), 'Failed to find prostate.hex in Frames list.'
columns_dict = h2o_util.list_to_dict(frames[0]['columns'], 'label')
assert ('CAPSULE' in columns_dict), 'Failed to find CAPSULE in Frames/prostate.hex.'
assert ('AGE' in columns_dict), 'Failed to find AGE in Frames/prostate.hex/columns.'
assert ('bins' in columns_dict['AGE']), 'Failed to find bins in Frames/prostate.hex/columns/AGE.'
print 'bins: ', repr(columns_dict['AGE']['bins'])
assert (None is columns_dict['AGE']['bins']), 'Failed to clear bins field.'
frames = a_node.columns(key=prostate_key)['frames']
columns_dict = h2o_util.list_to_dict(frames[0]['columns'], 'label')
assert ('ID' in columns_dict), 'Failed to find ID in Frames/prostate.hex/columns.'
assert ('AGE' in columns_dict), 'Failed to find AGE in Frames/prostate.hex/columns.'
assert ('bins' in columns_dict['AGE']), 'Failed to find bins in Frames/prostate.hex/columns/AGE.'
print 'bins: ', repr(columns_dict['AGE']['bins'])
assert (None is columns_dict['AGE']['bins']), 'Failed to clear bins field.'
frames = a_node.column(key=prostate_key, column='AGE')['frames']
columns_dict = h2o_util.list_to_dict(frames[0]['columns'], 'label')
assert ('AGE' in columns_dict), 'Failed to find AGE in Frames/prostate.hex/columns.'
assert ('bins' in columns_dict['AGE']), 'Failed to find bins in Frames/prostate.hex/columns/AGE.'
print 'bins: ', repr(columns_dict['AGE']['bins'])
assert (None is columns_dict['AGE']['bins']), 'Failed to clear bins field.'
frames = a_node.summary(key=prostate_key, column='AGE')['frames']
columns_dict = h2o_util.list_to_dict(frames[0]['columns'], 'label')
assert ('AGE' in columns_dict), 'Failed to find AGE in Frames/prostate.hex/columns/AGE/summary.'
col = columns_dict['AGE']
h2o_util.assertKeysExistAndNonNull(col, '', ['label', 'missing', 'zeros', 'pinfs', 'ninfs', 'mins', 'maxs', 'mean', 'sigma', 'type', 'data', 'precision', 'bins', 'base', 'stride', 'pctiles'])
h2o_util.assertKeysExist(col, '', ['domain', 'str_data'])
assert (col['mins'][0] == 43), 'Failed to find 43 as the first min for AGE.'
assert (col['maxs'][0] == 79), 'Failed to find 79 as the first max for AGE.'
assert (col['mean'] == 66.03947368421052), 'Failed to find 66.03947368421052 as the mean for AGE.'
assert (col['sigma'] == 6.527071269173308), 'Failed to find 6.527071269173308 as the sigma for AGE.'
assert (col['type'] == 'int'), 'Failed to find int as the type for AGE.'
assert (col['data'][0] == 65), 'Failed to find 65 as the first data for AGE.'
assert (col['precision'] == (-1)), 'Failed to find -1 as the precision for AGE.'
assert (col['bins'][0] == 1), 'Failed to find 1 as the first bin for AGE.'
assert (col['base'] == 43), 'Failed to find 43 as the base for AGE.'
assert (col['stride'] == 1), 'Failed to find 1 as the stride for AGE.'
assert (col['pctiles'][0] == 50.5), 'Failed to find 50.5 as the first pctile for AGE.'
print 'Importing and parsing: allyears2k_headers.zip'
import_result = a_node.import_files(path=os.path.realpath('../../smalldata/airlines/allyears2k_headers.zip'))
parse_result = a_node.parse(key=import_result['keys'][0])
if h2o.H2O.verbose:
    pp.pprint(parse_result)
airlines_key = parse_result['frames'][0]['key']['name']
print 'Importing and parsing: iris_wheader.csv'
import_result = a_node.import_files(path=os.path.realpath('../../smalldata/iris/iris_wheader.csv'))
parse_result = a_node.parse(key=import_result['keys'][0])
if h2o.H2O.verbose:
    pp.pprint(parse_result)
iris_key = parse_result['frames'][0]['key']['name']
models_to_build = [ModelSpec('kmeans_prostate', 'kmeans', prostate_key, {'K': 2, }, 'Clustering'), ModelSpec('glm_prostate_regression', 'glm', prostate_key, {'response_column': 'CAPSULE', 'do_classification': False, }, 'Regression'), ModelSpec('glm_prostate_binomial', 'glm', prostate_key, {'response_column': 'CAPSULE', 'do_classification': True, 'family': 'binomial', }, 'Binomial'), ModelSpec('deeplearning_prostate_regression', 'deeplearning', prostate_key, {'response_column': 'CAPSULE', 'do_classification': False, }, 'Regression'), ModelSpec('deeplearning_prostate_binomial', 'deeplearning', prostate_key, {'response_column': 'CAPSULE', 'do_classification': True, 'hidden': '[10, 20, 10]', }, 'Binomial'), ModelSpec('deeplearning_airlines_binomial', 'deeplearning', airlines_key, {'response_column': 'IsDepDelayed', }, 'Binomial'), ModelSpec('deeplearning_iris_multinomial', 'deeplearning', iris_key, {'response_column': 'class', }, 'Multinomial'), ModelSpec('gbm_prostate_regression', 'gbm', prostate_key, {'response_column': 'CAPSULE', 'do_classification': False, }, 'Regression'), ModelSpec('gbm_prostate_binomial', 'gbm', prostate_key, {'response_column': 'CAPSULE', 'do_classification': True, }, 'Binomial'), ModelSpec('gbm_airlines_binomial', 'gbm', airlines_key, {'response_column': 'IsDepDelayed', }, 'Binomial'), ModelSpec('gbm_iris_multinomial', 'gbm', iris_key, {'response_column': 'class', }, 'Multinomial')]
built_models = {}
for model_spec in models_to_build:
    model = model_spec.build_and_validate_model(a_node)
    built_models[model_spec.dest_key] = model
model_builder = a_node.model_builders(algo='deeplearning', timeoutSecs=240)['model_builders']['deeplearning']
dl_test_parameters_list = model_builder['parameters']
dl_test_parameters = {value['name']: value['default_value'] for value in dl_test_parameters_list}
parameters_validation = a_node.validate_model_parameters(algo='deeplearning', training_frame=None, parameters=dl_test_parameters, timeoutSecs=240)
assert ('validation_error_count' in parameters_validation), 'Failed to find validation_error_count in good-parameters parameters validation result.'
h2o.H2O.verboseprint('Bad params validation messages: ', repr(parameters_validation))
if (1 != parameters_validation['validation_error_count']):
    print 'validation errors: '
    pp.pprint(parameters_validation)
assert (1 == parameters_validation['validation_error_count']), '1 != validation_error_count in good-parameters parameters validation result.'
assert ('training_frame' == parameters_validation['validation_messages'][0]['field_name']), 'First validation message is about missing training frame.'
dl_test_parameters = {'response_column': 'CAPSULE', 'hidden': '[10, 20, 10]', }
parameters_validation = a_node.validate_model_parameters(algo='deeplearning', training_frame=None, parameters=dl_test_parameters, timeoutSecs=240)
assert ('validation_error_count' in parameters_validation), 'Failed to find validation_error_count in good-parameters parameters validation result.'
h2o.H2O.verboseprint('Bad params validation messages: ', repr(parameters_validation))
if (1 != parameters_validation['validation_error_count']):
    print 'validation errors: '
    pp.pprint(parameters_validation)
assert (1 == parameters_validation['validation_error_count']), '1 != validation_error_count in good-parameters parameters validation result.'
assert ('training_frame' == parameters_validation['validation_messages'][0]['field_name']), 'First validation message is about missing training frame.'
dl_test_parameters = {'response_column': 'CAPSULE', 'hidden': '[10, 20, 10]', 'input_dropout_ratio': 27, }
parameters_validation = a_node.validate_model_parameters(algo='deeplearning', training_frame=None, parameters=dl_test_parameters, timeoutSecs=240)
assert ('validation_error_count' in parameters_validation), 'Failed to find validation_error_count in bad-parameters parameters validation result.'
h2o.H2O.verboseprint('Good params validation messages: ', repr(parameters_validation))
assert (2 == parameters_validation['validation_error_count']), '2 != validation_error_count in bad-parameters parameters validation result.'
assert ('training_frame' == parameters_validation['validation_messages'][0]['field_name']), 'First validation message is about missing training frame.'
found_expected_error = False
for validation_message in parameters_validation['validation_messages']:
    if ((validation_message['message_type'] == 'ERROR') and (validation_message['field_name'] == 'input_dropout_ratio')):
        found_expected_error = True
assert found_expected_error, 'Failed to find error message about input_dropout_ratio in the validation messages.'
print 'About to try to build a DeepLearning model with bad parameters. . .'
dl_prostate_bad_parameters = {'response_column': 'CAPSULE', 'hidden': '[10, 20, 10]', 'input_dropout_ratio': 27, }
parameters_validation = a_node.build_model(algo='deeplearning', destination_key='deeplearning_prostate_binomial_bad', training_frame=prostate_key, parameters=dl_prostate_bad_parameters, timeoutSecs=240)
validate_validation_messages(parameters_validation, ['input_dropout_ratio'])
print 'Done trying to build DeepLearning model with bad parameters.'
mm = a_node.compute_model_metrics(model='deeplearning_prostate_binomial', frame=prostate_key)
assert (mm is not None), ((('Got a null result for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + prostate_key)
assert ('model_category' in mm), (((('ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + prostate_key) + ' does not contain a model_category.')
assert ('Binomial' == mm['model_category']), ((((('ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + prostate_key) + ' model_category is not Binomial, it is: ') + mm['model_category'])
assert ('auc' in mm), (((('ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + prostate_key) + ' does not contain an AUC.')
assert ('cm' in mm), (((('ModelMetrics for scoring: ' + 'deeplearning_prostate_binomial') + ' on: ') + prostate_key) + ' does not contain a CM.')
h2o.H2O.verboseprint('ModelMetrics for scoring: ', 'deeplearning_prostate_binomial', ' on: ', prostate_key, ':  ', repr(mm))
mms = a_node.model_metrics()
assert ('model_metrics' in mms), 'Failed to find model_metrics in result of /3/ModelMetrics.'
found_mm = False
for mm in mms['model_metrics']:
    assert ('model' in mm), ('mm does not contain a model element: ' + repr(mm))
    assert ('key' in mm['model']), ('mm[model] does not contain a key: ' + repr(mm))
    assert ('frame' in mm), ('mm does not contain a model element: ' + repr(mm))
    assert ('key' in mm['frame']), ('mm[frame] does not contain a key: ' + repr(mm))
    assert ('name' in mm['frame']['key']), ('mm[frame][key] does not contain a name: ' + repr(mm))
    model_key = mm['model']['key']
    frame_key = mm['frame']['key']['name']
    if ((model_key == 'deeplearning_prostate_binomial') and (frame_key == prostate_key)):
        found_mm = True
assert found_mm, ((('Failed to find ModelMetrics object for model: ' + 'deeplearning_prostate_binomial') + ' and frame: ') + prostate_key)
p = a_node.predict(model='deeplearning_prostate_binomial', frame=prostate_key)
validate_predictions(p, 'deeplearning_prostate_binomial', prostate_key, 380)
h2o.H2O.verboseprint('Predictions for scoring: ', 'deeplearning_prostate_binomial', ' on: ', prostate_key, ':  ', repr(p))
p = a_node.predict(model='deeplearning_prostate_regression', frame=prostate_key)
validate_predictions(p, 'deeplearning_prostate_regression', prostate_key, 380)
h2o.H2O.verboseprint('Predictions for scoring: ', 'deeplearning_prostate_regression', ' on: ', prostate_key, ':  ', repr(p))
p = a_node.predict(model='gbm_prostate_binomial', frame=prostate_key)
validate_predictions(p, 'gbm_prostate_binomial', prostate_key, 380)
h2o.H2O.verboseprint('Predictions for scoring: ', 'gbm_prostate_binomial', ' on: ', prostate_key, ':  ', repr(p))
p = a_node.predict(model='gbm_prostate_regression', frame=prostate_key)
validate_predictions(p, 'gbm_prostate_regression', prostate_key, 380)
h2o.H2O.verboseprint('Predictions for scoring: ', 'gbm_prostate_regression', ' on: ', prostate_key, ':  ', repr(p))
p = a_node.predict(model='kmeans_prostate', frame=prostate_key)
validate_predictions(p, 'kmeans_prostate', prostate_key, 380)
h2o.H2O.verboseprint('Predictions for scoring: ', 'kmeans_prostate', ' on: ', prostate_key, ':  ', repr(p))
model = a_node.models(key='kmeans_prostate', find_compatible_frames=True)
found_kmeans = False
h2o.H2O.verboseprint('k-means model with find_compatible_frames output: ')
h2o.H2O.verboseprint('/Models/', 'kmeans_prostate', '?find_compatible_frames=true: ', repr(model))
h2o_util.assertKeysExist(model['models'][0], '', ['compatible_frames'])
assert (prostate_key in model['models'][0]['compatible_frames']), (('Failed to find ' + prostate_key) + ' in compatible_frames list.')
result = a_node.frames(key=prostate_key, find_compatible_models=True, len=5)
frames = result['frames']
frames_dict = h2o_util.list_to_dict(frames, 'key/name')
assert (prostate_key in frames_dict), 'Failed to find prostate.hex in Frames list.'
compatible_models = result['compatible_models']
models_dict = h2o_util.list_to_dict(compatible_models, 'key')
assert ('deeplearning_prostate_binomial' in models_dict), (('Failed to find ' + 'deeplearning_prostate_binomial') + ' in compatible models list.')
assert ('deeplearning_prostate_binomial' in frames[0]['compatible_models'])
assert ('kmeans_prostate' in frames[0]['compatible_models'])
h2o.H2O.verboseprint('/Frames/prosate.hex?find_compatible_models=true: ', repr(result))
if clean_up_after:
    cleanup(models=[dl_airlines_model_name, 'deeplearning_prostate_binomial', 'kmeans_prostate'], frames=[prostate_key, airlines_key])
