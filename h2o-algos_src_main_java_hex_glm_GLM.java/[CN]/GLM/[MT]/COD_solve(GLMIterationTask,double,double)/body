{
  gt._gram.mul(_parms._obj_reg);
  ArrayUtils.mult(gt._xy,_parms._obj_reg);
  double wsumInv=1.0 / (gt.wsum * _parms._obj_reg);
  double l1pen=lambda * alpha;
  double l2pen=lambda * (1 - alpha);
  double[][] xx=gt._gram.getXX();
  double[] grads=gt._xy.clone();
  double[] beta=_state.beta().clone();
  for (int i=0; i < grads.length; ++i) {
    double ip=0;
    for (int j=0; j < beta.length; ++j)     ip+=beta[j] * xx[i][j];
    grads[i]=grads[i] - ip + beta[i] * xx[i][i];
  }
  double[] diagInv=MemoryManager.malloc8d(xx.length);
  for (int i=0; i < diagInv.length; ++i)   diagInv[i]=1.0 / (xx[i][i] + l2pen);
  int iter1=0;
  int P=gt._xy.length - 1;
  DataInfo activeData=_state.activeData();
  while (iter1++ < 1000) {
    double bdiffPos=0;
    double bdiffNeg=0;
    for (int i=0; i < activeData._cats; ++i) {
      for (int j=activeData._catOffsets[i]; j < activeData._catOffsets[i + 1]; ++j) {
        double b=ADMM.shrinkage(grads[j],l1pen) * diagInv[j];
        double bd=beta[j] - b;
        bdiffPos=bd > bdiffPos ? bd : bdiffPos;
        bdiffNeg=bd < bdiffNeg ? bd : bdiffNeg;
        doUpdateCD(grads,xx,bd,j,activeData._catOffsets[i],activeData._catOffsets[i + 1]);
        beta[j]=b;
      }
    }
    int numStart=activeData.numStart();
    for (int i=numStart; i < P; ++i) {
      double b=ADMM.shrinkage(grads[i],l1pen) * diagInv[i];
      double bd=beta[i] - b;
      bdiffPos=bd > bdiffPos ? bd : bdiffPos;
      bdiffNeg=bd < bdiffNeg ? bd : bdiffNeg;
      doUpdateCD(grads,xx,bd,i,i,i + 1);
      beta[i]=b;
    }
    double b=grads[P] * wsumInv;
    double bd=beta[P] - b;
    doUpdateCD(grads,xx,bd,P,P,P + 1);
    bdiffPos=bd > bdiffPos ? bd : bdiffPos;
    bdiffNeg=bd < bdiffNeg ? bd : bdiffNeg;
    beta[P]=b;
    if (-1e-4 < bdiffNeg && bdiffPos < 1e-4)     break;
  }
  return beta;
}
