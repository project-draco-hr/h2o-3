{
  _start_time=System.currentTimeMillis();
  if (_currentLambda > _taskInfo._lambdaMax) {
    tryComplete();
    return;
  }
  _iter=_taskInfo._iter;
  LogInfo("starting computation of lambda = " + _currentLambda + ", previous lambda = "+ _taskInfo._lastLambda);
  int[] activeCols=activeCols(_currentLambda,_taskInfo._lastLambda,_taskInfo._gradient);
  int n=activeCols == null ? _taskInfo._dinfo.fullN() : activeCols.length;
  if (n > _taskInfo._params._max_active_predictors)   throw new TooManyPredictorsException();
  double[] beta=contractVec(_taskInfo._beta,_activeCols);
  _lastResult=new IterationInfo(_taskInfo._iter,beta,contractVec(_taskInfo._gradient,_activeCols),_taskInfo._objval);
  boolean LBFGS=_forceLBFGS;
  if (LBFGS) {
    if (_taskInfo._params._alpha[0] > 0 || _activeCols != null)     throw H2O.unimpl();
    Log.info("current lambda = " + _currentLambda);
    GradientSolver solver=(_activeData._adaptedFrame.numCols() >= 100 || isSparse(_activeData._adaptedFrame)) ? new GLMColBasedGradientSolver(_taskInfo._params,_activeData,_currentLambda,_taskInfo._ymu,_taskInfo._nobs) : new GLMGradientSolver(_taskInfo._params,_activeData,_currentLambda,_taskInfo._ymu,_taskInfo._nobs);
    if (beta == null) {
      beta=MemoryManager.malloc8d(_activeData.fullN() + 1);
      beta[beta.length - 1]=_taskInfo._params.link(_taskInfo._ymu);
    }
    long t1=System.currentTimeMillis();
    L_BFGS_Params lParms=new L_BFGS_Params();
    final int workInc=WORK_TOTAL / _taskInfo._params._lambda.length / lParms._maxIter;
    L_BFGS.Result r=L_BFGS.solve(solver,lParms,beta,new History(20,beta.length),new ProgressMonitor(){
      @Override public boolean progress(      GradientInfo ginfo){
        update(workInc,_jobKey);
        return Job.isRunning(_jobKey);
      }
    }
);
    long t2=System.currentTimeMillis();
    Log.info("LBFGS done in " + r.iter + " iterations and "+ ((t2 - t1) / 1000)+ " seconds, objval = "+ r.ginfo._objVal+ ", gradient norm = "+ MathUtils.l2norm2(r.ginfo._gradient));
    GradientInfo ginfo=r.ginfo;
    double[] newBeta=r.coefs;
    _taskInfo._beta=newBeta;
    _taskInfo._gradient=ginfo._gradient;
    _taskInfo._iter=(_iter+=r.iter);
    setSubmodel(newBeta,null,this);
    tryComplete();
  }
 else   new GLMIterationTask(_jobKey,_activeData,_taskInfo._params,true,false,false,beta,_taskInfo._ymu,1.0 / _taskInfo._nobs,_taskInfo._thresholds,new Iteration(this)).asyncExec(_activeData._adaptedFrame);
}
