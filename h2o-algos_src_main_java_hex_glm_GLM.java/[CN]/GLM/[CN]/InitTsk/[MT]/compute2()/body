{
  new YMUTask(_dinfo,nclasses(),_parms._weights_column != null,new H2OCallback<YMUTask>(this){
    @Override public void callback(    final YMUTask ymut){
      _yMu=_parms._intercept ? ymut._yMu : new double[nclasses()];
      _wsum=ymut._wsum;
      if (_parms._obj_reg == -1)       _parms._obj_reg=1.0 / _wsum;
      _ymuLink=(_parms._intercept && _parms._family != Family.multinomial) ? _parms.link(_yMu[0]) : 0;
      _yMin=ymut._yMin;
      _yMax=ymut._yMax;
      _nobs=ymut._nobs;
      if (ymut._comupteWeightedSigma) {
        double[] sigmas=MemoryManager.malloc8d(_dinfo._nums);
        double[] mean=MemoryManager.malloc8d(_dinfo._nums);
        for (int i=0; i < _dinfo._nums; ++i) {
          sigmas[i]=MathUtils.weightedSigma(ymut._nobs,ymut._wsum,ymut._xsum[i],ymut._xxsum[i]);
          mean[i]=ymut._xsum[i] / ymut._wsum;
        }
        _dinfo.updateWeightedSigmaAndMean(sigmas,mean);
      }
      if (_dinfo._offset && _parms._intercept) {
        InitTsk.this.addToPendingCount(1);
        DataInfo dinfo=_dinfo.filterExpandedColumns(new int[]{});
        new GLMIterationTask(GLM.this._key,dinfo,0,_parms,false,new double[]{_parms.link(_response.mean()) - _offset.mean()},0,_parms._intercept,new NullModelIteration(dinfo)).asyncExec(dinfo._adaptedFrame);
      }
 else       computeGradients();
    }
  }
).asyncExec(_dinfo._adaptedFrame);
}
