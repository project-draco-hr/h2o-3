{
  if (!_parms._intercept) {
    gram.dropIntercept();
    xy=Arrays.copyOf(xy,xy.length - 1);
  }
  gram.mul(_parms._obj_reg);
  ArrayUtils.mult(xy,_parms._obj_reg);
  if (_state._iter == 0 && (_parms._remove_colinear_columns || _parms._compute_p_values)) {
    ArrayList<Integer> ignoredCols=new ArrayList<>();
    Cholesky chol=_chol=gram.qrCholesky(ignoredCols);
    if (!ignoredCols.isEmpty()) {
      int[] collinear_cols=new int[ignoredCols.size()];
      for (int i=0; i < collinear_cols.length; ++i)       collinear_cols[i]=ignoredCols.get(i);
      String[] collinear_col_names=ArrayUtils.select(_state.activeData().coefNames(),collinear_cols);
      if (!_parms._remove_colinear_columns)       throw new IllegalArgumentException("Got collinear columns, can not compute p-values unless some of the co-lienar columns are removed, please re-run with remove collinear_columns flag on or remove the collinear columns manually. Found following dependent columns " + collinear_col_names);
      _model.addWarning("Removed collinear columns " + collinear_col_names);
      Log.warn("Removed collinear columns " + Arrays.toString(collinear_col_names));
      xy=ArrayUtils.select(xy,_state.removeCols(collinear_cols));
    }
    chol.solve(xy);
  }
 else {
    GramSolver slvr=new GramSolver(gram.clone(),xy.clone(),_parms._intercept,_state.l2pen(),_state.l1pen(),_state.activeBC()._betaGiven,_state.activeBC()._rho,_state.activeBC()._betaLB,_state.activeBC()._betaUB);
    _chol=slvr._chol;
    if (_state.l1pen() == 0 && !_state.activeBC().hasBounds())     slvr.solve(xy);
 else {
      xy=MemoryManager.malloc8d(xy.length);
      (_lslvr=new ADMM.L1Solver(1e-4,10000)).solve(slvr,xy,_state.l1pen(),_parms._intercept,_state.activeBC()._betaLB,_state.activeBC()._betaUB);
    }
  }
  return _parms._intercept ? xy : Arrays.copyOf(xy,xy.length + 1);
}
