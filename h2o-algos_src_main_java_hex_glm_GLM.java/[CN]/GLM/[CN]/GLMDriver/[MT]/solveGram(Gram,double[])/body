{
  if (!_parms._intercept) {
    gram.dropIntercept();
    xy=Arrays.copyOf(xy,xy.length - 1);
  }
  gram.mul(_parms._obj_reg);
  ArrayUtils.mult(xy,_parms._obj_reg);
  if (_parms._remove_collinear_columns || _parms._compute_p_values) {
    ArrayList<Integer> ignoredCols=new ArrayList<>();
    Cholesky chol=((_state._iter == 0 && _parms._remove_collinear_columns) ? gram.qrCholesky(ignoredCols) : gram.cholesky(null));
    if (!chol.isSPD())     throw new NonSPDMatrixException();
    _chol=chol;
    if (!ignoredCols.isEmpty()) {
      int[] collinear_cols=new int[ignoredCols.size()];
      for (int i=0; i < collinear_cols.length; ++i)       collinear_cols[i]=ignoredCols.get(i);
      String[] collinear_col_names=ArrayUtils.select(_state.activeData().coefNames(),collinear_cols);
      _model.addWarning("Removed collinear columns " + Arrays.toString(collinear_col_names));
      Log.warn("Removed collinear columns " + Arrays.toString(collinear_col_names));
      xy=ArrayUtils.select(xy,_state.removeCols(collinear_cols));
    }
    chol.solve(xy);
  }
 else {
    GramSolver slvr=new GramSolver(gram.clone(),xy.clone(),_parms._intercept,_state.l2pen(),_state.l1pen(),_state.activeBC()._betaGiven,_state.activeBC()._rho,_state.activeBC()._betaLB,_state.activeBC()._betaUB);
    _chol=slvr._chol;
    if (_state.l1pen() == 0 && !_state.activeBC().hasBounds())     slvr.solve(xy);
 else {
      xy=MemoryManager.malloc8d(xy.length);
      (_lslvr=new ADMM.L1Solver(1e-4,10000)).solve(slvr,xy,_state.l1pen(),_parms._intercept,_state.activeBC()._betaLB,_state.activeBC()._betaUB);
    }
  }
  return _parms._intercept ? xy : Arrays.copyOf(xy,xy.length + 1);
}
