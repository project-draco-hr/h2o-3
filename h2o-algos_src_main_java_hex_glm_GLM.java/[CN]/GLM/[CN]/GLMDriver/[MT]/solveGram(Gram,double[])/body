{
  if (!_parms._intercept) {
    gram.dropIntercept();
    xy=Arrays.copyOf(xy,xy.length - 1);
  }
  int[] zeros=gram.dropZeroCols();
  xy=ArrayUtils.removeIds(xy,zeros);
  _state.removeCols(zeros);
  gram.mul(_parms._obj_reg);
  ArrayUtils.mult(xy,_parms._obj_reg);
  if (_parms._remove_collinear_columns || _parms._compute_p_values) {
    ArrayList<Integer> ignoredCols=new ArrayList<>();
    Cholesky chol=((_state._iter == 0) ? gram.qrCholesky(ignoredCols,_parms._standardize) : gram.cholesky(null));
    if (!ignoredCols.isEmpty() && !_parms._remove_collinear_columns) {
      int[] collinear_cols=new int[ignoredCols.size()];
      for (int i=0; i < collinear_cols.length; ++i)       collinear_cols[i]=ignoredCols.get(i);
      throw new Gram.CollinearColumnsException("Found collinear columns in the dataset. P-values can not be computed with collinear columns in the dataset. Set remove_collinear_columns flag to true to remove collinear columns automatically. Found collinear columns " + Arrays.toString(ArrayUtils.select(_dinfo.coefNames(),collinear_cols)));
    }
    if (!chol.isSPD())     throw new NonSPDMatrixException();
    _chol=chol;
    if (!ignoredCols.isEmpty()) {
      int[] collinear_cols=new int[ignoredCols.size()];
      for (int i=0; i < collinear_cols.length; ++i)       collinear_cols[i]=ignoredCols.get(i);
      String[] collinear_col_names=ArrayUtils.select(_state.activeData().coefNames(),collinear_cols);
      _model.addWarning("Removed collinear columns " + Arrays.toString(collinear_col_names));
      Log.warn("Removed collinear columns " + Arrays.toString(collinear_col_names));
      _state.removeCols(collinear_cols);
      xy=ArrayUtils.removeIds(xy,collinear_cols);
    }
    chol.solve(xy);
  }
 else {
    GramSolver slvr=new GramSolver(gram.clone(),xy.clone(),_parms._intercept,_state.l2pen(),_state.l1pen(),_state.activeBC()._betaGiven,_state.activeBC()._rho,_state.activeBC()._betaLB,_state.activeBC()._betaUB);
    _chol=slvr._chol;
    if (_state.l1pen() == 0 && !_state.activeBC().hasBounds()) {
      slvr.solve(xy);
    }
 else {
      xy=MemoryManager.malloc8d(xy.length);
      (_lslvr=new ADMM.L1Solver(1e-4,10000)).solve(slvr,xy,_state.l1pen(),_parms._intercept,_state.activeBC()._betaLB,_state.activeBC()._betaUB);
    }
  }
  return _parms._intercept ? xy : Arrays.copyOf(xy,xy.length + 1);
}
