{
  Log.info("Gradient err at lambda = " + _parms._lambda[_lambdaId] + " = "+ _tInfos[0].gradientCheck(_parms._lambda[_lambdaId],_parms._alpha[0]));
  int rank=0;
  for (int i=0; i < _tInfos[0]._beta.length - (_dinfo._intercept ? 1 : 0); ++i)   if (_tInfos[0]._beta[i] != 0)   ++rank;
  Log.info("Solution at lambda = " + _parms._lambda[_lambdaId] + "has "+ rank+ " nonzeros");
  if (_parms._n_folds > 1) {
    ParallelTasks<GLMSingleLambdaTsk> t=(ParallelTasks<GLMSingleLambdaTsk>)h2OCountedCompleter;
    for (int i=0; i < t._tasks.length; ++i)     _tInfos[i]=t._tasks[i]._taskInfo;
  }
  if (++_lambdaId < _parms._lambda.length && _tInfos[0]._iter < _parms._max_iter) {
    getCompleter().addToPendingCount(1);
    if (_parms._n_folds > 1) {
      GLMSingleLambdaTsk[] tasks=new GLMSingleLambdaTsk[_tInfos.length];
      H2OCountedCompleter cmp=new LambdaSearchIteration((H2OCountedCompleter)getCompleter());
      cmp.addToPendingCount(tasks.length - 1);
      for (int i=0; i < tasks.length; ++i)       tasks[i]=new GLMSingleLambdaTsk(cmp,_tInfos[i]);
      new ParallelTasks(new LambdaSearchIteration((H2OCountedCompleter)getCompleter()),tasks).fork();
    }
 else {
      do {
        double currentLambda=_parms._lambda[_lambdaId - 1];
        double nextLambda=_parms._lambda[_lambdaId];
        _tInfos[0].adjustToNewLambda(currentLambda,nextLambda,_parms._alpha[0],_dinfo._intercept);
      }
 while ((_tInfos[0].gradientCheck(_parms._lambda[_lambdaId],_parms._alpha[0]) < GLM_GRAD_EPS) && ++_lambdaId < (_parms._lambda.length - 1));
      Log.info("GLM next lambdaId = " + _lambdaId);
      new GLMSingleLambdaTsk(new LambdaSearchIteration((H2OCountedCompleter)getCompleter()),_tInfos[0]).fork();
    }
  }
}
