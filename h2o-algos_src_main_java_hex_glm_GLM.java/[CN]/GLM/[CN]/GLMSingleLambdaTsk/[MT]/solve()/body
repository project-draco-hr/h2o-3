{
  if (_activeData.fullN() > _parms._max_active_predictors)   throw new TooManyPredictorsException();
switch (_parms._solver) {
case L_BFGS:
{
      double[] beta=_taskInfo._beta;
      GradientSolver solver=new GLMGradientSolver(_parms,_activeData,_parms._lambda[_lambdaId] * (1 - _parms._alpha[0]),_taskInfo._ymu,_taskInfo._nobs,_rowFilter);
      if (_bc._betaGiven != null && _bc._rho != null)       solver=new ProximalGradientSolver(solver,_bc._betaGiven,_bc._rho);
      if (beta == null) {
        beta=MemoryManager.malloc8d(_activeData.fullN() + (_activeData._intercept ? 1 : 0));
        if (_activeData._intercept)         beta[beta.length - 1]=_parms.link(_taskInfo._ymu);
      }
      L_BFGS lbfgs=new L_BFGS().setMaxIter(_parms._max_iter);
      Result r=lbfgs.solve(solver,beta,_taskInfo._ginfo,new ProgressMonitor(){
        @Override public boolean progress(        double[] beta,        GradientInfo ginfo){
          if ((_taskInfo._iter & 7) == 0) {
            update(8,"iteration " + (_taskInfo._iter + 1) + ", objective value = "+ ginfo._objVal,GLM.this._key);
            LogInfo("LBFGS: objval = " + ginfo._objVal);
          }
          ++_taskInfo._iter;
          return isRunning(GLM.this._key);
        }
      }
);
      _taskInfo._beta=r.coefs;
      double l1pen=_parms._lambda[_lambdaId] * _parms._alpha[0];
      if (l1pen > 0 || _bc.hasBounds()) {
        double[] rho=MemoryManager.malloc8d(beta.length);
        for (int i=0; i < rho.length; ++i)         rho[i]=ADMM.L1Solver.estimateRho(_taskInfo._beta[i],l1pen);
        new ADMM.L1Solver(1e-4,100).solve(new LBFGS_ProximalSolver(solver,r.coefs.clone(),rho),_taskInfo._beta,l1pen);
      }
      break;
    }
case COORDINATE_DESCENT:
  double l1pen=_parms._alpha[0] * _parms._lambda[_lambdaId];
double l2pen=(1 - _parms._alpha[0]) * _parms._lambda[_lambdaId];
double[] beta=_taskInfo._beta.clone();
int off;
double xOldSub;
double xOldMul;
double xNewSub=0;
double xNewMul=1;
double[] betaUpdate=null;
boolean betaChanges=true;
int iter=0;
while (betaChanges) {
int it=iter;
while (betaChanges && ++iter < 1000) {
betaChanges=false;
for (int i=0; i < _activeData._adaptedFrame.numCols(); ++i) {
Vec previousVec=i == 0 ? _taskInfo._iVec : _dinfo._adaptedFrame.vec(i - 1);
Vec currentVec=i == _dinfo._adaptedFrame.numCols() - 1 ? _taskInfo._iVec : _dinfo._adaptedFrame.vec(i);
xOldSub=xNewSub;
xOldMul=xNewMul;
boolean isCategorical=currentVec.isEnum();
int to;
if (isCategorical) {
xNewSub=0;
xNewMul=1;
off=_dinfo._catOffsets[i];
to=_dinfo._catOffsets[i + 1];
}
 else {
int k=i - _dinfo._cats;
xNewSub=_dinfo._normSub[k];
xNewMul=_dinfo._normMul[k];
off=_dinfo.numStart() + k;
to=off + 1;
}
double[] currentBeta=Arrays.copyOfRange(_taskInfo._beta,off,to);
double[] xy=new GLMCoordinateDescentTask(betaUpdate,currentBeta,xOldSub,xOldMul,xNewSub,xNewMul).doAll(previousVec,currentVec,_taskInfo._eVec,_taskInfo._wVec,_taskInfo._zVec)._xy;
for (int j=0; j < xy.length; ++j) {
betaUpdate=currentBeta;
double updatedCoef=ADMM.shrinkage(xy[j],l1pen) / (1 + l2pen);
betaUpdate[j]=updatedCoef - currentBeta[j];
if (betaUpdate[j] < -1e-4 || betaUpdate[j] > 1e-4) betaChanges=true;
beta[off + j]=updatedCoef;
}
}
}
if (iter > it + 1) {
betaChanges=true;
new GLMTask.GLMWeightsTask(_parms).doAll(_dinfo._adaptedFrame.lastVec(),_taskInfo._zVec,_taskInfo._wVec,_taskInfo._eVec);
}
}
break;
case ADMM:
new GLMIterationTask(GLM.this._key,_activeData,_parms._lambda[_lambdaId] * (1 - _parms._alpha[0]),_parms,false,_taskInfo._beta,_taskInfo._ymu,_rowFilter,new Iteration(this,false)).asyncExec(_activeData._adaptedFrame);
return;
default :
throw H2O.unimpl();
}
checkKKTsAndComplete();
tryComplete();
}
