import sys, pprint, argparse, errno, re, string
sys.path.insert(1, '../../py')
import h2o
import os
here = os.path.dirname(os.path.realpath(__file__))
parser = argparse.ArgumentParser(description='Attach to an H2O instance and call its REST API to generate the Java REST API bindings docs and write them to the filesystem.')
parser.add_argument('--verbose', '-v', help='verbose output', action='store_true')
parser.add_argument('--usecloud', help='ip:port to attach to', default='')
parser.add_argument('--host', help='hostname to attach to', default='localhost')
parser.add_argument('--port', help='port to attach to', type=int, default=54321)
parser.add_argument('--dest', help='destination directory', default=(here + '/../build/src-gen/thrift'))
args = parser.parse_args()
h2o.H2O.verbose = (True if args.verbose else False)
pp = pprint.PrettyPrinter(indent=4)
type_mapping = {'boolean': 'bool', 'byte': 'byte', 'short': 'i16', 'int': 'i32', 'long': 'i64', 'float': 'double', 'double': 'double', 'string': 'string', }
thrift_reserved_words = set(['from', 'type', 'exception', 'lambda', 'required'])
if (len(args.usecloud) > 0):
    arr = args.usecloud.split(':')
    args.host = arr[0]
    args.port = int(arr[1])
h2o.H2O.verboseprint('connecting to: ', args.host, ':', args.port)
a_node = h2o.H2O(args.host, args.port)
print 'creating the Thrift IDL in {}. . .'.format(args.dest)
save_full = ((args.dest + os.sep) + 'water/bindings/structs/H2O.thrift')
save_dir = os.path.dirname(save_full)
try:
    os.makedirs(save_dir)
except OSError as exception:
    if (exception.errno != errno.EEXIST):
        raise
with open(save_full, 'w') as the_file:
    the_file.write('###########################################\n')
    the_file.write('# Thrift bindings for H2O Machine Learning.\n')
    the_file.write('# NOTE: This file is generated. DO NOT EDIT\n')
    the_file.write('###########################################\n')
    the_file.write('namespace * water.bindings.structs\n')
    the_file.write('union PrimitiveUnion {')
    the_file.write('  1: bool bool_field\n')
    the_file.write('  2: byte byte_field\n')
    the_file.write('  3: i16 i16_field\n')
    the_file.write('  4: i32 i32_field\n')
    the_file.write('  5: i64 i64_field\n')
    the_file.write('  6: double double_field\n')
    the_file.write('  7: binary binary_field\n')
    the_file.write('  8: string string_field\n')
    the_file.write('}')
all_schemas = a_node.schemas()['schemas']
all_schemas_map = {}
all_schemas_ordered = []
enums = {}
for schema in all_schemas:
    if ('void' == schema['name']):
        continue
    schema_name = schema['name']
    all_schemas_map[schema_name] = schema
for schema in all_schemas:
    if ('void' == schema['name']):
        continue
    add_schema_to_dependency_array(schema, all_schemas_ordered)
for schema_name in all_schemas_ordered:
    if ('void' == schema_name):
        continue
    struct_name = schema_name
    schema = all_schemas_map[schema_name]
    if schema['type'].startswith('enum'):
        with open(save_full, 'a') as the_file:
            for line in generate_enum(schema_name, all_schemas_map[schema_name]['values']):
                the_file.write(('%s\n' % line))
    else:
        with open(save_full, 'a') as the_file:
            for line in generate_struct(all_schemas_map[schema_name], struct_name):
                the_file.write(('%s\n' % line))
endpoints_result = a_node.endpoints()
endpoints = endpoints_result['routes']
if h2o.H2O.verbose:
    print 'Endpoints: '
    pp.pprint(endpoints)
endpoints_meta = []
for num in range(len(endpoints)):
    meta = a_node.endpoint_by_number(num)['routes'][0]
    endpoints_meta.append(meta)
