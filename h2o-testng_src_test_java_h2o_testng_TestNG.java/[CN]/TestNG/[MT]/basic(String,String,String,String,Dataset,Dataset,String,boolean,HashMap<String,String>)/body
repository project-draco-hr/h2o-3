{
  RecordingTestcase rt=new RecordingTestcase();
  Param[] params=null;
  Model.Parameters modelParameter=null;
  String invalidMessage=null;
  String notImplMessage=null;
switch (algorithm) {
case FunctionUtils.drf:
    params=DRFConfig.params;
  break;
case FunctionUtils.gbm:
params=GBMConfig.params;
break;
case FunctionUtils.glm:
params=GLMConfig.params;
break;
default :
Reporter.log("do not implement for algorithm: " + algorithm);
}
try {
invalidMessage=FunctionUtils.validate(params,train_dataset_id,train_dataset,rawInput);
if (FunctionUtils.drf.equals(algorithm)) {
notImplMessage=FunctionUtils.checkImplemented(rawInput);
}
if (StringUtils.isNotEmpty(invalidMessage)) {
Reporter.log(invalidMessage,true);
Assert.fail(String.format(invalidMessage));
}
 else if (StringUtils.isNotEmpty(notImplMessage)) {
Reporter.log(notImplMessage,true);
Assert.fail(String.format(notImplMessage));
}
 else {
modelParameter=FunctionUtils.toModelParameter(params,algorithm,train_dataset_id,validate_dataset_id,train_dataset,validate_dataset,rawInput);
FunctionUtils.basicTesting(algorithm,modelParameter,isNegativeTestcase);
}
}
  finally {
Reporter.log("Total Memory used in testcase:" + (rt.getUsedMemory() / RecordingTestcase.MB) + "MB");
Reporter.log("Total Time used in testcase:" + (rt.getTimeRecording()) + "millis");
try {
Thread.sleep(100);
}
 catch (InterruptedException ex) {
Thread.currentThread().interrupt();
}
}
}
