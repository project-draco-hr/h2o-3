{
  if (null == http_method || null == uri)   return null;
  for (  Route r : _routes.values())   if (r._url_pattern.matcher(uri).matches())   if (http_method.equals(r._http_method))   return r;
  for (  Route r : _fallbacks.values())   if (r._url_pattern.matcher(uri).matches())   if (http_method.equals(r._http_method))   return r;
  Matcher m=getVersionPattern().matcher(uri);
  if (!m.matches())   return null;
  int version=Integer.valueOf(m.group(1));
  if (version == Route.MIN_VERSION)   return null;
  String lower_uri="/" + (version - 1) + "/"+ m.group(2);
  Route fallback=lookup(http_method,lower_uri);
  if (null == fallback)   return null;
  Matcher route_m=version_pattern.matcher(fallback._url_pattern_raw);
  if (!route_m.matches())   throw H2O.fail("Found a fallback route that doesn't have a version: " + fallback);
  int route_version=Integer.valueOf(route_m.group(1));
  for (int i=version; i > route_version && i >= Route.MIN_VERSION; i--) {
    String fallback_route_uri="/" + i + "/"+ route_m.group(2);
    Pattern fallback_route_pattern=Pattern.compile(fallback_route_uri);
    Route generated=new Route(fallback._http_method,fallback_route_uri,fallback_route_pattern,fallback._summary,fallback._handler_class,fallback._handler_method,fallback._path_params,fallback._handler_factory);
    _fallbacks.put(fallback_route_pattern.pattern(),generated);
  }
  return lookup(http_method,uri);
}
