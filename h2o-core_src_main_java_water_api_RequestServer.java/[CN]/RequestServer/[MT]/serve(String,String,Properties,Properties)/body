{
  Thread.currentThread().setPriority(Thread.MAX_PRIORITY - 1);
  int version=parseVersion(uri);
  int idx=version >> 16;
  version&=0xFFFF;
  String uripath=uri.substring(idx);
  RequestType type=RequestType.requestType(uripath);
  String path=type.requestName(uripath);
  String versioned_path="/" + version + path;
  alwaysLogRequest(path,method,parms);
  if (method.equals("HEAD") && uri.equals("/")) {
    Response r=new Response(HTTP_OK,MIME_PLAINTEXT,"");
    return r;
  }
  if (uri.endsWith("/Logs/download")) {
    maybeLogRequest(method,path,versioned_path,"",parms);
    return downloadLogs();
  }
  try {
    Route route=lookup(method,versioned_path);
    if (route != null && route._handler_class != CloudHandler.class && route._handler_class != TutorialsHandler.class && route._handler_class != TypeaheadHandler.class)     Schema.registerAllSchemasIfNecessary();
    if (route == null)     return getResource(version,type,uri);
 else     if (route._handler_class == water.api.DownloadDataHandler.class) {
      return wrapDownloadData(HTTP_OK,handle(type,route,version,parms));
    }
 else {
      capturePathParms(parms,versioned_path,route);
      maybeLogRequest(method,path,versioned_path,route._url_pattern.pattern(),parms);
      return wrap(handle(type,route,version,parms),type);
    }
  }
 catch (  H2OAbstractRuntimeException e) {
    H2OError error=e.toH2OError(uri);
    Log.warn(error._dev_msg);
    Log.warn(error._values.toJsonString());
    Log.warn((Object[])error._stacktrace);
    return wrap(new H2OErrorV1().fillFromImpl(error),type);
  }
catch (  Exception e) {
    H2OError error=new H2OError(e,uri);
    if (e instanceof IllegalArgumentException)     error._http_status=HttpResponseStatus.BAD_REQUEST.getCode();
 else     if (e instanceof FileNotFoundException)     error._http_status=HttpResponseStatus.BAD_REQUEST.getCode();
 else     if (e instanceof MalformedURLException)     error._http_status=HttpResponseStatus.BAD_REQUEST.getCode();
    Log.warn(error._dev_msg);
    Log.warn(error._values.toJsonString());
    Log.warn((Object[])error._stacktrace);
    return wrap(new H2OErrorV1().fillFromImpl(error),type);
  }
}
