{
  if (ast.type() == Env.NULL)   return null;
  ast.exec(env);
  long cols[];
  if (env.isNum()) {
    int col=(int)((ASTNum)env.pop())._d;
    if (col < 0 && col < -len)     col=0;
    if (col == 0)     return new long[0];
    return new long[]{col};
  }
  if (env.isSeries()) {
    ASTSeries a=env.popSeries();
    if (a.isColSelector())     return a.toArray();
    Frame ary=env.peekAry();
    final ASTSeries a0=a;
    Frame fr=new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs.len() + cs.start(); ++i) {
          if (a0.contains(i))           cs.set0((int)(i - cs.start()),1);
        }
      }
    }
.doAll(ary.anyVec().makeZero()).getResult()._fr;
    return fr;
  }
  if (env.isSpan()) {
    ASTSpan a=env.popSpan();
    if (a.isColSelector())     return a.toArray();
    Frame ary=env.peekAry();
    final ASTSpan a0=a;
    Frame fr=new MRTask(){
      @Override public void map(      Chunk cs){
        for (long i=cs.start(); i < cs.len() + cs.start(); ++i) {
          if (a0.contains(i))           cs.set0((int)(i - cs.start()),1);
        }
      }
    }
.doAll(ary.anyVec().makeZero()).getResult()._fr;
    return fr;
  }
  Frame ary=env.peekAry();
  if (ary.numCols() != 1)   throw new IllegalArgumentException("Selector must be a single column: " + ary.names());
  Vec vec=ary.anyVec();
  if (ary.numRows() == len && vec.min() >= 0 && vec.max() <= 1 && vec.isInt())   return ary;
  if (ary.numRows() > 10000000)   throw H2O.fail("Unimplemented: Cannot explicitly select > 10000000 rows in slice.");
  cols=MemoryManager.malloc8((int)ary.numRows());
  for (int i=0; i < cols.length; ++i) {
    if (vec.isNA(i))     throw new IllegalArgumentException("Can not use NA as index!");
    cols[i]=vec.at8(i);
  }
  return cols;
}
