{
  boolean is_enum=Enum.class.isAssignableFrom(clz);
  boolean is_array=clz.isArray();
  if (is_enum)   return "enum";
  if (String.class.isAssignableFrom(clz))   return "string";
  if (clz.equals(Boolean.TYPE) || clz.equals(Byte.TYPE) || clz.equals(Short.TYPE)|| clz.equals(Integer.TYPE)|| clz.equals(Long.TYPE)|| clz.equals(Float.TYPE)|| clz.equals(Double.TYPE))   return clz.toString();
  if (is_array)   return consType(schema,clz.getComponentType()) + "[]";
  if (Map.class.isAssignableFrom(clz))   return "Map";
  if (List.class.isAssignableFrom(clz))   return "List";
  if (water.Key.class.isAssignableFrom(clz))   return "Key";
  if (Schema.class.isAssignableFrom(clz)) {
    return Schema.getImplClass((Class<Schema>)clz).getSimpleName();
  }
  if (Iced.class.isAssignableFrom(clz)) {
    Log.warn("WARNING: found non-Schema Iced field: " + clz.toString() + " in Schema: "+ schema.getClass());
    return clz.getSimpleName();
  }
  Log.warn("Don't know how to generate a client-friendly type name for class: " + clz.toString() + " in Schema: "+ schema.getClass());
  return clz.toString();
}
