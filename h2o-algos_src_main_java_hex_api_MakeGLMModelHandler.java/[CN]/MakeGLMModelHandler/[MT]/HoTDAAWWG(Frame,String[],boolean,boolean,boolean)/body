{
  final DataInfo dinfo=new DataInfo(fr,null,1,useAll,standardize ? TransformType.STANDARDIZE : TransformType.NONE,TransformType.NONE,true,false,false,false,false,false,interactions);
  Frame res;
  if (interactionsOnly) {
    if (dinfo._interactionVecs == null)     throw new IllegalArgumentException("no interactions");
    int noutputs=0;
    final int[] colIds=new int[dinfo._interactionVecs.length];
    int idx=0;
    String[] coefNames=dinfo.coefNames();
    for (    int i : dinfo._interactionVecs)     colIds[idx++]=(noutputs+=((InteractionWrappedVec)dinfo._adaptedFrame.vec(i)).expandedLength());
    String[] names=new String[noutputs];
    int offset=idx=0;
    final int[] offsetIds=new int[colIds.length];
    for (int i=0; i < dinfo._adaptedFrame.numCols(); ++i) {
      Vec v=dinfo._adaptedFrame.vec(i);
      if (v instanceof InteractionWrappedVec) {
        int namesIdx=0;
        offsetIds[idx]=offset;
        while (namesIdx < colIds[idx])         names[namesIdx++]=coefNames[offset++];
        idx++;
        if (idx >= colIds.length)         break;
      }
 else {
        if (v.isCategorical())         offset+=v.domain().length - (useAll ? 0 : 1);
 else         offset++;
      }
    }
    res=new MRTask(){
      @Override public void map(      Chunk[] cs,      NewChunk ncs[]){
        DataInfo.Row r=dinfo.newDenseRow();
        for (int i=0; i < cs[0]._len; ++i) {
          r=dinfo.extractDenseRow(cs,i,r);
          int newChkIdx=0;
          for (int idx=0; idx < offsetIds.length; ++idx) {
            int startOffset=offsetIds[idx];
            for (int start=startOffset; start < (startOffset + colIds[idx]); ++start)             ncs[newChkIdx++].addNum(r.get(start));
          }
        }
      }
    }
.doAll(noutputs,Vec.T_NUM,dinfo._adaptedFrame).outputFrame(Key.make(),names,null);
  }
 else {
    byte[] types=new byte[dinfo.fullN()];
    Arrays.fill(types,Vec.T_NUM);
    res=new MRTask(){
      @Override public void map(      Chunk[] cs,      NewChunk ncs[]){
        DataInfo.Row r=dinfo.newDenseRow();
        for (int i=0; i < cs[0]._len; ++i) {
          r=dinfo.extractDenseRow(cs,i,r);
          for (int n=0; n < ncs.length; ++n)           ncs[n].addNum(r.get(n));
        }
      }
    }
.doAll(types,dinfo._adaptedFrame.vecs()).outputFrame(Key.make(),dinfo.coefNames(),null);
  }
  dinfo.dropInteractions();
  dinfo.remove();
  return res;
}
