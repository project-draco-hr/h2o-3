{
  boolean toss_fr=false;
  Frame fr0=null, fr1=null;
  double d0=0, d1=0;
  String s0=null, s1=null;
  int left_type=env.peekType();
  Object left=env.peek();
  int right_type=env.peekTypeAt(-1);
  Object right=env.peekAt(-1);
switch (left_type) {
case Env.NUM:
    d1=((ASTNum)left)._d;
  break;
case Env.ARY:
fr1=((ASTFrame)left)._fr;
break;
case Env.STR:
s1=((ASTString)left)._s;
break;
default :
throw H2O.fail("Got unusable type: " + left_type + " in binary operator "+ opStr());
}
switch (right_type) {
case Env.NUM:
d0=((ASTNum)right)._d;
break;
case Env.ARY:
fr0=((ASTFrame)right)._fr;
break;
case Env.STR:
s0=((ASTString)right)._s;
break;
default :
throw H2O.fail("Got unusable type: " + right_type + " in binary operator "+ opStr());
}
if ((fr0 == null && fr1 == null) && (s0 == null && s1 == null)) {
env.push(new ASTNum(op(d0,d1)));
return;
}
if (fr0 == null && fr1 == null) {
if (s0 == null) {
if (opStr().equals("==") || opStr().equals("!=")) env.push(new ASTNum(Double.valueOf(op(d0,s1))));
 else env.push(new ASTString('\"',op(d0,s1)));
}
 else if (s1 == null) {
if (opStr().equals("==") || opStr().equals("!=")) env.push(new ASTNum(Double.valueOf(op(s0,d1))));
 else env.push(new ASTString('\"',op(s0,d1)));
}
 else env.push(new ASTString('\"',op(s0,s1)));
return;
}
final boolean lf=fr0 != null;
final boolean rf=fr1 != null;
final double df0=d0, df1=d1;
final String sf0=s0, sf1=s1;
Frame fr;
int ncols=0;
if (fr0 != null) {
ncols=fr0.numCols();
if (fr1 != null) {
if (fr0.numCols() != fr1.numCols() || fr0.numRows() != fr1.numRows()) throw new IllegalArgumentException("Arrays must be same size: LHS FRAME NUM ROWS/COLS: " + fr0.numRows() + "/"+ fr0.numCols()+ " vs RHS FRAME NUM ROWS/COLS: "+ fr1.numRows()+ "/"+ fr1.numCols());
fr=new Frame(fr0).add(fr1);
toss_fr=true;
}
 else {
fr=new Frame(fr0);
}
}
 else {
ncols=fr1.numCols();
fr=new Frame(fr1);
}
final ASTBinOp bin=this;
Key tmp_key=Key.make();
Frame fr2=new MRTask(){
@Override public void map(Chunk chks[],NewChunk nchks[]){
for (int i=0; i < nchks.length; i++) {
NewChunk n=nchks[i];
int rlen=chks[0].len();
Chunk c0=chks[i];
if ((!c0.vec().isEnum() && !(lf && rf && chks[i + nchks.length].vec().isEnum())) || bin instanceof ASTEQ || bin instanceof ASTNE) {
for (int ro=0; ro < rlen; ro++) {
double lv=0;
double rv=0;
String l=null;
String r=null;
if (lf) {
if (chks[i].vec().isUUID() || (chks[i].isNA0(ro) && !bin.opStr().equals("|"))) {
n.addNum(Double.NaN);
continue;
}
if (chks[i].vec().isEnum()) l=chks[i].vec().domain()[(int)chks[i].at0(ro)];
 else lv=chks[i].at0(ro);
}
 else if (sf0 == null) {
if (Double.isNaN(df0) && !bin.opStr().equals("|")) {
n.addNum(Double.NaN);
continue;
}
lv=df0;
l=null;
}
 else {
l=sf0;
}
if (rf) {
if (chks[i + (lf ? nchks.length : 0)].vec().isUUID() || chks[i].isNA0(ro) && !bin.opStr().equals("|")) {
n.addNum(Double.NaN);
continue;
}
if (chks[i].vec().isEnum()) r=chks[i].vec().domain()[(int)chks[i].at0(ro)];
 else rv=chks[i + (lf ? nchks.length : 0)].at0(ro);
}
 else if (sf1 == null) {
if (Double.isNaN(df1) && !bin.opStr().equals("|")) {
n.addNum(Double.NaN);
continue;
}
rv=df1;
r=null;
}
 else {
r=sf1;
}
if (l == null && r == null) n.addNum(bin.op(lv,rv));
 else if (l == null) n.addNum(Double.valueOf(bin.op(lv,r)));
 else if (r == null) n.addNum(Double.valueOf(bin.op(l,rv)));
 else n.addNum(Double.valueOf(bin.op(l,r)));
}
}
 else {
for (int r=0; r < rlen; r++) n.addNA();
}
}
}
}
.doAll(ncols,fr).outputFrame(tmp_key,(lf ? fr0 : fr1)._names,null);
if (env.isAry()) env.cleanup(env.popAry());
 else env.pop();
if (env.isAry()) env.cleanup(env.popAry());
 else env.pop();
env.push(new ASTFrame(fr2));
}
