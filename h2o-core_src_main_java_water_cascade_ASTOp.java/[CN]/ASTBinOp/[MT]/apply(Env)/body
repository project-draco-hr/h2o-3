{
  boolean toss_fr=false;
  Frame fr0=null, fr1=null;
  double d0=0, d1=0;
  String s0="", s1="";
  int left_type=env.peekType();
  Object left=env.pop();
  int right_type=env.peekType();
  Object right=env.pop();
switch (left_type) {
case Env.NUM:
    d1=((ASTNum)left)._d;
  break;
case Env.ARY:
fr1=((ASTFrame)left)._fr;
break;
case Env.STR:
s1=((ASTString)left)._s;
break;
default :
throw H2O.fail("Got unusable type: " + left_type + " in binary operator "+ opStr());
}
switch (right_type) {
case Env.NUM:
d0=((ASTNum)right)._d;
break;
case Env.ARY:
fr0=((ASTFrame)right)._fr;
break;
case Env.STR:
s0=((ASTString)right)._s;
break;
default :
throw H2O.fail("Got unusable type: " + right_type + " in binary operator "+ opStr());
}
if (fr0 == null && fr1 == null) {
env.push(new ASTNum(op(d0,d1)));
return;
}
final boolean lf=fr0 != null;
final boolean rf=fr1 != null;
final double df0=d0, df1=d1;
Frame fr;
int ncols=0;
if (fr0 != null) {
ncols=fr0.numCols();
if (fr1 != null) {
if (fr0.numCols() != fr1.numCols() || fr0.numRows() != fr1.numRows()) throw new IllegalArgumentException("Arrays must be same size: LHS FRAME NUM ROWS/COLS: " + fr0.numRows() + "/"+ fr0.numCols()+ " vs RHS FRAME NUM ROWS/COLS: "+ fr1.numRows()+ "/"+ fr1.numCols());
fr=new Frame(fr0).add(fr1);
toss_fr=true;
}
 else {
fr=new Frame(fr0);
}
}
 else {
ncols=fr1.numCols();
fr=new Frame(fr1);
}
final ASTBinOp bin=this;
Frame fr2=new MRTask(){
@Override public void map(Chunk chks[],NewChunk nchks[]){
for (int i=0; i < nchks.length; i++) {
NewChunk n=nchks[i];
int rlen=chks[0].len();
Chunk c0=chks[i];
if ((!c0.vec().isEnum() && !(lf && rf && chks[i + nchks.length].vec().isEnum())) || bin instanceof ASTEQ || bin instanceof ASTNE) {
for (int r=0; r < rlen; r++) {
double lv;
double rv;
if (lf) {
if (chks[i].vec().isUUID() || (chks[i].isNA0(r) && !bin.opStr().equals("|"))) {
n.addNum(Double.NaN);
continue;
}
lv=chks[i].at0(r);
}
 else {
if (Double.isNaN(df0) && !bin.opStr().equals("|")) {
n.addNum(Double.NaN);
continue;
}
lv=df0;
}
if (rf) {
if (chks[i + (lf ? nchks.length : 0)].vec().isUUID() || chks[i].isNA0(r) && !bin.opStr().equals("|")) {
n.addNum(Double.NaN);
continue;
}
rv=chks[i + (lf ? nchks.length : 0)].at0(r);
}
 else {
if (Double.isNaN(df1) && !bin.opStr().equals("|")) {
n.addNum(Double.NaN);
continue;
}
rv=df1;
}
n.addNum(bin.op(lv,rv));
}
}
 else {
for (int r=0; r < rlen; r++) n.addNA();
}
}
}
}
.doAll(ncols,fr).outputFrame(Key.make(),(lf ? fr0 : fr1)._names,null);
env.push(new ASTFrame(fr2));
if (toss_fr) env.cleanup(fr0,fr1,fr);
 else env.cleanup(fr0,fr1);
}
