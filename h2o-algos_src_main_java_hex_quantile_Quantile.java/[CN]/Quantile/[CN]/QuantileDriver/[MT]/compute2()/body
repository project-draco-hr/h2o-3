{
  QuantileModel model=null;
  try {
    Scope.enter();
    _parms.lock_frames(Quantile.this);
    init(true);
    model=new QuantileModel(dest(),_parms,new QuantileModel.QuantileOutput(Quantile.this));
    model._output._quantiles=new double[train().numCols()][_parms._probs.length];
    model.delete_and_lock(_key);
    Vec vecs[]=train().vecs();
    for (int n=0; n < vecs.length; n++) {
      if (!isRunning())       return;
      Vec vec=vecs[n];
      Histo h1=new Histo(vec.min(),vec.max(),0,vec.length(),vec.isInt()).doAll(vec);
      for (int p=0; p < _parms._probs.length; p++) {
        double prob=_parms._probs[p];
        Histo h=h1;
        while (true) {
          double q=model._output._quantiles[n][p]=h.findQuantile(prob);
          if (!Double.isNaN(q))           break;
          h=h.refinePass(prob).doAll(vec);
        }
        model._output._iters++;
        model.update(_key);
        update(1);
      }
      StringBuilder sb=new StringBuilder();
      sb.append("Quantile: iter: ").append(model._output._iters).append(" Qs=").append(Arrays.toString(model._output._quantiles[n]));
      Log.info(sb);
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    cancel2(t);
    throw t;
  }
 finally {
    if (model != null)     model.unlock(_key);
    _parms.unlock_frames(Quantile.this);
    Scope.exit(model == null ? null : model._key);
    done();
  }
  tryComplete();
}
