{
  if (_model._output._ntrees == 0)   return;
  int model_mem_size=0;
  int trees_so_far=_model._output._ntrees;
  _model._output._treeStats._byte_size=0;
  for (int i=0; i < trees_so_far; ++i) {
    Key<CompressedTree>[] per_class=_model._output._treeKeys[i];
    for (int j=0; j < per_class.length; ++j) {
      if (per_class[j] == null)       continue;
      model_mem_size+=DKV.get(per_class[j]).memOrLoad().length;
      _model._output._treeStats._byte_size+=(long)model_mem_size;
    }
  }
  double avg_tree_mem_size=(double)model_mem_size / trees_so_far;
  Log.debug("Average tree size (for all classes): " + PrettyPrint.bytes((long)avg_tree_mem_size));
  long max_mem=H2O.CLOUD._memary[H2O.CLOUD.SELF.index()]._heartbeat.get_max_mem();
  if (_parms._ntrees * avg_tree_mem_size > max_mem) {
    String msg="The tree model will not fit in the driver node's memory (" + PrettyPrint.bytes((long)avg_tree_mem_size) + " per tree x "+ _parms._ntrees+ " > "+ PrettyPrint.bytes(max_mem)+ ") - try decreasing ntrees and/or max_depth or increasing min_rows!";
    error("_ntrees",msg);
    throw new IllegalArgumentException(msg);
  }
}
