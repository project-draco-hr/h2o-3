{
  super.init(expensive);
  if (H2O.ARGS.client && _parms._build_tree_one_node)   error("_build_tree_one_node","Cannot run on a single node in client mode");
  if (_vresponse != null)   _vresponse_key=_vresponse._key;
  if (_response != null)   _response_key=_response._key;
  if (_parms._min_rows < 0)   error("_min_rows","Requested min_rows must be greater than 0");
  if (_parms._ntrees < 0 || _parms._ntrees > 100000)   error("_ntrees","Requested ntrees must be between 1 and 100000");
  _ntrees=_parms._ntrees;
  if (_parms._checkpoint) {
    Value cv=DKV.get(_parms._model_id);
    if (cv != null) {
      M checkpointModel=cv.get();
      if (_parms._ntrees < checkpointModel._output._ntrees + 1)       error("_ntrees","Requested ntrees must be between " + checkpointModel._output._ntrees + 1+ " and 100000");
      _ntrees=_parms._ntrees - checkpointModel._output._ntrees;
    }
  }
  if (_parms._nbins <= 1)   error("_nbins","_nbins must be > 1.");
  if (_parms._nbins >= 1 << 16)   error("_nbins","_nbins must be < " + (1 << 16));
  if (_parms._nbins_cats <= 1)   error("_nbins_cats","_nbins_cats must be > 1.");
  if (_parms._nbins_cats >= 1 << 16)   error("_nbins_cats","_nbins_cats must be < " + (1 << 16));
  if (_parms._max_depth <= 0)   error("_max_depth","_max_depth must be > 0.");
  if (_parms._min_rows <= 0)   error("_min_rows","_min_rows must be > 0.");
  if (_train != null) {
    double sumWeights=_train.numRows() * (hasWeightCol() ? _train.vec(_parms._weights_column).mean() : 1);
    if (sumWeights < 2 * _parms._min_rows)     error("_min_rows","The dataset size is too small to split for min_rows=" + _parms._min_rows + ": must have at least "+ 2 * _parms._min_rows + " (weighted) rows, but have only " + sumWeights + ".");
  }
  if (_train != null)   _ncols=_train.numCols() - 1 - numSpecialCols();
}
