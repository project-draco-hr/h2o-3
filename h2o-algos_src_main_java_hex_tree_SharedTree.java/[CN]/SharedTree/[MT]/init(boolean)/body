{
  super.init(expensive);
  if (_nclass > SharedTreeModel.SharedTreeParameters.MAX_SUPPORTED_LEVELS)   error("_nclass","Too many levels in response column!");
  if (_parms._min_rows < 0)   error("_min_rows","Requested min_rows must be greater than 0");
  if (_parms._ntrees < 0 || _parms._ntrees > 100000)   error("_ntrees","Requested ntrees must be between 1 and 100000");
  _ntrees=_parms._ntrees;
  if (_parms._checkpoint) {
    Value cv=DKV.get(_parms._destination_key);
    if (cv != null) {
      M checkpointModel=cv.get();
      if (_parms._ntrees < checkpointModel._output._ntrees + 1)       error("_ntrees","Requested ntrees must be between " + checkpointModel._output._ntrees + 1+ " and 100000");
      _ntrees=_parms._ntrees - checkpointModel._output._ntrees;
    }
  }
  if (_parms._max_depth <= 0)   error("_max_depth","_max_depth must be > 0.");
  if (_parms._min_rows < 1)   error("_min_rows","_min_rows must be >= 1.");
  if (_train != null && _train.numRows() < _parms._min_rows * 2)   error("_min_rows","The dataset size is too small to split for min_rows=" + _parms._min_rows + " , number of rows: "+ _train.numRows()+ " < 2*"+ _parms._min_rows);
  if (_train != null)   _ncols=_train.numCols() - 1;
}
