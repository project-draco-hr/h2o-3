{
  Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
  ServerSocketChannel errsock=null;
  boolean saw_error=false;
  while (true) {
    try {
      if (errsock != null) {
        final ServerSocketChannel tmp2=errsock;
        errsock=null;
        tmp2.close();
      }
      if (saw_error)       Thread.sleep(100);
      saw_error=false;
      if (SOCK == null) {
        SOCK=ServerSocketChannel.open();
        SOCK.socket().setReceiveBufferSize(AutoBuffer.BBP_BIG._size);
        SOCK.socket().bind(H2O.SELF._key);
      }
      SocketChannel sock=SOCK.accept();
      ByteBuffer bb=ByteBuffer.allocate(4).order(ByteOrder.nativeOrder());
      bb.limit(bb.capacity());
      bb.position(0);
      while (bb.hasRemaining())       sock.read(bb);
      bb.flip();
      int chanType=bb.get();
      int port=bb.getChar();
      int sentinel=(0xFF) & bb.get();
      if (sentinel != 0xef)       throw H2O.fail("missing eom sentinel when opening new tcp channel");
      H2ONode h2o=H2ONode.intern(sock.socket().getInetAddress(),port);
      if (chanType == 1) {
        Log.info("starting new UDP-TCP receiver thread connected to " + sock.socket().getRemoteSocketAddress());
        new UDP_TCP_ReaderThread(h2o,sock).start();
      }
 else       if (chanType == 2)       new TCPReaderThread(sock,new AutoBuffer(sock)).start();
 else       throw H2O.fail("unexpected channel type " + chanType + ", only know 1 - Small and 2 - Big");
    }
 catch (    java.nio.channels.AsynchronousCloseException ex) {
      break;
    }
catch (    Exception e) {
      e.printStackTrace();
      Log.err("IO error on TCP port " + H2O.H2O_PORT + ": ",e);
      saw_error=true;
      errsock=SOCK;
      SOCK=null;
    }
  }
}
