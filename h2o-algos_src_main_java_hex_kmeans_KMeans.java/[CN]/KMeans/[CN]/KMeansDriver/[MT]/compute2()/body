{
  Frame fr=null;
  KMeansModel model=null;
  try {
    fr=_parms._training_frame;
    fr.read_lock(_key);
    if (fr.numRows() < _parms._K)     throw new IllegalArgumentException("Cannot make " + _parms._K + " clusters out of "+ fr.numRows()+ " rows.");
    Vec vecs[]=fr.vecs();
    final int N=vecs.length;
    int ncats=0, len=N;
    while (ncats != len) {
      while (ncats < len && vecs[ncats].isEnum())       ncats++;
      while (len > 0 && !vecs[len - 1].isEnum())       len--;
      if (ncats < len - 1)       fr.swap(ncats,len - 1);
    }
    _ncats=ncats;
    model=new KMeansModel(dest(),fr,_parms,new KMeansModel.KMeansOutput(),ncats);
    model.delete_and_lock(_key);
    double[] means=new double[N];
    for (int i=0; i < N; i++)     means[i]=vecs[i].mean();
    double[] mults=null;
    if (_parms._normalize) {
      mults=new double[N];
      for (int i=0; i < N; i++) {
        double sigma=vecs[i].sigma();
        mults[i]=normalize(sigma) ? 1.0 / sigma : 1.0;
      }
    }
    Random rand=water.util.RandomUtils.getRNG(_parms._seed - 1);
    double clusters[][];
    if (_parms._init == Initialization.None) {
      clusters=model._output._clusters=new double[_parms._K][fr.numCols()];
      for (      double[] cluster : clusters)       randomRow(vecs,rand,cluster,means,mults);
    }
 else {
      clusters=new double[1][vecs.length];
      randomRow(vecs,rand,clusters[0],means,mults);
      while (model._output._iters < 5) {
        SumSqr sqr=new SumSqr(clusters,means,mults,_ncats).doAll(vecs);
        Sampler sampler=new Sampler(clusters,means,mults,_ncats,sqr._sqr,_parms._K * 3,_parms._seed).doAll(vecs);
        clusters=ArrayUtils.append(clusters,sampler._sampled);
        if (!isRunning())         return;
        model._output._clusters=denormalize(clusters,ncats,means,mults);
        model._output._mse=sqr._sqr / fr.numRows();
        model._output._iters++;
        model.update(_key);
      }
      clusters=recluster(clusters,rand);
    }
    model._output._iters=0;
    LOOP:     for (; model._output._iters < _parms._max_iters; model._output._iters++) {
      if (!isRunning())       return;
      Lloyds task=new Lloyds(clusters,means,mults,_ncats,_parms._K).doAll(vecs);
      max_cats(task._cMeans,task._cats);
      boolean badrow=false;
      for (int clu=0; clu < _parms._K; clu++) {
        if (task._rows[clu] == 0) {
          if (badrow) {
            Log.warn("KMeans: Re-running Lloyds to re-init another cluster");
            model._output._iters--;
            if (reinit_attempts++ < _parms._K) {
              continue LOOP;
            }
 else {
              reinit_attempts=0;
              break;
            }
          }
          long row=task._worst_row;
          Log.warn("KMeans: Re-initializing cluster " + clu + " to row "+ row);
          data(clusters[clu]=task._cMeans[clu],vecs,row,means,mults);
          task._rows[clu]=1;
          badrow=true;
        }
      }
      model._output._clusters=denormalize(task._cMeans,ncats,means,mults);
      model._output._rows=task._rows;
      model._output._mses=task._cSqr;
      double ssq=0;
      for (int i=0; i < _parms._K; i++) {
        ssq+=model._output._mses[i];
        model._output._mses[i]/=task._rows[i];
      }
      model._output._mse=ssq / fr.numRows();
      model.update(_key);
      update(1);
      double sum=0;
      for (int clu=0; clu < _parms._K; clu++)       sum+=distance(clusters[clu],task._cMeans[clu],ncats);
      sum/=N;
      Log.info("KMeans: Change in cluster centers=" + sum);
      if (sum < 1e-6)       break;
      clusters=task._cMeans;
      StringBuilder sb=new StringBuilder();
      sb.append("KMeans: iter: ").append(model._output._iters).append(", MSE=").append(model._output._mse);
      for (int i=0; i < _parms._K; i++)       sb.append(", ").append(task._cSqr[i]).append("/").append(task._rows[i]);
      Log.info(sb);
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
    cancel2(t);
    throw t;
  }
 finally {
    if (model != null)     model.unlock(_key);
    if (fr != null)     fr.unlock(_key);
    done();
  }
  tryComplete();
}
