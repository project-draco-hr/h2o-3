{
  double[][] res=new double[_parms._k][];
  res[0]=points[0];
  int count=1;
  ClusterDist cd=new ClusterDist();
switch (_parms._init) {
case None:
    break;
case PlusPlus:
{
    while (count < res.length) {
      double sum=0;
      for (      double[] point1 : points)       sum+=minSqr(res,point1,_ncats,cd,count);
      for (      double[] point : points) {
        if (minSqr(res,point,_ncats,cd,count) >= rand.nextDouble() * sum) {
          res[count++]=point;
          break;
        }
      }
    }
    break;
  }
case Furthest:
{
  while (count < res.length) {
    double max=0;
    int index=0;
    for (int i=0; i < points.length; i++) {
      double sqr=minSqr(res,points[i],_ncats,cd,count);
      if (sqr > max) {
        max=sqr;
        index=i;
      }
    }
    res[count++]=points[index];
  }
  break;
}
default :
throw H2O.fail();
}
return res;
}
