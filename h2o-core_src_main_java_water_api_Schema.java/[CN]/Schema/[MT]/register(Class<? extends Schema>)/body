{
synchronized (clz) {
    Class<? extends Schema> existing=schemas.get(clz.getSimpleName());
    if (null != existing) {
      if (clz != existing)       throw H2O.fail("Two schema classes have the same simpleName; this is not supported: " + clz + " and "+ existing+ ".");
      return;
    }
    if (clz.getGenericSuperclass() instanceof ParameterizedType) {
      Type[] schema_type_parms=((ParameterizedType)(clz.getGenericSuperclass())).getActualTypeArguments();
      if (schema_type_parms.length < 2)       throw H2O.fail("Found a Schema that does not pass at least two type parameters.  Each Schema needs to be parameterized on the backing class (if any, or Iced if not) and itself: " + clz);
      Class parm0=ReflectionUtils.findActualClassParameter(clz,0);
      if (!Iced.class.isAssignableFrom(parm0))       throw H2O.fail("Found a Schema with bad type parameters.  First parameter is a subclass of Iced.  Each Schema needs to be parameterized on the backing class (if any, or Iced if not) and itself: " + clz + ".  Second parameter is of class: "+ parm0);
      if (Schema.class.isAssignableFrom(parm0))       throw H2O.fail("Found a Schema with bad type parameters.  First parameter is a subclass of Schema.  Each Schema needs to be parameterized on the backing class (if any, or Iced if not) and itself: " + clz + ".  Second parameter is of class: "+ parm0);
      Class parm1=ReflectionUtils.findActualClassParameter(clz,1);
      if (!Schema.class.isAssignableFrom(parm1))       throw H2O.fail("Found a Schema with bad type parameters.  Second parameter is not a subclass of Schema.  Each Schema needs to be parameterized on the backing class (if any, or Iced if not) and itself: " + clz + ".  Second parameter is of class: "+ parm1);
    }
 else {
      throw H2O.fail("Found a Schema that does not have a parameterized superclass.  Each Schema needs to be parameterized on the backing class (if any, or Iced if not) and itself: " + clz);
    }
    int version=extractVersionFromSchemaName(clz.getSimpleName());
    if (version > getHighestSupportedVersion() && version != EXPERIMENTAL_VERSION)     throw H2O.fail("Found a schema with a version higher than the highest supported version; you probably want to bump the highest supported version: " + clz);
    if (version > -1 && version != EXPERIMENTAL_VERSION) {
      if (version > HIGHEST_SUPPORTED_VERSION)       throw H2O.fail("Found a schema with a version greater than the highest supported version of: " + getHighestSupportedVersion() + ": "+ clz);
      if (version > LATEST_VERSION) {
synchronized (Schema.class) {
          if (version > LATEST_VERSION)           LATEST_VERSION=version;
        }
      }
    }
    Schema s=null;
    try {
      s=clz.newInstance();
    }
 catch (    Exception e) {
      Log.err("Failed to instantiate schema class: " + clz + " because: "+ e);
    }
    if (null != s) {
      Log.debug("Registered Schema: " + clz.getSimpleName());
      SchemaMetadata meta=new SchemaMetadata(s);
      for (      SchemaMetadata.FieldMetadata field_meta : meta.fields) {
        String name=field_meta.name;
        if ("__meta".equals(name) || "__http_status".equals(name) || "_exclude_fields".equals(name)|| "_include_fields".equals(name))         continue;
        if ("Gini".equals(name))         continue;
        if (name.endsWith("AUC"))         continue;
        if ("f0point5".equals(name) || "f0point5_for_criteria".equals(name) || "f1_for_criteria".equals(name)|| "f2_for_criteria".equals(name))         continue;
        if (name.startsWith("_"))         Log.warn("Found schema field which violates the naming convention; name starts with underscore: " + meta.name + "."+ name);
        if (!name.equals(name.toLowerCase()) && !name.equals(name.toUpperCase()))         Log.warn("Found schema field which violates the naming convention; name has mixed lowercase and uppercase characters: " + meta.name + "."+ name);
      }
    }
  }
}
