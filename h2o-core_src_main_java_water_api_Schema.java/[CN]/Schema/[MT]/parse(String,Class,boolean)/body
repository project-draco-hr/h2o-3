{
  if (fclz.equals(String.class))   return s;
  if (fclz.equals(int.class))   return Integer.valueOf(s);
  if (fclz.equals(long.class))   return Long.valueOf(s);
  if (fclz.equals(boolean.class))   return Boolean.valueOf(s);
  if (fclz.equals(byte.class))   return Byte.valueOf(s);
  if (fclz.equals(double.class))   return Double.valueOf(s);
  if (fclz.equals(float.class))   return Float.valueOf(s);
  if (fclz.isArray()) {
    if (s.equals("null") || s.length() == 0)     return null;
    read(s,0,'[',fclz);
    read(s,s.length() - 1,']',fclz);
    String inside=s.substring(1,s.length() - 1).trim();
    String[] splits;
    if (inside.length() == 0)     splits=new String[]{};
 else     splits=inside.split(",");
    Class<E> afclz=(Class<E>)fclz.getComponentType();
    E[] a=null;
    if (afclz == int.class) {
      a=(E[])Array.newInstance(Integer.class,splits.length);
    }
 else     if (afclz == double.class) {
      a=(E[])Array.newInstance(Double.class,splits.length);
    }
 else {
      a=(E[])Array.newInstance(afclz,splits.length);
    }
    for (int i=0; i < splits.length; i++) {
      if (String.class == afclz || KeySchema.class.isAssignableFrom(afclz)) {
        String stripped=splits[i].trim();
        if (stripped.length() >= 2)         stripped=stripped.substring(1,stripped.length() - 1);
        a[i]=(E)parse(stripped,afclz,required);
      }
 else {
        a[i]=(E)parse(splits[i].trim(),afclz,required);
      }
    }
    return a;
  }
  if (fclz.equals(Key.class))   if ((s == null || s.length() == 0) && required)   throw new IllegalArgumentException("Missing key");
 else   if (!required && (s == null || s.length() == 0))   return null;
 else   return Key.make(s);
  if (KeySchema.class.isAssignableFrom(fclz)) {
    if ((s == null || s.length() == 0) && required)     throw new IllegalArgumentException("Missing key");
    if (!required && (s == null || s.length() == 0))     return null;
    return KeySchema.make(fclz,Key.make(s));
  }
  if (Enum.class.isAssignableFrom(fclz))   return Enum.valueOf(fclz,s);
  if (FrameV2.class.isAssignableFrom(fclz))   if ((s == null || s.length() == 0) && required)   throw new IllegalArgumentException("Missing key");
 else   if (!required && (s == null || s.length() == 0))   return null;
 else {
    Value v=DKV.get(s);
    if (null == v)     return null;
    if (!v.isFrame())     throw new IllegalArgumentException("Frame argument points to a non-Frame object: " + v.get().getClass());
    return new FrameV2((Frame)v.get());
  }
  if (JobV2.class.isAssignableFrom(fclz))   if ((s == null || s.length() == 0) && required)   throw new IllegalArgumentException("Missing key");
 else   if (!required && (s == null || s.length() == 0))   return null;
 else {
    Value v=DKV.get(s);
    if (null == v)     return null;
    if (!v.isJob())     throw new IllegalArgumentException("Job argument points to a non-Job object: " + v.get().getClass());
    return new JobV2().fillFromImpl((Job)v.get());
  }
  if (FrameV2.ColSpecifierV2.class.isAssignableFrom(fclz)) {
    return new FrameV2.ColSpecifierV2(s);
  }
  if (ModelSchema.class.isAssignableFrom(fclz))   throw H2O.fail("Can't yet take ModelSchema as input.");
  throw new RuntimeException("Unimplemented schema fill from " + fclz.getSimpleName());
}
