{
  double step=_initialStep;
  _bound=false;
  _brackt=false;
  _stx=_sty=0;
  _stMin=_stMax=0;
  _betGradient=null;
  _bestPsiVal=Double.POSITIVE_INFINITY;
  _bestStep=0;
  double maxObj=ginfo._objVal - _minRelativeImprovement * ginfo._objVal;
  final double dgInit=ArrayUtils.innerProduct(ginfo._gradient,direction);
  final double dgtest=dgInit * _ftol;
  if (dgtest >= 0)   return false;
  if (_beta == null)   _beta=new double[betaStart.length];
  double width=maxStep - minStep;
  double oldWidth=2 * width;
  boolean stage1=true;
  _ginfox=ginfo;
  _fvx=_fvy=ginfo._objVal;
  _dgx=_dgy=dgInit;
  _iter=0;
  while (true) {
    if (_brackt) {
      _stMin=Math.min(_stx,_sty);
      _stMax=Math.max(_stx,_sty);
    }
 else {
      _stMin=_stx;
      _stMax=step + _xtrapf * (step - _stx);
    }
    step=Math.min(step,maxStep);
    step=Math.max(step,minStep);
    double maxFval=ginfo._objVal + step * dgtest;
    for (int i=0; i < _beta.length; ++i)     _beta[i]=betaStart[i] + step * direction[i];
    GradientInfo newGinfo=slvr.getGradient(_beta);
    if (newGinfo._objVal < maxObj && (_betGradient == null || (newGinfo._objVal - maxFval) < _bestPsiVal)) {
      _bestPsiVal=(newGinfo._objVal - maxFval);
      _betGradient=newGinfo;
      _bestStep=step;
    }
    ++_iter;
    if (_iter < maxfev && (!Double.isNaN(step) && (Double.isNaN(newGinfo._objVal) || Double.isInfinite(newGinfo._objVal) || ArrayUtils.hasNaNsOrInfs(newGinfo._gradient)))) {
      _brackt=true;
      _sty=step;
      maxStep=step;
      _fvy=Double.POSITIVE_INFINITY;
      _dgy=Double.MAX_VALUE;
      step*=.5;
      continue;
    }
    double dgp=ArrayUtils.innerProduct(newGinfo._gradient,direction);
    if (Double.isNaN(step) || _brackt && (step <= _stMin || step >= _stMax)) {
      _returnStatus=6;
      break;
    }
    if (step == maxStep && newGinfo._objVal <= maxFval & dgp <= dgtest) {
      _returnStatus=5;
      _stx=step;
      _ginfox=newGinfo;
      break;
    }
    if (step == minStep && (newGinfo._objVal > maxFval | dgp >= dgtest)) {
      _returnStatus=4;
      if (_betGradient != null) {
        _stx=_bestStep;
        _ginfox=_betGradient;
      }
 else {
        _stx=step;
        _ginfox=newGinfo;
      }
      break;
    }
    if (_iter >= maxfev) {
      _returnStatus=3;
      if (_betGradient != null) {
        _stx=_bestStep;
        _ginfox=_betGradient;
      }
 else {
        _stx=step;
        _ginfox=newGinfo;
      }
      break;
    }
    if (_brackt && (_stMax - _stMin) <= _xtol * _stMax) {
      _ginfox=newGinfo;
      _returnStatus=2;
      break;
    }
    if (newGinfo._objVal < maxFval && Math.abs(dgp) <= -_gtol * dgInit) {
      _stx=step;
      _dgx=dgp;
      _fvx=newGinfo._objVal;
      _ginfox=newGinfo;
      _returnStatus=1;
      break;
    }
    stage1=stage1 && (newGinfo._objVal > maxFval || dgp < dgtest);
    boolean useAugmentedFuntcion=stage1 && newGinfo._objVal <= _fvx && newGinfo._objVal > maxFval;
    double off=useAugmentedFuntcion ? dgtest : 0;
    double nextStep=nextStep(newGinfo,dgp,step,off);
    if (_brackt) {
      if (Math.abs(_sty - _stx) >= .66 * oldWidth)       nextStep=_stx + .5 * (_sty - _stx);
      oldWidth=width;
      width=Math.abs(_sty - _stx);
    }
    step=nextStep;
  }
  boolean succ=_ginfox._objVal < ginfo._objVal;
  return succ;
}
