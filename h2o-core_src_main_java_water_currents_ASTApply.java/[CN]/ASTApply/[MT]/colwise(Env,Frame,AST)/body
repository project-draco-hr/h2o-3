{
  Vec vecs[]=fr.vecs();
  Val vals[]=new Val[vecs.length];
  for (int i=0; i < vecs.length; i++) {
    Frame f1=new Frame(new String[]{fr._names[i]},new Vec[]{vecs[i]});
    vals[i]=new ASTExec(fun,new ASTFrame(f1)).exec(env);
  }
  Val v0=vals[0];
switch (v0.type()) {
case Val.NUM:
{
      double ds[]=new double[vecs.length];
      for (int i=0; i < vecs.length; i++)       ds[i]=vals[i].getNum();
      Key<Vec> key=Vec.VectorGroup.VG_LEN1.addVecs(1)[0];
      Vec vec=Vec.makeVec(ds,key);
      return new ValFrame(new Frame(new String[]{fun.str()},new Vec[]{vec}));
    }
case Val.FRM:
{
    Frame fr0=v0.getFrame();
    int ncols=fr0.numCols();
    double dss[][]=new double[ncols][vecs.length];
    for (int i=0; i < vecs.length; i++) {
      Frame res=vals[i].getFrame();
      if (res.numRows() != 1)       throw new IllegalArgumentException("apply result must be a scalar or a frame with 1 row; found " + res.numRows() + " rows");
      if (res.numCols() != ncols)       throw new IllegalArgumentException("apply result Frames must have all the same columns, found " + ncols + " cols and "+ res.numCols());
      for (int c=0; c < res.numCols(); c++)       dss[c][i]=res.vec(c).at(0);
      res.delete();
    }
    Key<Vec>[] keys=Vec.VectorGroup.VG_LEN1.addVecs(ncols);
    Frame res=new Frame();
    for (int c=0; c < ncols; c++)     res.add(Frame.defaultColName(c),Vec.makeVec(dss[c],keys[c]));
    return new ValFrame(res);
  }
case Val.FUN:
throw water.H2O.unimpl();
case Val.STR:
throw water.H2O.unimpl();
default :
throw water.H2O.unimpl();
}
}
