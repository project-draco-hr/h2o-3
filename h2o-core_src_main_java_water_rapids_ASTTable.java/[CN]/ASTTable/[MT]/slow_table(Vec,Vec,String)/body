{
  Vec vx=v2 == null ? v1 : v2;
  SlowCnt sc=new SlowCnt().doAll(vx,v1);
  double dcols[]=collectDomain(sc._col0s);
  if (v2 == null) {
    Frame res=new Frame();
    Vec rowlabel=Vec.makeVec(dcols,Vec.VectorGroup.VG_LEN1.addVec());
    rowlabel.setDomain(v1.domain());
    res.add(colname,rowlabel);
    long cnts[]=new long[dcols.length];
    for (int col=0; col < dcols.length; col++) {
      long lkey=Double.doubleToRawLongBits(dcols[col]);
      NonBlockingHashMapLong<AtomicLong> colx=sc._col0s.get(lkey);
      AtomicLong al=colx.get(lkey);
      cnts[col]=al.get();
    }
    Vec vec=Vec.makeVec(cnts,null,Vec.VectorGroup.VG_LEN1.addVec());
    res.add("Counts",vec);
    return new ValFrame(res);
  }
  NonBlockingHashMapLong<AtomicLong> rows=new NonBlockingHashMapLong<>();
  for (NonBlockingHashMapLong.IteratorLong i=iter(sc._col0s); i.hasNext(); )   rows.putAll(sc._col0s.get(i.nextLong()));
  double drows[]=collectDomain(rows);
  Frame res=new Frame();
  Vec rowlabel=Vec.makeVec(drows,Vec.VectorGroup.VG_LEN1.addVec());
  rowlabel.setDomain(v1.domain());
  res.add(colname,rowlabel);
  long cnts[]=new long[drows.length];
  for (int col=0; col < dcols.length; col++) {
    NonBlockingHashMapLong<AtomicLong> colx=sc._col0s.get(Double.doubleToRawLongBits(dcols[col]));
    for (int row=0; row < drows.length; row++) {
      AtomicLong al=colx.get(Double.doubleToRawLongBits(drows[row]));
      cnts[row]=al == null ? 0 : al.get();
    }
    Vec vec=Vec.makeVec(cnts,null,Vec.VectorGroup.VG_LEN1.addVec());
    res.add(vx.isCategorical() ? vx.domain()[col] : Double.toString(dcols[col]),vec);
  }
  return new ValFrame(res);
}
