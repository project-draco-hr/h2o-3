{
  assert(_state == JobState.RUNNING);
  final Frame origTrainFrame=train();
  final Integer N=nFoldWork();
  final Vec foldAssignment;
  final Vec foldCol=origTrainFrame.vec(_parms._fold_column);
  if (_parms._fold_column != null) {
    foldAssignment=makeFoldAssignment(foldCol);
  }
 else {
    final long seed=_parms.nFoldSeed();
    Log.info("Creating " + N + " cross-validation splits with random number seed: "+ seed);
switch (_parms._fold_assignment) {
case AUTO:
case Random:
      foldAssignment=ASTKFold.kfoldColumn(zTmp(),N,seed);
    break;
case Modulo:
  foldAssignment=ASTKFold.moduloKfoldColumn(zTmp(),N);
break;
case Stratified:
foldAssignment=ASTKFold.stratifiedKFoldColumn(response(),N,seed);
break;
default :
throw H2O.unimpl();
}
}
final Key[] modelKeys=new Key[N];
final Key[] predictionKeys=new Key[N];
final String origWeightsName=_parms._weights_column;
final Vec[] weights=new Vec[2 * N];
final Vec origWeight=origWeightsName != null ? origTrainFrame.vec(origWeightsName) : origTrainFrame.anyVec().makeCon(1.0);
final Frame[] cvTrain=new Frame[N];
final Frame[] cvValid=new Frame[N];
final String[] identifier=new String[N];
final String weightName="__internal_cv_weights__";
if (train().find(weightName) != -1) throw new H2OIllegalArgumentException("Frame cannot contain a Vec called '" + weightName + "'.");
final Key<M> origDest=dest();
for (int i=0; i < N; ++i) {
weights[2 * i]=zTmp();
weights[2 * i + 1]=zTmp();
final int whichFold=i;
new MRTask(){
@Override public void map(Chunk chks[]){
Chunk fold=chks[0];
Chunk orig=chks[1];
Chunk train=chks[2];
Chunk valid=chks[3];
for (int i=0; i < orig._len; ++i) {
int foldAssignment=(int)fold.at8(i) % N;
assert(foldAssignment >= 0 && foldAssignment < N);
boolean holdout=foldAssignment == whichFold;
double w=orig.atd(i);
train.set(i,holdout ? 0 : w);
valid.set(i,holdout ? w : 0);
}
}
}
.doAll(new Vec[]{foldAssignment,origWeight,weights[2 * i],weights[2 * i + 1]});
if (weights[2 * i].isConst() || weights[2 * i + 1].isConst()) {
String msg="Not enough data to create " + N + " random cross-validation splits. Either reduce nfolds, specify a larger dataset (or specify another random number seed, if applicable).";
throw new H2OIllegalArgumentException(msg);
}
identifier[i]=origDest.toString() + "_cv_" + (i + 1);
modelKeys[i]=Key.make(identifier[i]);
cvTrain[i]=new Frame(Key.make(identifier[i] + "_" + _parms._train.toString()+ "_train"),origTrainFrame.names(),origTrainFrame.vecs());
if (origWeightsName != null) cvTrain[i].remove(origWeightsName);
cvTrain[i].add(weightName,weights[2 * i]);
DKV.put(cvTrain[i]);
cvValid[i]=new Frame(Key.make(identifier[i] + "_" + _parms._train.toString()+ "_valid"),origTrainFrame.names(),origTrainFrame.vecs());
if (origWeightsName != null) cvValid[i].remove(origWeightsName);
cvValid[i].add(weightName,weights[2 * i + 1]);
DKV.put(cvValid[i]);
}
foldAssignment.remove();
if (origWeightsName == null) origWeight.remove();
ModelMetrics.MetricBuilder[] mb=new ModelMetrics.MetricBuilder[N];
_deleteProgressKey=false;
long cs=_parms.checksum();
final boolean async=false;
_cvModelBuilderKeys=new Key[N];
ModelBuilder<M,P,O>[] cvModelBuilders=new ModelBuilder[N];
for (int i=0; i < N; ++i) {
if (isCancelledOrCrashed()) break;
cvModelBuilders[i]=(ModelBuilder<M,P,O>)this.clone();
_cvModelBuilderKeys[i]=Key.make(_key.toString() + "_cv" + i);
cvModelBuilders[i]._key=_cvModelBuilderKeys[i];
cvModelBuilders[i]._cvModelBuilderKeys=null;
cvModelBuilders[i]._dest=modelKeys[i];
cvModelBuilders[i]._state=JobState.CREATED;
cvModelBuilders[i]._parms=(P)_parms.clone();
cvModelBuilders[i]._parms._weights_column=weightName;
cvModelBuilders[i]._parms._train=cvTrain[i]._key;
cvModelBuilders[i]._parms._valid=cvValid[i]._key;
cvModelBuilders[i]._parms._fold_assignment=Model.Parameters.FoldAssignmentScheme.AUTO;
cvModelBuilders[i].modifyParmsForCrossValidationSplits(i,N,_parms._model_id);
}
for (int i=0; i < N; ++i) {
cvModelBuilders[i].init(false);
if (cvModelBuilders[i].error_count() > 0) {
_messages=cvModelBuilders[i]._messages;
updateValidationMessages();
throw H2OModelBuilderIllegalArgumentException.makeFromBuilder(cvModelBuilders[i]);
}
}
for (int i=0; i < N; ++i) {
if (isCancelledOrCrashed()) break;
Log.info("Building cross-validation model " + (i + 1) + " / "+ N+ ".");
cvModelBuilders[i]._start_time=System.currentTimeMillis();
cvModelBuilders[i].trainModelImpl(-1,true);
if (!async) cvModelBuilders[i].block();
}
assert(cs == _parms.checksum());
if (!isCancelledOrCrashed()) {
Log.info("Building main model.");
assert(DKV.get(_key).get() == this);
assert(_state == JobState.RUNNING);
assert(((Job)DKV.getGet(_key))._state == JobState.RUNNING);
_state=JobState.CREATED;
assert(((Job)DKV.getGet(_key))._state == JobState.CREATED);
assert(!_deleteProgressKey);
_deleteProgressKey=true;
modifyParmsForCrossValidationMainModel(N,async ? null : _cvModelBuilderKeys);
trainModelImpl(-1,false);
if (!async) block();
}
 else {
DKV.remove(dest());
}
Model[] m=new Model[N];
for (int i=0; i < N; ++i) {
Frame adaptFr=null;
try {
adaptFr=new Frame(cvValid[i]);
if (!isCancelledOrCrashed()) {
cvModelBuilders[i].block();
cvModelBuilders[i].done(true);
cvModelBuilders[i].updateModelOutput();
m[i]=DKV.getGet(cvModelBuilders[i].dest());
m[i].adaptTestForTrain(adaptFr,true,!isSupervised());
mb[i]=m[i].scoreMetrics(adaptFr);
if (nclasses() == 2 || _parms._keep_cross_validation_predictions) {
String predName="prediction_" + modelKeys[i].toString();
predictionKeys[i]=Key.make(predName);
m[i].predictScoreImpl(cvValid[i],adaptFr,predName);
}
}
}
  finally {
if (adaptFr != null) {
Model.cleanup_adapt(adaptFr,cvValid[i]);
DKV.remove(adaptFr._key);
}
if (cvTrain[i] != null) DKV.remove(cvTrain[i]._key);
if (cvValid[i] != null) DKV.remove(cvValid[i]._key);
if (weights[2 * i] != null) weights[2 * i].remove();
if (weights[2 * i + 1] != null) weights[2 * i + 1].remove();
if (cvModelBuilders[i] != null) cvModelBuilders[i].remove();
}
}
if (!isCancelledOrCrashed()) {
block();
Model mainModel=DKV.getGet(dest());
assert(_state == JobState.RUNNING);
Log.info("Computing " + N + "-fold cross-validation metrics.");
mainModel._output._cross_validation_models=new Key[N];
mainModel._output._cross_validation_predictions=_parms._keep_cross_validation_predictions ? new Key[N] : null;
for (int i=0; i < N; ++i) {
if (i > 0) mb[0].reduce(mb[i]);
mainModel._output._cross_validation_models[i]=modelKeys[i];
if (_parms._keep_cross_validation_predictions) mainModel._output._cross_validation_predictions[i]=predictionKeys[i];
}
Frame preds=null;
if (nclasses() == 2) {
Vec[] p1s=new Vec[N];
for (int i=0; i < N; ++i) {
p1s[i]=((Frame)DKV.getGet(predictionKeys[i])).lastVec();
}
Frame p1combined=new HoldoutPredictionCombiner().doAll(1,Vec.T_NUM,new Frame(p1s)).outputFrame(new String[]{"p1"},null);
Vec p1=p1combined.anyVec();
preds=new Frame(new Vec[]{p1,p1,p1});
if (!_parms._keep_cross_validation_predictions) {
for (Key k : predictionKeys) ((Frame)DKV.getGet(k)).remove();
}
}
mainModel._output._cross_validation_metrics=mb[0].makeModelMetrics(mainModel,_parms.train(),null,preds);
if (preds != null) preds.remove();
mainModel._output._cross_validation_metrics._description=N + "-fold cross-validation on training data";
Log.info(mainModel._output._cross_validation_metrics.toString());
DKV.put(mainModel);
assert(!isDone());
done(true);
updateModelOutput();
}
return this;
}
