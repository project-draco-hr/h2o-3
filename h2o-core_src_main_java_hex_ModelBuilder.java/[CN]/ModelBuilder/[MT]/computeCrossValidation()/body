{
  assert(_state == JobState.RUNNING);
  final Frame origTrainFrame=train();
  Vec foldAssignment;
  final Integer N;
  if (_parms._fold_column != null) {
    foldAssignment=origTrainFrame.vec(_parms._fold_column);
    N=(int)foldAssignment.max() - (int)foldAssignment.min() + 1;
    assert(N > 1);
  }
 else {
    N=_parms._nfolds;
    long seed=new Random().nextLong();
    for (    Field f : _parms.getClass().getFields()) {
      if (f.getName().equals("_seed")) {
        try {
          seed=(long)(f.get(_parms));
        }
 catch (        IllegalAccessException e) {
          e.printStackTrace();
        }
      }
    }
    Log.info("Creating " + N + " cross-validation splits with random number seed: "+ seed);
    foldAssignment=origTrainFrame.anyVec().makeZero();
    final Model.Parameters.FoldAssignmentScheme foldAssignmentScheme=_parms._fold_assignment;
switch (foldAssignmentScheme) {
case AUTO:
case Random:
      foldAssignment=ASTKFold.kfoldColumn(foldAssignment,N,seed);
    break;
case Modulo:
  foldAssignment=ASTKFold.moduloKfoldColumn(foldAssignment,N);
break;
case Stratified:
foldAssignment=ASTKFold.stratifiedKFoldColumn(response(),N,seed);
break;
default :
throw H2O.unimpl();
}
}
final Key[] modelKeys=new Key[N];
final Key[] predictionKeys=new Key[N];
final String origWeightsName=_parms._weights_column;
final Vec[] weights=new Vec[2 * N];
final Vec origWeight=origWeightsName != null ? origTrainFrame.vec(origWeightsName) : origTrainFrame.anyVec().makeCon(1.0);
final Frame[] cvTrain=new Frame[N];
final Frame[] cvValid=new Frame[N];
final String[] identifier=new String[N];
final String weightName="weights";
final Key<M> origDest=dest();
for (int i=0; i < N; ++i) {
weights[2 * i]=origTrainFrame.anyVec().makeZero();
weights[2 * i + 1]=origTrainFrame.anyVec().makeZero();
final int whichFold=i;
new MRTask(){
@Override public void map(Chunk chks[]){
Chunk fold=chks[0];
Chunk orig=chks[1];
Chunk train=chks[2];
Chunk valid=chks[3];
for (int i=0; i < orig._len; ++i) {
int foldAssignment=(int)fold.at8(i) % N;
assert(foldAssignment >= 0 && foldAssignment < N);
boolean holdout=foldAssignment == whichFold;
double w=orig.atd(i);
train.set(i,holdout ? 0 : w);
valid.set(i,holdout ? w : 0);
}
}
}
.doAll(new Vec[]{foldAssignment,origWeight,weights[2 * i],weights[2 * i + 1]});
if (weights[2 * i].isConst() || weights[2 * i + 1].isConst()) {
String msg="Not enough data to create " + N + " random cross-validation splits. Either reduce nfolds, specify a larger dataset (or specify another random number seed, if applicable).";
throw new H2OIllegalArgumentException(msg);
}
identifier[i]=origDest.toString() + "_cv_" + (i + 1);
modelKeys[i]=Key.make(identifier[i]);
cvTrain[i]=new Frame(Key.make(identifier[i] + "_" + _parms._train.toString()+ "_train"),origTrainFrame.names(),origTrainFrame.vecs());
cvTrain[i].add(weightName,weights[2 * i]);
DKV.put(cvTrain[i]);
cvValid[i]=new Frame(Key.make(identifier[i] + "_" + _parms._train.toString()+ "_valid"),origTrainFrame.names(),origTrainFrame.vecs());
cvValid[i].add(weightName,weights[2 * i + 1]);
DKV.put(cvValid[i]);
}
if (_parms._fold_column == null) foldAssignment.remove();
if (origWeightsName == null) origWeight.remove();
ModelMetrics.MetricBuilder[] mb=new ModelMetrics.MetricBuilder[N];
_deleteProgressKey=false;
long cs=_parms.checksum();
final boolean async=false;
cvModelBuilderKeys=new Key[N];
ModelBuilder<M,P,O>[] cvModelBuilders=new ModelBuilder[N];
for (int i=0; i < N; ++i) {
if (isCancelledOrCrashed()) break;
Log.info("Building cross-validation model " + (i + 1) + " / "+ N+ ".");
cvModelBuilders[i]=(ModelBuilder<M,P,O>)this.clone();
cvModelBuilderKeys[i]=Key.make(_key.toString() + "_cv" + i);
cvModelBuilders[i]._key=cvModelBuilderKeys[i];
cvModelBuilders[i].cvModelBuilderKeys=null;
cvModelBuilders[i]._dest=modelKeys[i];
cvModelBuilders[i]._state=JobState.CREATED;
cvModelBuilders[i]._parms=(P)_parms.clone();
cvModelBuilders[i]._parms._weights_column=weightName;
cvModelBuilders[i]._parms._train=cvTrain[i]._key;
cvModelBuilders[i]._parms._valid=cvValid[i]._key;
cvModelBuilders[i]._parms._fold_assignment=Model.Parameters.FoldAssignmentScheme.AUTO;
cvModelBuilders[i].modifyParmsForCrossValidationSplits(i,N,_parms._model_id);
cvModelBuilders[i]._start_time=System.currentTimeMillis();
cvModelBuilders[i].trainModelImpl(-1,true);
if (!async) cvModelBuilders[i].block();
}
assert(cs == _parms.checksum());
if (!isCancelledOrCrashed()) {
Log.info("Building main model.");
assert(DKV.get(_key).get() == this);
assert(_state == JobState.RUNNING);
assert(((Job)DKV.getGet(_key))._state == JobState.RUNNING);
_state=JobState.CREATED;
assert(((Job)DKV.getGet(_key))._state == JobState.CREATED);
assert(!_deleteProgressKey);
_deleteProgressKey=true;
modifyParmsForCrossValidationMainModel(N);
trainModelImpl(-1,false);
if (!async) block();
}
 else {
DKV.remove(dest());
}
Model[] m=new Model[N];
for (int i=0; i < N; ++i) {
Frame adaptFr=null;
try {
adaptFr=new Frame(cvValid[i]);
if (!isCancelledOrCrashed()) {
cvModelBuilders[i].block();
cvModelBuilders[i].done(true);
cvModelBuilders[i].updateModelOutput();
m[i]=DKV.getGet(cvModelBuilders[i].dest());
m[i].adaptTestForTrain(adaptFr,true,!isSupervised());
mb[i]=m[i].scoreMetrics(adaptFr);
if (_parms._keep_cross_validation_predictions) {
String predName="prediction_" + modelKeys[i].toString();
predictionKeys[i]=Key.make(predName);
m[i].predictScoreImpl(cvValid[i],adaptFr,predName);
}
}
}
  finally {
if (adaptFr != null) {
Model.cleanup_adapt(adaptFr,cvValid[i]);
DKV.remove(adaptFr._key);
}
if (cvTrain[i] != null) DKV.remove(cvTrain[i]._key);
if (cvValid[i] != null) DKV.remove(cvValid[i]._key);
if (weights[2 * i] != null) weights[2 * i].remove();
if (weights[2 * i + 1] != null) weights[2 * i + 1].remove();
if (cvModelBuilders[i] != null) cvModelBuilders[i].remove();
}
}
if (!isCancelledOrCrashed()) {
block();
Model mainModel=DKV.getGet(dest());
assert(_state == JobState.RUNNING);
Log.info("Computing " + N + "-fold cross-validation metrics.");
mainModel._output._cross_validation_models=new Key[N];
mainModel._output._cross_validation_predictions=_parms._keep_cross_validation_predictions ? new Key[N] : null;
for (int i=0; i < N; ++i) {
if (i > 0) mb[0].reduce(mb[i]);
mainModel._output._cross_validation_models[i]=modelKeys[i];
if (_parms._keep_cross_validation_predictions) mainModel._output._cross_validation_predictions[i]=predictionKeys[i];
}
mainModel._output._cross_validation_metrics=mb[0].makeModelMetrics(mainModel,_parms.train());
mainModel._output._cross_validation_metrics._description=N + "-fold cross-validation on training data";
Log.info(mainModel._output._cross_validation_metrics.toString());
DKV.put(mainModel);
assert(!isDone());
done(true);
updateModelOutput();
}
return this;
}
