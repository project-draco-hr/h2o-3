{
  System.out.println("\nCreating left index ...");
  long t0=System.nanoTime();
  RadixOrder leftIndex=new RadixOrder(leftFrame,leftCols);
  System.out.println("Creating left index took: " + (System.nanoTime() - t0) / 1e9);
  System.out.println("\nCreating right index ...");
  t0=System.nanoTime();
  RadixOrder rightIndex=new RadixOrder(rightFrame,rightCols);
  System.out.println("Creating right index took: " + (System.nanoTime() - t0) / 1e9 + "\n");
  int bitShift=Math.max(8,rightIndex._biggestBit[0]) - Math.max(8,leftIndex._biggestBit[0]);
  int leftExtent=256, rightExtent=1;
  if (bitShift < 0) {
    leftExtent>>=-bitShift;
    rightExtent<<=-bitShift;
  }
  System.out.println("Sending BinaryMerge async RPC calls ...");
  t0=System.nanoTime();
  List<RPC> bmList=new ArrayList<>();
  for (int leftMSB=0; leftMSB < leftExtent; leftMSB++) {
    int rightMSBBase=leftMSB >> bitShift;
    for (int k=0; k < rightExtent; k++) {
      int rightMSB=rightMSBBase + k;
      H2ONode rightNode=MoveByFirstByte.ownerOfMSB(rightMSB);
      RPC bm=new RPC<>(rightNode,new BinaryMerge(leftFrame,rightFrame,leftMSB,rightMSB,leftIndex._bytesUsed,rightIndex._bytesUsed,allLeft));
      bmList.add(bm);
      bm.call();
    }
  }
  System.out.println("Sending BinaryMerge async RPC calls took: " + (System.nanoTime() - t0) / 1e9);
  System.out.println("Summing BinaryMerge._numChunks (and waiting for RPCs to finish)... ");
  t0=System.nanoTime();
  long ansN=0;
  int numChunks=0;
  BinaryMerge bmResults[]=new BinaryMerge[bmList.size()];
  int i=0;
  for (  RPC rpc : bmList) {
    System.out.print(String.format("%4d: ",i));
    BinaryMerge thisbm;
    bmResults[i++]=thisbm=(BinaryMerge)rpc.get();
    for (int t=0; t < 12; t++)     System.out.print(String.format("%2.2f ",thisbm._timings[t]));
    System.out.println();
    if (thisbm._numRowsInResult == 0)     continue;
    numChunks+=thisbm._chunkSizes.length;
    ansN+=thisbm._numRowsInResult;
  }
  System.out.println("\ntook: " + (System.nanoTime() - t0) / 1e9);
  assert(i == bmList.size());
  System.out.print("Allocating and populating chunk info (e.g. size and batch number) ...");
  t0=System.nanoTime();
  long chunkSizes[]=new long[numChunks];
  int chunkLeftMSB[]=new int[numChunks];
  int chunkRightMSB[]=new int[numChunks];
  int chunkBatch[]=new int[numChunks];
  int k=0;
  for (i=0; i < bmList.size(); i++) {
    BinaryMerge thisbm=bmResults[i];
    if (thisbm._numRowsInResult == 0)     continue;
    int thisChunkSizes[]=thisbm._chunkSizes;
    for (int j=0; j < thisChunkSizes.length; j++) {
      chunkSizes[k]=thisChunkSizes[j];
      chunkLeftMSB[k]=thisbm._leftMSB;
      chunkRightMSB[k]=thisbm._rightMSB;
      chunkBatch[k]=j;
      k++;
    }
  }
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  System.out.print("Allocating and populated espc ...");
  t0=System.nanoTime();
  long espc[]=new long[chunkSizes.length + 1];
  i=0;
  long sum=0;
  for (  long s : chunkSizes) {
    espc[i++]=sum;
    sum+=s;
  }
  espc[espc.length - 1]=sum;
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  assert(sum == ansN);
  System.out.print("Allocating dummy vecs/chunks of the final frame ...");
  t0=System.nanoTime();
  int numJoinCols=leftIndex._bytesUsed.length;
  int numLeftCols=leftFrame.numCols();
  int numColsInResult=numLeftCols + rightFrame.numCols() - numJoinCols;
  final byte[] types=new byte[numColsInResult];
  final String[][] doms=new String[numColsInResult][];
  final String[] names=new String[numColsInResult];
  for (int j=0; j < numLeftCols; j++) {
    types[j]=leftFrame.vec(j).get_type();
    doms[j]=leftFrame.domains()[j];
    names[j]=leftFrame.names()[j];
  }
  for (int j=0; j < rightFrame.numCols() - numJoinCols; j++) {
    types[numLeftCols + j]=rightFrame.vec(j + numJoinCols).get_type();
    doms[numLeftCols + j]=rightFrame.domains()[j + numJoinCols];
    names[numLeftCols + j]=rightFrame.names()[j + numJoinCols];
  }
  Key key=Vec.newKey();
  Vec[] vecs=new Vec(key,Vec.ESPC.rowLayout(key,espc)).makeCons(numColsInResult,0,doms,types);
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  System.out.print("Finally stitch together by overwriting dummies ...");
  t0=System.nanoTime();
  Frame fr=new Frame(Key.make(rightFrame._key.toString() + "_joined_with_" + leftFrame._key.toString()),names,vecs);
  ChunkStitcher ff=new ChunkStitcher(leftFrame,rightFrame,chunkSizes,chunkLeftMSB,chunkRightMSB,chunkBatch);
  ff.doAll(fr);
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  Merge.cleanUp();
  return fr;
}
