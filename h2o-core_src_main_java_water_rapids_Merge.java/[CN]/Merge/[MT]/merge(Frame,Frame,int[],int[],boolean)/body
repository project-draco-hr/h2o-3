{
  RadixOrder leftIndex=new RadixOrder(leftFrame,leftCols);
  RadixOrder rightIndex=new RadixOrder(rightFrame,rightCols);
  int bitShift=Math.max(8,rightIndex._biggestBit[0]) - Math.max(8,leftIndex._biggestBit[0]);
  int leftExtent=256, rightExtent=1;
  if (bitShift < 0) {
    leftExtent>>=-bitShift;
    rightExtent<<=-bitShift;
  }
  List<RPC> bmList=new ArrayList<>();
  for (int leftMSB=0; leftMSB < leftExtent; leftMSB++) {
    int rightMSBBase=leftMSB >> bitShift;
    for (int k=0; k < rightExtent; k++) {
      int rightMSB=rightMSBBase + k;
      H2ONode leftNode=MoveByFirstByte.ownerOfMSB(leftMSB);
      H2ONode rightNode=MoveByFirstByte.ownerOfMSB(rightMSB);
      RPC bm=new RPC<>(rightNode,new BinaryMerge(leftFrame,rightFrame,leftMSB,rightMSB,leftIndex._bytesUsed,rightIndex._bytesUsed,allLeft));
      bmList.add(bm);
      bm.call();
    }
  }
  long ansN=0;
  int numChunks=0;
  BinaryMerge bmResults[]=new BinaryMerge[bmList.size()];
  int i=0;
  for (  RPC rpc : bmList) {
    BinaryMerge thisbm;
    bmResults[i++]=thisbm=(BinaryMerge)rpc.get();
    if (thisbm._numRowsInResult == 0)     continue;
    numChunks+=thisbm._chunkSizes.length;
    ansN+=thisbm._numRowsInResult;
  }
  assert(i == bmList.size());
  long chunkSizes[]=new long[numChunks];
  int chunkLeftMSB[]=new int[numChunks];
  int chunkRightMSB[]=new int[numChunks];
  int chunkBatch[]=new int[numChunks];
  int k=0;
  for (i=0; i < bmList.size(); i++) {
    BinaryMerge thisbm=bmResults[i];
    if (thisbm._numRowsInResult == 0)     continue;
    int thisChunkSizes[]=thisbm._chunkSizes;
    for (int j=0; j < thisChunkSizes.length; j++) {
      chunkSizes[k]=thisChunkSizes[j];
      chunkLeftMSB[k]=thisbm._leftMSB;
      chunkRightMSB[k]=thisbm._rightMSB;
      chunkBatch[k]=j;
      k++;
    }
  }
  long espc[]=new long[chunkSizes.length + 1];
  i=0;
  long sum=0;
  for (  long s : chunkSizes) {
    espc[i++]=sum;
    sum+=s;
  }
  espc[espc.length - 1]=sum;
  assert(sum == ansN);
  int numJoinCols=leftIndex._bytesUsed.length;
  int numLeftCols=leftFrame.numCols();
  int numColsInResult=numLeftCols + rightFrame.numCols() - numJoinCols;
  final byte[] types=new byte[numColsInResult];
  final String[][] doms=new String[numColsInResult][];
  final String[] names=new String[numColsInResult];
  for (int j=0; j < numLeftCols; j++) {
    types[j]=leftFrame.vec(j).get_type();
    doms[j]=leftFrame.domains()[j];
    names[j]=leftFrame.names()[j];
  }
  for (int j=0; j < rightFrame.numCols() - numJoinCols; j++) {
    types[numLeftCols + j]=rightFrame.vec(j + numJoinCols).get_type();
    doms[numLeftCols + j]=rightFrame.domains()[j + numJoinCols];
    names[numLeftCols + j]=rightFrame.names()[j + numJoinCols];
  }
  Key key=Vec.newKey();
  Vec[] vecs=new Vec(key,Vec.ESPC.rowLayout(key,espc)).makeCons(numColsInResult,0,doms,types);
  Frame fr=new Frame(Key.make(rightFrame._key.toString() + "_joined_with_" + leftFrame._key.toString()),names,vecs);
  ChunkStitcher ff=new ChunkStitcher(leftFrame,rightFrame,chunkSizes,chunkLeftMSB,chunkRightMSB,chunkBatch);
  ff.doAll(fr);
  return fr;
}
