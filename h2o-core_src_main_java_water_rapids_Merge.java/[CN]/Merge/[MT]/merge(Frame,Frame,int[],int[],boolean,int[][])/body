{
  System.out.println("\nCreating left index ...");
  long t0=System.nanoTime();
  RadixOrder leftIndex;
  H2O.H2OCountedCompleter left=H2O.submitTask(leftIndex=new RadixOrder(leftFrame,true,leftCols,null));
  left.join();
  System.out.println("***\n*** Creating left index took: " + (System.nanoTime() - t0) / 1e9 + "\n***\n");
  System.out.println("\nCreating right index ...");
  t0=System.nanoTime();
  RadixOrder rightIndex;
  H2O.H2OCountedCompleter right=H2O.submitTask(rightIndex=new RadixOrder(rightFrame,false,rightCols,id_maps));
  right.join();
  System.out.println("***\n*** Creating right index took: " + (System.nanoTime() - t0) / 1e9 + "\n***\n");
  int bitShift=Math.max(8,rightIndex._biggestBit[0]) - Math.max(8,leftIndex._biggestBit[0]);
  int leftExtent=256, rightExtent=1;
  if (bitShift < 0) {
    leftExtent>>=-bitShift;
    rightExtent<<=-bitShift;
  }
  long ansN=0;
  int numChunks=0;
  System.out.print("Making BinaryMerge RPC calls ... ");
  t0=System.nanoTime();
  List<RPC> bmList=new ArrayList<>();
  for (int leftMSB=0; leftMSB < leftExtent; leftMSB++) {
    int rightMSBBase=leftMSB >> bitShift;
    for (int k=0; k < rightExtent; k++) {
      int rightMSB=rightMSBBase + k;
      H2ONode rightNode=SplitByMSBLocal.ownerOfMSB(rightMSB);
      RPC bm=new RPC<>(rightNode,new BinaryMerge(leftFrame,rightFrame,leftMSB,rightMSB,leftIndex._bytesUsed,rightIndex._bytesUsed,allLeft));
      bmList.add(bm);
      System.out.print(rightNode.index() + " ");
    }
  }
  System.out.println("... took: " + (System.nanoTime() - t0) / 1e9);
  int queueSize=Math.max(H2O.CLOUD.size() * 20,40);
  t0=System.nanoTime();
  System.out.print("Sending BinaryMerge async RPC calls in a queue of " + queueSize + " ... ");
  int queue[]=new int[queueSize];
  BinaryMerge bmResults[]=new BinaryMerge[bmList.size()];
  int nextItem;
  for (nextItem=0; nextItem < queueSize; nextItem++) {
    queue[nextItem]=nextItem;
    bmList.get(nextItem).call();
  }
  int leftOnQueue=queueSize;
  int waitMS=50;
  while (leftOnQueue > 0) {
    try {
      Thread.sleep(waitMS);
    }
 catch (    InterruptedException ex) {
      Thread.currentThread().interrupt();
    }
    int doneInSweep=0;
    for (int q=0; q < queueSize; q++) {
      int thisBM=queue[q];
      if (thisBM >= 0 && bmList.get(thisBM).isDone()) {
        BinaryMerge thisbm;
        bmResults[thisBM]=thisbm=(BinaryMerge)bmList.get(thisBM).get();
        leftOnQueue--;
        doneInSweep++;
        if (thisbm._numRowsInResult > 0) {
          System.out.print(String.format("%3d",queue[q]) + ":");
          for (int t=0; t < 20; t++)           System.out.print(String.format("%.2f ",thisbm._timings[t]));
          System.out.println();
          numChunks+=thisbm._chunkSizes.length;
          ansN+=thisbm._numRowsInResult;
        }
        queue[q]=-1;
        if (nextItem < bmList.size()) {
          bmList.get(nextItem).call();
          queue[q]=nextItem++;
          leftOnQueue++;
        }
      }
    }
    if (doneInSweep == 0)     waitMS=Math.min(1000,waitMS * 2);
  }
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  System.out.print("Removing DKV keys of left and right index.  ... ");
  t0=System.nanoTime();
  for (int msb=0; msb < 256; msb++) {
    for (int isLeft=0; isLeft < 2; isLeft++) {
      Key k=getSortedOXHeaderKey(isLeft == 0 ? false : true,msb);
      SingleThreadRadixOrder.OXHeader oxheader=DKV.getGet(k);
      DKV.remove(k);
      if (oxheader != null) {
        for (int b=0; b < oxheader._nBatch; ++b) {
          k=SplitByMSBLocal.getSortedOXbatchKey(isLeft == 0 ? false : true,msb,b);
          DKV.remove(k);
        }
      }
    }
  }
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  System.out.print("Allocating and populating chunk info (e.g. size and batch number) ...");
  t0=System.nanoTime();
  long chunkSizes[]=new long[numChunks];
  int chunkLeftMSB[]=new int[numChunks];
  int chunkRightMSB[]=new int[numChunks];
  int chunkBatch[]=new int[numChunks];
  int k=0;
  for (int i=0; i < bmList.size(); i++) {
    BinaryMerge thisbm=bmResults[i];
    if (thisbm._numRowsInResult == 0)     continue;
    int thisChunkSizes[]=thisbm._chunkSizes;
    for (int j=0; j < thisChunkSizes.length; j++) {
      chunkSizes[k]=thisChunkSizes[j];
      chunkLeftMSB[k]=thisbm._leftMSB;
      chunkRightMSB[k]=thisbm._rightMSB;
      chunkBatch[k]=j;
      k++;
    }
  }
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  System.out.print("Allocating and populated espc ...");
  t0=System.nanoTime();
  long espc[]=new long[chunkSizes.length + 1];
  int i=0;
  long sum=0;
  for (  long s : chunkSizes) {
    espc[i++]=sum;
    sum+=s;
  }
  espc[espc.length - 1]=sum;
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  assert(sum == ansN);
  System.out.print("Allocating dummy vecs/chunks of the final frame ...");
  t0=System.nanoTime();
  int numJoinCols=leftIndex._bytesUsed.length;
  int numLeftCols=leftFrame.numCols();
  int numColsInResult=numLeftCols + rightFrame.numCols() - numJoinCols;
  final byte[] types=new byte[numColsInResult];
  final String[][] doms=new String[numColsInResult][];
  final String[] names=new String[numColsInResult];
  for (int j=0; j < numLeftCols; j++) {
    types[j]=leftFrame.vec(j).get_type();
    doms[j]=leftFrame.domains()[j];
    names[j]=leftFrame.names()[j];
  }
  for (int j=0; j < rightFrame.numCols() - numJoinCols; j++) {
    types[numLeftCols + j]=rightFrame.vec(j + numJoinCols).get_type();
    doms[numLeftCols + j]=rightFrame.domains()[j + numJoinCols];
    names[numLeftCols + j]=rightFrame.names()[j + numJoinCols];
  }
  Key key=Vec.newKey();
  Vec[] vecs=new Vec(key,Vec.ESPC.rowLayout(key,espc)).makeCons(numColsInResult,0,doms,types);
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  System.out.print("Finally stitch together by overwriting dummies ...");
  t0=System.nanoTime();
  Frame fr=new Frame(names,vecs);
  ChunkStitcher ff=new ChunkStitcher(chunkSizes,chunkLeftMSB,chunkRightMSB,chunkBatch);
  ff.doAll(fr);
  System.out.println("took: " + (System.nanoTime() - t0) / 1e9);
  return fr;
}
