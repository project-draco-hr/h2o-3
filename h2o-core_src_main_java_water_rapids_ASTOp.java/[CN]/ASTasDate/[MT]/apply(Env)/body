{
  final String format=_format;
  if (format.isEmpty())   throw new IllegalArgumentException("as.Date requires a non-empty format string");
  Frame fr=env.popAry();
  if (fr.vecs().length != 1 || !(fr.vecs()[0].isEnum() || fr.vecs()[0].isString()))   throw new IllegalArgumentException("as.Date requires a single column of factors or strings");
  Frame fr2=new MRTask(){
    @Override public void map(    Chunk chks[],    NewChunk nchks[]){
      final boolean isStr=chks[0] instanceof CStrChunk;
      String date=null;
      DateTimeFormatter dtf=ParseTime.forStrptimePattern(format).withZone(ParseTime.getTimezone());
      for (int i=0; i < nchks.length; i++) {
        NewChunk n=nchks[i];
        Chunk c=chks[i];
        int rlen=c._len;
        for (int r=0; r < rlen; r++) {
          if (!c.isNA(r)) {
            if (isStr)             date=c.atStr(new ValueString(),r).toString();
 else             date=c.vec().domain()[(int)c.atd(r)];
            n.addNum(DateTime.parse(date,dtf).getMillis(),0);
          }
 else           n.addNA();
        }
      }
    }
  }
.doAll(fr.numCols(),fr).outputFrame(fr._names,null);
  env.pushAry(fr2);
}
