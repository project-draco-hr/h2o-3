{
  Frame two=env.peekType() == Env.NULL ? null : env.popAry();
  if (two == null)   env.pop();
  Frame one=env.popAry();
  if (two != null)   if (two.numCols() != 1 || one.numCols() != 1)   throw new IllegalArgumentException("`table` supports at *most* two vectors");
 else   if (one.numCols() < 1 || one.numCols() > 2)   throw new IllegalArgumentException("`table` supports at *most* two vectors and at least one vector.");
  Frame fr;
  if (two != null)   fr=new Frame(one.add(two));
 else   fr=one;
  final int ncol;
  if ((ncol=fr.vecs().length) > 2)   throw new IllegalArgumentException("table does not apply to more than two cols.");
  for (int i=0; i < ncol; i++)   if (!fr.vecs()[i].isInt())   throw new IllegalArgumentException("table only applies to integer vectors.");
  Vec dataLayoutVec;
  Frame fr2;
  String colnames[];
  String[][] d=new String[ncol + 1][];
  if (ncol == 1) {
    final int min=(int)fr.anyVec().min();
    final int max=(int)fr.anyVec().max();
    colnames=new String[]{fr.name(0),"Count"};
    d[0]=fr.anyVec().domain();
    d[1]=null;
    if (min >= 0) {
      UniqueColumnCountTask t=new UniqueColumnCountTask(max,false,false,0).doAll(fr.anyVec());
      final long[] cts=t._cts;
      dataLayoutVec=Vec.makeCon(0,cts.length);
      fr2=new MRTask(){
        @Override public void map(        Chunk[] c,        NewChunk[] cs){
          for (int i=0; i < c[0]._len; ++i) {
            int idx=(int)(i + c[0].start());
            if (cts[idx] == 0)             continue;
            cs[0].addNum(idx);
            cs[1].addNum(cts[idx]);
          }
        }
      }
.doAll(2,dataLayoutVec).outputFrame(colnames,d);
    }
 else     if (min <= 0 && max <= 0) {
      UniqueColumnCountTask t=new UniqueColumnCountTask(-1 * min,true,false,0).doAll(fr.anyVec());
      final long[] cts=t._cts;
      dataLayoutVec=Vec.makeCon(0,cts.length);
      fr2=new MRTask(){
        @Override public void map(        Chunk[] c,        NewChunk[] cs){
          for (int i=0; i < c[0]._len; ++i) {
            int idx=(int)(i + c[0].start());
            if (cts[idx] == 0)             continue;
            cs[0].addNum(idx * -1);
            cs[1].addNum(cts[idx]);
          }
        }
      }
.doAll(2,dataLayoutVec).outputFrame(colnames,d);
    }
 else {
      UniqueColumnCountTask t=new UniqueColumnCountTask(max + -1 * min,false,true,max).doAll(fr.anyVec());
      final long[] cts=t._cts;
      dataLayoutVec=Vec.makeCon(0,cts.length);
      fr2=new MRTask(){
        @Override public void map(        Chunk[] c,        NewChunk[] cs){
          for (int i=0; i < c[0]._len; ++i) {
            int idx=(int)(i + c[0].start());
            if (cts[idx] == 0)             continue;
            cs[0].addNum(idx > max ? (idx - max) * -1 : idx);
            cs[1].addNum(cts[idx]);
          }
        }
      }
.doAll(2,dataLayoutVec).outputFrame(colnames,d);
    }
  }
 else {
    colnames=new String[]{fr.name(0),fr.name(1),"count"};
    long s=System.currentTimeMillis();
    UniqueTwoColumnTask t=new UniqueTwoColumnTask().doAll(fr);
    Log.info("Finished raw tabling in: " + (System.currentTimeMillis() - s) / 1000. + " (s)");
    final NonBlockingHashMap m=t._cnts;
    dataLayoutVec=Vec.makeCon(0,m.size());
    d[0]=fr.vec(0).domain();
    if (ncol == 2) {
      d[1]=fr.vec(1).domain();
    }
    fr2=new MRTask(){
      @Override public void map(      Chunk[] c,      NewChunk[] cs){
        Iterator it=m.keySet().iterator();
        for (int j=0; j < c[0].start(); ++j)         it.next();
        for (int i=0; i < c[0]._len; ++i) {
          GroupPair g=(GroupPair)it.next();
          cs[0].addNum(g._ls[0]);
          if (ncol == 2) {
            cs[1].addNum(g._ls[1]);
            cs[2].addNum((int)m.get(g));
          }
 else {
            cs[1].addNum((int)m.get(g));
          }
        }
      }
    }
.doAll(ncol + 1,dataLayoutVec).outputFrame(colnames,d);
  }
  Keyed.remove(dataLayoutVec._key);
  env.pushAry(fr2);
}
