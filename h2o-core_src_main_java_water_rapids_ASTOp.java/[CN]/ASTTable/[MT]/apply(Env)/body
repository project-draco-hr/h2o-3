{
  Frame two=env.peekType() == Env.NULL ? null : env.popAry();
  if (two == null)   env.pop();
  Frame one=env.popAry();
  if (two != null)   if (two.numCols() != 1 || one.numCols() != 1)   throw new IllegalArgumentException("`table` supports at *most* two vectors");
 else   if (one.numCols() < 1 || one.numCols() > 2)   throw new IllegalArgumentException("`table` supports at *most* two vectors and at least one vector.");
  Frame fr;
  if (two != null)   fr=new Frame(one.add(two));
 else   fr=one;
  final int ncol;
  if ((ncol=fr.vecs().length) > 2)   throw new IllegalArgumentException("table does not apply to more than two cols.");
  for (int i=0; i < ncol; i++)   if (!fr.vecs()[i].isInt())   throw new IllegalArgumentException("table only applies to integer vectors.");
  Vec dataLayoutVec;
  Frame fr2;
  String colnames[];
  String[][] d=new String[ncol + 1][];
  if (ncol == 1) {
    final int min=(int)fr.anyVec().min();
    final int max=(int)fr.anyVec().max();
    colnames=new String[]{fr.name(0),"Count"};
    d[0]=fr.anyVec().domain();
    d[1]=null;
    if (min >= 0) {
      UniqueColumnCountTask t=new UniqueColumnCountTask(max,false,false,0).doAll(fr.anyVec());
      final long[] cts=t._cts;
      dataLayoutVec=Vec.makeCon(0,cts.length);
      fr2=new MRTask(){
        @Override public void map(        Chunk[] c,        NewChunk[] cs){
          for (int i=0; i < c[0]._len; ++i) {
            int idx=(int)(i + c[0].start());
            if (cts[idx] == 0)             continue;
            cs[0].addNum(idx);
            cs[1].addNum(cts[idx]);
          }
        }
      }
.doAll(2,dataLayoutVec).outputFrame(colnames,d);
    }
 else     if (min <= 0 && max <= 0) {
      UniqueColumnCountTask t=new UniqueColumnCountTask(-1 * min,true,false,0).doAll(fr.anyVec());
      final long[] cts=t._cts;
      dataLayoutVec=Vec.makeCon(0,cts.length);
      fr2=new MRTask(){
        @Override public void map(        Chunk[] c,        NewChunk[] cs){
          for (int i=0; i < c[0]._len; ++i) {
            int idx=(int)(i + c[0].start());
            if (cts[idx] == 0)             continue;
            cs[0].addNum(idx * -1);
            cs[1].addNum(cts[idx]);
          }
        }
      }
.doAll(2,dataLayoutVec).outputFrame(colnames,d);
    }
 else {
      UniqueColumnCountTask t=new UniqueColumnCountTask(max + -1 * min,false,true,max).doAll(fr.anyVec());
      final long[] cts=t._cts;
      dataLayoutVec=Vec.makeCon(0,cts.length);
      fr2=new MRTask(){
        @Override public void map(        Chunk[] c,        NewChunk[] cs){
          for (int i=0; i < c[0]._len; ++i) {
            int idx=(int)(i + c[0].start());
            if (cts[idx] == 0)             continue;
            cs[0].addNum(idx > max ? (idx - max) * -1 : idx);
            cs[1].addNum(cts[idx]);
          }
        }
      }
.doAll(2,dataLayoutVec).outputFrame(colnames,d);
    }
  }
 else {
    colnames=new String[]{fr.name(0),fr.name(1),"count"};
    long s=System.currentTimeMillis();
    Uniq2ColTsk u=new Uniq2ColTsk().doAll(fr);
    Log.info("Finished gathering uniq groups in: " + (System.currentTimeMillis() - s) / 1000. + " (s)");
    final long[] pairs=new long[u._s.size()];
    int i=0;
    Iterator it=u._s.iterator();
    while (it.hasNext())     pairs[i++]=(long)it.next();
    dataLayoutVec=Vec.makeCon(0,pairs.length);
    s=System.currentTimeMillis();
    NewHashMap h=new NewHashMap(pairs).doAll(dataLayoutVec);
    Log.info("Finished creating new HashMap in: " + (System.currentTimeMillis() - s) / 1000. + " (s)");
    s=System.currentTimeMillis();
    final long[] cnts=new CountUniq2ColTsk(h._s).doAll(fr)._cnts;
    Log.info("Finished gathering counts in: " + (System.currentTimeMillis() - s) / 1000. + " (s)");
    d[0]=fr.vec(0).domain();
    d[1]=fr.vec(1).domain();
    fr2=new MRTask(){
      @Override public void map(      Chunk[] c,      NewChunk[] cs){
        int start=(int)c[0].start();
        for (int i=0; i < c[0]._len; ++i) {
          long[] g=unmix(pairs[i + start]);
          cs[0].addNum(g[0]);
          cs[1].addNum(g[1]);
          cs[2].addNum(cnts[i + start]);
        }
      }
    }
.doAll(ncol + 1,dataLayoutVec).outputFrame(colnames,d);
  }
  Keyed.remove(dataLayoutVec._key);
  env.pushAry(fr2);
}
