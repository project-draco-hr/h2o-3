{
  Frame two=env.peekType() == Env.NULL ? null : env.popAry();
  if (two == null)   env.pop();
  Frame one=env.popAry();
  if (two != null)   if (two.numCols() != 1 || one.numCols() != 1)   throw new IllegalArgumentException("`table` supports at *most* two vectors");
 else   if (one.numCols() < 1 || one.numCols() > 2)   throw new IllegalArgumentException("`table` supports at *most* two vectors and at least one vector.");
  Frame fr;
  if (two != null)   fr=new Frame(one.add(two));
 else   fr=one;
  int ncol;
  if ((ncol=fr.vecs().length) > 2)   throw new IllegalArgumentException("table does not apply to more than two cols.");
  for (int i=0; i < ncol; i++)   if (!fr.vecs()[i].isInt())   throw new IllegalArgumentException("table only applies to integer vectors.");
  String[][] domains=new String[ncol][];
  final long[][] levels=new long[ncol][];
  for (int i=0; i < ncol; i++) {
    Vec v=fr.vecs()[i];
    levels[i]=new Vec.CollectDomain().doAll(new Frame(v)).domain();
    domains[i]=v.domain();
  }
  final long[][] counts=new Tabularize(levels).doAll(fr)._counts;
  Vec dataLayoutVec=Vec.makeCon(0,levels[0].length);
  Vec[] vecs=new Vec[counts.length + 1];
  String[] colnames=new String[counts.length + 1];
  (vecs[0]=new MRTask(){
    @Override public void map(    Chunk cs,    NewChunk oc){
      for (int i=0; i < cs._len; ++i) {
        oc.addNum((double)levels[0][(int)(i + cs.start())]);
      }
    }
  }
.doAll(1,dataLayoutVec).outputFrame(null,null).anyVec()).setDomain(fr.vecs()[0].domain() == null ? null : fr.vecs()[0].domain().clone());
  colnames[0]="row.names";
  if (ncol == 1)   colnames[1]="Count";
  int level1=0;
  for (; level1 < counts.length; ) {
    final int lvl=++level1;
    vecs[lvl]=new MRTask(){
      @Override public void map(      Chunk cs,      NewChunk oc){
        for (int i=0; i < cs._len; ++i)         oc.addNum((double)counts[lvl - 1][(int)(i + cs.start())]);
      }
    }
.doAll(1,dataLayoutVec).outputFrame(null,null).anyVec();
    if (ncol > 1) {
      colnames[level1]=domains[1] == null ? Long.toString(levels[1][level1 - 1]) : domains[1][(int)(levels[1][level1])];
    }
  }
  Keyed.remove(dataLayoutVec._key);
  Frame fr2=new Frame(colnames,vecs);
  env.pushAry(fr2);
}
