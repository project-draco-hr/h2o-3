{
  Frame fr=env.pop0Ary();
  if (fr.vecs().length != 1 || fr.vecs()[0].isEnum())   throw new IllegalArgumentException("First argument must be a numeric column vector");
  double fmin=fr.anyVec().min();
  double fmax=fr.anyVec().max();
  int nbins=_cuts.length - 1;
  double width;
  if (nbins == 0) {
    if (_cuts[0] < 2)     throw new IllegalArgumentException("The number of cuts must be >= 2. Got: " + _cuts[0]);
    nbins=(int)Math.floor(_cuts[0]);
    width=(fmax - fmin) / nbins;
    _cuts=new double[nbins];
    _cuts[0]=fmin - 0.001 * (fmax - fmin);
    for (int i=1; i < _cuts.length; ++i)     _cuts[i]=(i == _cuts.length - 1) ? (fmax + 0.001 * (fmax - fmin)) : (fmin + i * width);
  }
  width=(fmax - fmin) / nbins;
  if (width == 0)   throw new IllegalArgumentException("Data vector is constant!");
  if (_labels != null && _labels.length != nbins)   throw new IllegalArgumentException("`labels` vector does not match the number of cuts.");
  final double cuts[]=_cuts;
  for (int i=0; i < _cuts.length; ++i)   _cuts[i]=Math.floor(_cuts[i] * Math.pow(10,_diglab) + 0.5) / Math.pow(10,_diglab);
  String[][] domains=new String[1][nbins];
  if (_labels == null) {
    domains[0][0]=(_includelowest ? "[" : left()) + _cuts[0] + ","+ _cuts[1]+ rite();
    for (int i=1; i < (_cuts.length - 1); ++i)     domains[0][i]=left() + _cuts[i] + ","+ _cuts[i + 1]+ rite();
  }
 else   domains[0]=_labels;
  final boolean incLow=_includelowest;
  Frame fr2=new MRTask(){
    @Override public void map(    Chunk c,    NewChunk nc){
      int rows=c._len;
      for (int r=0; r < rows; ++r) {
        double x=c.at0(r);
        if (Double.isNaN(x) || (incLow && x < cuts[0]) || (!incLow && x <= cuts[0])|| (_right && x > cuts[cuts.length - 1])|| (!_right && x >= cuts[cuts.length - 1]))         nc.addNum(Double.NaN);
 else {
          for (int i=1; i < cuts.length; ++i) {
            if (_right) {
              if (x <= cuts[i]) {
                nc.addNum(i - 1);
                break;
              }
            }
 else             if (x < cuts[i]) {
              nc.addNum(i - 1);
              break;
            }
          }
        }
      }
    }
  }
.doAll(1,fr).outputFrame(fr.names(),domains);
  env.push(new ValFrame(fr2));
}
