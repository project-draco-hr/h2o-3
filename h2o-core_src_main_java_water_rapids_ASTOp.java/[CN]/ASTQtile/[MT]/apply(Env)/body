{
  QuantileModel.QuantileParameters parms=new QuantileModel.QuantileParameters();
  parms._probs=_probs;
  if (_probs == null) {
    final Frame probs;
    if (env.isAry()) {
      probs=env.popAry();
      if (probs.numCols() != 1)       throw new IllegalArgumentException("Probs must be a single vector.");
      Vec pv=probs.anyVec();
      double[] p=parms._probs=new double[(int)pv.length()];
      for (int i=0; i < pv.length(); i++)       if ((p[i]=pv.at((long)i)) < 0 || p[i] > 1)       throw new IllegalArgumentException("Quantile: probs must be in the range of [0, 1].");
    }
 else     if (env.isNum()) {
      double p[]=parms._probs=new double[1];
      p[0]=env.popDbl();
      if (p[0] < 0 || p[0] > 1)       throw new IllegalArgumentException("Quantile: probs must be in the range of [0, 1].");
    }
  }
  Frame x=env.popAry();
  Key tk=null;
  if (x._key == null) {
    DKV.put(tk=Key.make(),x=new Frame(tk,x.names(),x.vecs()));
  }
  parms._train=x._key;
  QuantileModel q=new Quantile(parms).trainModel().get();
  if (tk != null) {
    DKV.remove(tk);
  }
  Vec shape=Vec.makeZero(parms._probs.length);
  Key[] keys=shape.group().addVecs(1 + x.numCols());
  Vec[] vecs=new Vec[keys.length];
  String[] names=new String[keys.length];
  vecs[0]=Vec.makeCon(keys[0],parms._probs);
  DKV.put(keys[0],vecs[0]);
  names[0]="Probs";
  for (int i=1; i <= x.numCols(); ++i) {
    vecs[i]=Vec.makeCon(keys[i],q._output._quantiles[i - 1]);
    DKV.put(keys[i],vecs[i]);
    names[i]=x._names[i - 1] + "Quantiles";
  }
  Frame fr=new Frame(names,vecs);
  q.delete();
  shape.remove();
  parms._probs=_probs=null;
  env.pushAry(fr);
}
