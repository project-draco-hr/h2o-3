{
  QuantileModel.QuantileParameters parms=new QuantileModel.QuantileParameters();
  parms._probs=_probs;
  if (_probs == null) {
    final Frame probs;
    if (env.isAry()) {
      probs=env.popAry();
      if (probs.numCols() != 1)       throw new IllegalArgumentException("Probs must be a single vector.");
      Vec pv=probs.anyVec();
      double[] p=parms._probs=new double[(int)pv.length()];
      for (int i=0; i < pv.length(); i++)       if ((p[i]=pv.at((long)i)) < 0 || p[i] > 1)       throw new IllegalArgumentException("Quantile: probs must be in the range of [0, 1].");
    }
 else     if (env.isNum()) {
      double p[]=parms._probs=new double[1];
      p[0]=env.popDbl();
      if (p[0] < 0 || p[0] > 1)       throw new IllegalArgumentException("Quantile: probs must be in the range of [0, 1].");
    }
  }
  Frame x=env.popAry();
  parms._train=x._key;
  QuantileModel q=new Quantile(parms).trainModel().get();
  Frame fr=new Frame();
  fr.add("Probs",Vec.makeCon(parms._probs));
  for (int i=0; i < x.numCols(); i++)   fr.add(x._names[i] + "Quantiles",Vec.makeCon(q._output._quantiles[i]));
  q.delete();
  env.pushAry(fr);
}
