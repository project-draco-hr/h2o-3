{
  Frame tst;
  if (env.isNum()) {
    tst=new Frame(new String[]{"tst"},new Vec[]{Vec.makeCon(env.popDbl(),1)});
  }
 else   if (!env.isAry())   throw new IllegalArgumentException("`test` argument must be a frame: ifelse(`test`, `yes`, `no`)");
 else   tst=env.popAry();
  if (tst.numCols() != 1)   throw new IllegalArgumentException("`test` has " + tst.numCols() + " columns. `test` must have exactly 1 column.");
  Frame yes=null;
  double dyes=0;
  Frame no=null;
  double dno=0;
  if (env.isAry())   yes=env.popAry();
 else   dyes=env.popDbl();
  if (env.isAry())   no=env.popAry();
 else   dno=env.popDbl();
  if (yes != null && no != null) {
    if (yes.numCols() != no.numCols()) {
      if (!((yes.numCols() == 1 && no.numCols() != 1) || (yes.numCols() != 1 && no.numCols() == 1))) {
        throw new IllegalArgumentException("Column mismatch between `yes` and `no`. `yes` has " + yes.numCols() + " columns; `no` has "+ no.numCols()+ " columns.");
      }
    }
  }
 else   if (yes != null) {
    if (yes.numCols() != 1)     throw new IllegalArgumentException("Column mismatch between `yes` and `no`. `yes` has " + yes.numCols() + " columns; `no` has "+ 1+ " columns.");
  }
 else   if (no != null) {
    if (no.numCols() != 1)     throw new IllegalArgumentException("Column mismatch between `yes` and `no`. `yes` has " + 1 + "; `no` has "+ no.numCols()+ ".");
  }
  Frame fr2;
  if (tst.numRows() == 1 && tst.numCols() == 1) {
    if (tst.anyVec().at(0) != 0)     fr2=new Frame(new String[]{"C1"},new Vec[]{yes == null ? Vec.makeCon(dyes,1) : yes.vecs()[0]});
 else     fr2=new Frame(new String[]{"C1"},new Vec[]{no == null ? Vec.makeCon(dno,1) : no.vecs()[0]});
  }
 else {
    Frame a_yes=yes == null ? adaptToTst(dyes,tst) : adaptToTst(yes,tst);
    Frame a_no=no == null ? adaptToTst(dno,tst) : adaptToTst(no,tst);
    Frame frtst=(new Frame(tst)).add(a_yes).add(a_no);
    final int ycols=a_yes.numCols();
    fr2=new MRTask(){
      @Override public void map(      Chunk chks[],      NewChunk nchks[]){
        int rows=chks[0]._len;
        int cols=chks.length;
        Chunk pred=chks[0];
        for (int r=0; r < rows; ++r) {
          for (int c=(pred.atd(r) != 0 ? 1 : ycols + 1), col=0; c < (pred.atd(r) != 0 ? ycols + 1 : cols); ++c) {
            if (chks[c].vec().isUUID())             nchks[col++].addUUID(chks[c],r);
 else             if (chks[c].vec().isString())             nchks[col++].addStr(chks[c].atStr(new ValueString(),r));
 else             nchks[col++].addNum(chks[c].atd(r));
          }
        }
      }
    }
.doAll(yes == null ? 1 : yes.numCols(),frtst).outputFrame(yes == null ? (new String[]{"C1"}) : yes.names(),null);
  }
  env.pushAry(fr2);
}
