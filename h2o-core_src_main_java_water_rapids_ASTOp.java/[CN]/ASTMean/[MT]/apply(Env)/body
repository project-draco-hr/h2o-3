{
  if (env.isNum())   return;
  Frame fr=env.popAry();
  if (fr.numCols() > 1 && fr.numRows() == 1) {
    double mean=0;
    double rows=0;
    for (    Vec v : fr.vecs()) {
      double val=v.at(0);
      if (!Double.isNaN(val)) {
        mean+=v.at(0);
        rows++;
      }
    }
    env.push(new ValNum(mean / rows));
  }
 else   if (fr.numCols() > 1) {
    Futures fs=new Futures();
    Key key=Vec.VectorGroup.VG_LEN1.addVecs(1)[0];
    AppendableVec v=new AppendableVec(key);
    NewChunk chunk=new NewChunk(v,0);
    for (int i=0; i < fr.numCols(); ++i)     chunk.addNum(fr.vec(i).isEnum() ? Double.NaN : fr.vec(i).mean());
    chunk.close(0,fs);
    Vec vec=v.close(fs);
    fs.blockForPending();
    Frame fr2=new Frame(Key.make(),new String[]{"C1"},new Vec[]{vec});
    DKV.put(fr2);
    env.pushAry(fr2);
  }
 else {
    Vec v=fr.anyVec();
    if (v.isEnum()) {
      env.push(new ValNum(Double.NaN));
      return;
    }
    if (_narm || v.naCnt() == 0)     env.push(new ValNum(v.mean()));
 else {
      MeanNARMTask t=new MeanNARMTask(false).doAll(v);
      if (t._rowcnt == 0 || Double.isNaN(t._sum))       env.push(new ValNum(Double.NaN));
 else       env.push(new ValNum(t._sum / t._rowcnt));
    }
  }
}
