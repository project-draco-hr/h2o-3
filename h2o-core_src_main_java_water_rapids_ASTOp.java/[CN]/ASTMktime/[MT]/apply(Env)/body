{
  Frame fs[]=new Frame[7];
  int is[]=new int[7];
  Frame x=null;
  for (int i=0; i < 7; i++)   if (env.peekType() == Env.ARY)   fs[i]=x=env.popAry();
 else   is[i]=(int)env.popDbl();
  if (x == null) {
    long msec=new MutableDateTime(is[6],is[5] + 1,is[4] + 1,is[3],is[2],is[1],is[0]).getMillis();
    env.poppush(1,new ValNum(msec));
    return;
  }
  Vec vecs[]=new Vec[7];
  for (int i=0; i < 7; i++) {
    if (fs[i] == null) {
      vecs[i]=x.anyVec().makeCon(is[i]);
    }
 else {
      if (fs[i].numCols() != 1)       throw new IllegalArgumentException("Expect single column");
      vecs[i]=fs[i].anyVec();
    }
  }
  Frame fr2=new MRTask(){
    @Override public void map(    Chunk chks[],    NewChunk nchks[]){
      MutableDateTime dt=new MutableDateTime(0);
      NewChunk n=nchks[0];
      int rlen=chks[0]._len;
      for (int r=0; r < rlen; r++) {
        dt.setDateTime((int)chks[6].at8(r),(int)chks[5].at8(r) + 1,(int)chks[4].at8(r) + 1,(int)chks[3].at8(r),(int)chks[2].at8(r),(int)chks[1].at8(r),(int)chks[0].at8(r));
        n.addNum(dt.getMillis());
      }
    }
  }
.doAll(1,vecs).outputFrame(new String[]{"msec"},null);
  env.poppush(1,new ValFrame(fr2));
}
