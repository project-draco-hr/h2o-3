{
  if (env.isNum()) {
    env.pop();
    env.push(new ValNum(Double.NaN));
  }
 else {
    Frame fr=env.peekAry();
    Frame y=((ValFrame)env.peekAt(-1))._fr;
    String use=((ValStr)env.peekAt(-2))._s;
    String[] colnames=y.names();
    if (fr.numRows() != y.numRows())     throw new IllegalArgumentException("In var(): incompatible dimensions. Frames must have the same number of rows.");
    if (use.equals("everything"))     _narm=false;
    if (use.equals("complete.obs"))     _narm=true;
    if (use.equals("all.obs"))     _narm=false;
    if (fr.numRows() == 1) {
      double xmean=0;
      double ymean=0;
      double divideby=fr.numCols() - 1;
      double ss=0;
      for (      Vec v : fr.vecs())       xmean+=v.at(0);
      for (      Vec v : y.vecs())       ymean+=v.at(0);
      xmean/=(divideby + 1);
      ymean/=(divideby + 1);
      if (Double.isNaN(xmean) || Double.isNaN(ymean)) {
        ss=Double.NaN;
      }
 else {
        for (int r=0; r <= divideby; ++r) {
          ss+=(fr.vecs()[r].at(0) - xmean) * (y.vecs()[r].at(0) - ymean);
        }
      }
      env.pop();
      env.pop();
      env.pop();
      env.push(new ValNum(ss == Double.NaN ? ss : ss / divideby));
    }
 else {
      final double[][] covars=new double[y.numCols()][fr.numCols()];
      final CovarTask tsks[][]=new CovarTask[y.numCols()][fr.numCols()];
      final Frame frs[][]=new Frame[y.numCols()][fr.numCols()];
      final double xmeans[]=new double[fr.numCols()];
      final double ymeans[]=new double[y.numCols()];
      for (int r=0; r < fr.numCols(); ++r)       xmeans[r]=getMean(fr.vecs()[r],_narm,use);
      for (int c=0; c < y.numCols(); ++c)       ymeans[c]=getMean(y.vecs()[c],_narm,use);
      for (int c=0; c < y.numCols(); ++c) {
        for (int r=0; r < fr.numCols(); ++r) {
          frs[c][r]=new Frame(y.vecs()[c],fr.vecs()[r]);
          tsks[c][r]=new CovarTask(ymeans[c],xmeans[r]).doAll(frs[c][r]);
        }
      }
      for (int c=0; c < y.numCols(); c++)       for (int r=0; r < fr.numCols(); r++) {
        covars[c][r]=tsks[c][r].getResult()._ss / (fr.numRows() - 1);
        frs[c][r]=null;
      }
      env.pop();
      env.pop();
      env.pop();
      if (covars.length == 1 && covars[0].length == 1)       env.push(new ValNum(covars[0][0]));
 else {
        Key keys[]=Vec.VectorGroup.VG_LEN1.addVecs(covars.length);
        Vec[] vecs=new Vec[covars.length];
        for (int i=0; i < covars.length; i++) {
          AppendableVec v=new AppendableVec(keys[i]);
          NewChunk c=new NewChunk(v,0);
          for (int j=0; j < covars[0].length; j++)           c.addNum(covars[i][j]);
          c.close(0,null);
          vecs[i]=v.close(null);
        }
        env.push(new ValFrame(new Frame(colnames,vecs)));
      }
    }
  }
}
