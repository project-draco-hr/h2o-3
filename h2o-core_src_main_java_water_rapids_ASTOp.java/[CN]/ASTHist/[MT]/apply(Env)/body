{
  Frame fr2;
  Val v=e.pop();
  String algo=null;
  int numBreaks=-1;
  double[] breaks=null;
  if (v instanceof ValStr)   algo=((ValStr)v)._s.toLowerCase();
 else   if (v instanceof ValDoubleList)   breaks=((ValDoubleList)v)._d;
 else   if (v instanceof ValNum)   numBreaks=(int)((ValNum)v)._d;
 else   throw new IllegalArgumentException("breaks must be a string, a list of doubles, or a number. Got: " + v.getClass());
  Frame f=e.popAry();
  if (f.numCols() != 1)   throw new IllegalArgumentException("Hist only applies to single numeric columns.");
  Vec vec=f.anyVec();
  if (!vec.isNumeric())   throw new IllegalArgumentException("Hist only applies to single numeric columns.");
  HistTask t;
  double h;
  double x1=vec.max();
  double x0=vec.min();
  if (breaks != null)   t=new HistTask(breaks,-1,-1).doAll(vec);
 else   if (algo != null) {
switch (algo) {
case "sturges":
      numBreaks=sturges(vec);
    h=(x1 - x0) / numBreaks;
  break;
case "rice":
numBreaks=rice(vec);
h=(x1 - x0) / numBreaks;
break;
case "sqrt":
numBreaks=sqrt(vec);
h=(x1 - x0) / numBreaks;
break;
case "doane":
numBreaks=doane(vec);
h=(x1 - x0) / numBreaks;
break;
case "scott":
h=scotts_h(vec);
numBreaks=scott(vec,h);
break;
case "fd":
h=fds_h(vec);
numBreaks=fd(vec,h);
break;
default :
numBreaks=sturges(vec);
h=(x1 - x0) / numBreaks;
}
t=new HistTask(computeCuts(vec,numBreaks),h,x0).doAll(vec);
}
 else {
h=(x1 - x0) / numBreaks;
t=new HistTask(computeCuts(vec,numBreaks),h,x0).doAll(vec);
}
final double[] brks=t._breaks;
final long[] cnts=t._counts;
final double[] mids=t._mids;
Vec layoutVec=Vec.makeZero(brks.length);
fr2=new MRTask(){
@Override public void map(Chunk[] c,NewChunk[] nc){
int start=(int)c[0].start();
for (int i=0; i < c[0]._len; ++i) {
nc[0].addNum(brks[i + start]);
if (i == 0) {
nc[1].addNA();
nc[2].addNA();
}
 else {
nc[1].addNum(cnts[(i - 1) + start]);
nc[2].addNum(mids[(i - 1) + start]);
}
}
}
}
.doAll(3,layoutVec).outputFrame(null,new String[]{"breaks","counts","mids"},null);
layoutVec.remove();
e.pushAry(fr2);
}
