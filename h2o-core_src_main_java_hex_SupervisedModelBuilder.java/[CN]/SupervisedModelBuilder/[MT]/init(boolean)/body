{
  super.init(expensive);
  if (!_parms._balance_classes)   hide("_max_after_balance_size","Balance classes is false, hide max_after_balance_size");
  if (_parms._max_after_balance_size <= 0.0)   error("_max_after_balance_size","Max size after balancing needs to be positive, suggest 1.0f");
  if (_train == null)   return;
  if (_train.numCols() <= 1)   error("_train","Training data must have at least 2 features (incl. response).");
  if (!isSupervised()) {
    hide("_response_column","Ignored for unsupervised methods.");
    hide("_balance_classes","Ignored for unsupervised methods.");
    hide("_class_sampling_factors","Ignored for unsupervised methods.");
    hide("_max_after_balance_size","Ignored for unsupervised methods.");
    hide("_max_confusion_matrix_size","Ignored for unsupervised methods.");
    _response=null;
    _response_key=null;
    _vresponse=null;
    _nclass=1;
    return;
  }
  if (null == _parms._response_column) {
    error("_response_column","Response column parameter not set.");
    return;
  }
  if (!_parms._balance_classes) {
    hide("_max_after_balance_size","Only used with balanced classes");
    hide("_class_sampling_factors","Class sampling factors is only applicable if balancing classes.");
  }
  int ridx=_train.find(_parms._response_column);
  if (ridx == -1) {
    error("_response_column","Response column " + _parms._response_column + " not found in frame: "+ _parms._train+ ".");
  }
 else {
    _response=_train.remove(ridx);
    if (_valid != null && _valid.find(_parms._response_column) == -1)     error("_response_column","Response column is missing in the validation set!");
    _vresponse=_valid == null ? null : _valid.remove(ridx);
    if (_response.isBad())     error("_response_column","Response column is all NAs!");
    if (_response.isConst())     error("_response_column","Response column is constant!");
    _train.add(_parms._response_column,_response);
    _response_key=_response._key;
    if (_valid != null) {
      _valid.add(_parms._response_column,_vresponse);
      _vresponse_key=_vresponse._key;
    }
    _nclass=_response.isEnum() ? _response.domain().length : 1;
    if (_nclass > 1000)     warn("_response","Response has " + _nclass + " levels, which can lead to slow and large models.");
    if (_nclass > 10000)     error("_response","Response has " + _nclass + " > 10,000 levels, which is not currently enabled.");
    if (_parms._balance_classes && isClassifier() && (long)(_train.numRows() * _parms._max_after_balance_size) < _nclass)     error("_max_after_balance_size","Cannot end up with fewer rows than there are classes. Increase max_after_balance_size.");
    if (!isClassifier()) {
      hide("_balance_classes","Balance classes is only applicable to classification problems.");
      hide("_class_sampling_factors","Class sampling factors is only applicable to classification problems.");
      hide("_max_after_balance_size","Max after balance size is only applicable to classification problems.");
      hide("_max_confusion_matrix_size","Max confusion matrix size is only applicable to classification problems.");
    }
    if (_nclass <= 2)     hide("_max_hit_ratio_k","Max K-value for hit ratio is only applicable to multi-class classification problems.");
    if (_nclass <= 2)     hide("_max_confusion_matrix_size","Only for multi-class classification problems.");
  }
}
