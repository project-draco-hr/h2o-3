{
  H2O.API_PORT=H2O.ARGS.port == 0 ? H2O.ARGS.baseport : H2O.ARGS.port;
  while (true) {
    H2O.H2O_PORT=H2O.API_PORT + 1;
    try {
      _apiSocket=new ServerSocket(H2O.API_PORT);
      _udpSocket=DatagramChannel.open();
      _udpSocket.socket().setReuseAddress(true);
      _udpSocket.socket().bind(new InetSocketAddress(H2O.SELF_ADDRESS,H2O.H2O_PORT));
      break;
    }
 catch (    IOException e) {
      if (_apiSocket != null)       try {
        _apiSocket.close();
      }
 catch (      IOException ohwell) {
        Log.err(ohwell);
      }
      if (_udpSocket != null)       try {
        _udpSocket.close();
      }
 catch (      IOException ie) {
      }
      _apiSocket=null;
      _udpSocket=null;
      if (H2O.ARGS.port != 0)       H2O.die("On " + H2O.SELF_ADDRESS + " some of the required ports "+ H2O.ARGS.port+ ", "+ (H2O.ARGS.port + 1)+ " are not available, change -port PORT and try again.");
    }
    H2O.API_PORT+=2;
  }
  H2O.SELF=H2ONode.self(H2O.SELF_ADDRESS);
  Log.info("Internal communication uses port: ",H2O.H2O_PORT,"\nListening for HTTP and REST traffic on  http:/",H2O.SELF_ADDRESS,":" + _apiSocket.getLocalPort() + "/");
  String embeddedConfigFlatfile=null;
  if (embeddedConfigFlatfile != null)   H2O.STATIC_H2OS=parseFlatFileFromString(embeddedConfigFlatfile);
 else   H2O.STATIC_H2OS=parseFlatFile(H2O.ARGS.flatfile);
  int hash=H2O.ARGS.name.hashCode() & 0x7fffffff;
  int port=(hash % (0xF0000000 - 0xE1000000)) + 0xE1000000;
  byte[] ip=new byte[4];
  for (int i=0; i < 4; i++)   ip[i]=(byte)(port >>> ((3 - i) << 3));
  try {
    H2O.CLOUD_MULTICAST_GROUP=InetAddress.getByAddress(ip);
  }
 catch (  UnknownHostException e) {
    Log.throwErr(e);
  }
  H2O.CLOUD_MULTICAST_PORT=(port >>> 16);
}
