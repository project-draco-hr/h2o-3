{
  H2O.API_PORT=H2O.ARGS.port == 0 ? H2O.ARGS.baseport : H2O.ARGS.port;
  if (H2O.getJetty() == null) {
    H2O.setJetty(new JettyHTTPD());
  }
  while (true) {
    H2O.H2O_PORT=H2O.API_PORT + 1;
    try {
      _apiSocket=H2O.ARGS.ip == null ? new ServerSocket(H2O.API_PORT) : new ServerSocket(H2O.API_PORT,-1,H2O.SELF_ADDRESS);
      _apiSocket.setReuseAddress(true);
      _udpSocket=DatagramChannel.open();
      _udpSocket.socket().setReuseAddress(true);
      InetSocketAddress isa=new InetSocketAddress(H2O.SELF_ADDRESS,H2O.H2O_PORT);
      _udpSocket.socket().bind(isa);
      _tcpSocketBig=ServerSocketChannel.open();
      _tcpSocketBig.socket().setReceiveBufferSize(water.AutoBuffer.TCP_BUF_SIZ);
      _tcpSocketBig.socket().bind(isa);
      if (!H2O.ARGS.useUDP) {
        _tcpSocketSmall=ServerSocketChannel.open();
        _tcpSocketBig.socket().setReceiveBufferSize(water.AutoBuffer.TCP_BUF_SIZ);
        InetSocketAddress isa2=new InetSocketAddress(H2O.SELF_ADDRESS,H2O.H2O_PORT + 1);
        _tcpSocketSmall.socket().bind(isa2);
      }
      _apiSocket.close();
      if (!H2O.ARGS.disable_web) {
        H2O.getJetty().start(H2O.ARGS.ip,H2O.API_PORT);
      }
      break;
    }
 catch (    Exception e) {
      if (_apiSocket != null)       try {
        _apiSocket.close();
      }
 catch (      IOException ohwell) {
        Log.err(ohwell);
      }
      if (_udpSocket != null)       try {
        _udpSocket.close();
      }
 catch (      IOException ie) {
      }
      if (_tcpSocketBig != null)       try {
        _tcpSocketBig.close();
      }
 catch (      IOException ie) {
      }
      if (_tcpSocketSmall != null)       try {
        _tcpSocketSmall.close();
      }
 catch (      IOException ie) {
      }
      _apiSocket=null;
      _udpSocket=null;
      _tcpSocketBig=null;
      _tcpSocketSmall=null;
      if (H2O.ARGS.port != 0)       H2O.die("On " + H2O.SELF_ADDRESS + " some of the required ports "+ H2O.ARGS.port+ ", "+ (H2O.ARGS.port + 1)+ " are not available, change -port PORT and try again.");
    }
    H2O.API_PORT+=4;
  }
  H2O.SELF=H2ONode.self(H2O.SELF_ADDRESS);
  Log.info("Internal communication uses port: ",H2O.H2O_PORT,"\n" + "Listening for HTTP and REST traffic on " + H2O.getJetty().getScheme() + "://",H2O.getIpPortString() + "/");
  try {
    Log.debug("Interface MTU: ",(NetworkInterface.getByInetAddress(H2O.SELF_ADDRESS)).getMTU());
  }
 catch (  SocketException se) {
    Log.debug("No MTU due to SocketException. " + se.toString());
  }
  String embeddedConfigFlatfile=null;
  AbstractEmbeddedH2OConfig ec=H2O.getEmbeddedH2OConfig();
  if (ec != null) {
    ec.notifyAboutEmbeddedWebServerIpPort(H2O.SELF_ADDRESS,H2O.API_PORT);
    if (ec.providesFlatfile()) {
      try {
        embeddedConfigFlatfile=ec.fetchFlatfile();
      }
 catch (      Exception e) {
        Log.err("Failed to get embedded config flatfile");
        Log.err(e);
        H2O.exit(1);
      }
    }
  }
  if (embeddedConfigFlatfile != null)   H2O.STATIC_H2OS=parseFlatFileFromString(embeddedConfigFlatfile);
 else   H2O.STATIC_H2OS=parseFlatFile(H2O.ARGS.flatfile);
  int hash=H2O.ARGS.name.hashCode() & 0x7fffffff;
  int port=(hash % (0xF0000000 - 0xE1000000)) + 0xE1000000;
  byte[] ip=new byte[4];
  for (int i=0; i < 4; i++)   ip[i]=(byte)(port >>> ((3 - i) << 3));
  try {
    H2O.CLOUD_MULTICAST_GROUP=InetAddress.getByAddress(ip);
  }
 catch (  UnknownHostException e) {
    Log.throwErr(e);
  }
  H2O.CLOUD_MULTICAST_PORT=(port >>> 16);
}
