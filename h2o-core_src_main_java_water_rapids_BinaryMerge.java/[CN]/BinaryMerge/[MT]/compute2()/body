{
  _timings=new double[20];
  long t0=System.nanoTime();
  SingleThreadRadixOrder.OXHeader leftSortedOXHeader=DKV.getGet(getSortedOXHeaderKey(true,_leftMSB));
  if (leftSortedOXHeader == null) {
    if (_allRight)     throw H2O.unimpl();
    tryComplete();
    return;
  }
  SingleThreadRadixOrder.OXHeader rightSortedOXHeader=DKV.getGet(getSortedOXHeaderKey(false,_rightMSB));
  if (rightSortedOXHeader == null) {
    if (_allLeft == false) {
      tryComplete();
      return;
    }
    rightSortedOXHeader=new SingleThreadRadixOrder.OXHeader(0,0,0);
  }
  _leftBatchSize=leftSortedOXHeader._batchSize;
  _rightBatchSize=rightSortedOXHeader._batchSize;
  _perNodeNumRightRowsToFetch=new long[H2O.CLOUD.size()];
  _perNodeNumLeftRowsToFetch=new long[H2O.CLOUD.size()];
  _leftKey=new byte[leftSortedOXHeader._nBatch][];
  _leftOrder=new long[leftSortedOXHeader._nBatch][];
  _retFirst=new long[leftSortedOXHeader._nBatch][];
  _retLen=new long[leftSortedOXHeader._nBatch][];
  for (int b=0; b < leftSortedOXHeader._nBatch; ++b) {
    SplitByMSBLocal.OXbatch oxLeft=DKV.getGet(SplitByMSBLocal.getSortedOXbatchKey(true,_leftMSB,b));
    _leftKey[b]=oxLeft._x;
    _leftOrder[b]=oxLeft._o;
    _retFirst[b]=new long[oxLeft._o.length];
    _retLen[b]=new long[oxLeft._o.length];
  }
  _leftN=leftSortedOXHeader._numRows;
  _rightKey=new byte[rightSortedOXHeader._nBatch][];
  _rightOrder=new long[rightSortedOXHeader._nBatch][];
  for (int b=0; b < rightSortedOXHeader._nBatch; ++b) {
    SplitByMSBLocal.OXbatch oxRight=DKV.getGet(SplitByMSBLocal.getSortedOXbatchKey(false,_rightMSB,b));
    _rightKey[b]=oxRight._x;
    _rightOrder[b]=oxRight._o;
  }
  _rightN=rightSortedOXHeader._numRows;
  _leftKeyNCol=_leftFieldSizes.length;
  _rightKeyNCol=_rightFieldSizes.length;
  _leftKeySize=ArrayUtils.sum(_leftFieldSizes);
  _rightKeySize=ArrayUtils.sum(_rightFieldSizes);
  System.out.println("_leftKeySize=" + _leftKeySize + " _rightKeySize="+ _rightKeySize+ " _leftN="+ _leftN+ " _rightN="+ _rightN);
  _numJoinCols=Math.min(_leftKeyNCol,_rightKeyNCol);
  _leftChunkNode=new int[_leftFrame.anyVec().nChunks()];
  _rightChunkNode=new int[_rightFrame.anyVec().nChunks()];
  for (int i=0; i < _leftFrame.anyVec().nChunks(); i++) {
    _leftChunkNode[i]=_leftFrame.anyVec().chunkKey(i).home_node().index();
  }
  for (int i=0; i < _rightFrame.anyVec().nChunks(); i++) {
    _rightChunkNode[i]=_rightFrame.anyVec().chunkKey(i).home_node().index();
  }
  _leftVec=_leftFrame.anyVec();
  _rightVec=_rightFrame.anyVec();
  _timings[0]+=(System.nanoTime() - t0) / 1e9;
  if ((_leftN != 0 || _allRight) && (_rightN != 0 || _allLeft)) {
    t0=System.nanoTime();
    bmerge_r(-1,_leftN,-1,_rightN);
    _timings[1]+=(System.nanoTime() - t0) / 1e9;
    if (_numRowsInResult > 0)     createChunksInDKV();
  }
  tryComplete();
}
