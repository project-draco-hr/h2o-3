{
  String[] lines=new String[10];
  int nlines=0;
  int offset=0;
  while (offset < bits.length && nlines < lines.length) {
    int lineStart=offset;
    while (offset < bits.length && !CsvParser.isEOL(bits[offset]))     ++offset;
    int lineEnd=offset;
    ++offset;
    if ((offset < bits.length) && (bits[offset] == CsvParser.CHAR_LF))     ++offset;
    if (bits[lineStart] == '#')     continue;
    if (bits[lineStart] == '@')     continue;
    if (lineEnd > lineStart) {
      String str=new String(bits,lineStart,lineEnd - lineStart).trim();
      if (!str.isEmpty())       lines[nlines++]=str;
    }
  }
  if (nlines == 0)   return new ParseSetupHandler(false,0,new String[]{"No data!"},ParserType.AUTO,AUTO_SEP,0,false,null,null);
  ArrayList<String> errors=new ArrayList<>();
  String[] labels;
  final byte single_quote=singleQuotes ? CsvParser.CHAR_SINGLE_QUOTE : -1;
  final String[][] data=new String[nlines][];
  if (nlines == 1) {
    if (sep == AUTO_SEP) {
      if (lines[0].split(",").length > 2)       sep=(byte)',';
 else       if (lines[0].split(" ").length > 2)       sep=' ';
 else       return new ParseSetupHandler(false,1,new String[]{"Failed to guess separator."},ParserType.CSV,AUTO_SEP,ncols,singleQuotes,null,data);
    }
    data[0]=determineTokens(lines[0],sep,single_quote);
    ncols=(ncols > 0) ? ncols : data[0].length;
    if (checkHeader == 0)     labels=ParseSetupHandler.allStrings(data[0]) ? data[0] : null;
 else     if (checkHeader == 1)     labels=data[0];
 else     labels=null;
  }
 else {
    if (sep == AUTO_SEP) {
      sep=guessSeparator(lines[0],lines[1],single_quote);
      if (sep == AUTO_SEP && nlines > 2) {
        if (sep == AUTO_SEP)         sep=guessSeparator(lines[1],lines[2],single_quote);
        if (sep == AUTO_SEP)         sep=guessSeparator(lines[0],lines[2],single_quote);
      }
      if (sep == AUTO_SEP)       sep=(byte)' ';
    }
    for (int i=0; i < nlines; ++i)     data[i]=determineTokens(lines[i],sep,single_quote);
    if (ncols == -1)     ncols=guessNcols(columnNames,data);
    if (checkHeader == 0) {
      labels=ParseSetupHandler.hasHeader(data[0],data[1]) && (data[0].length == ncols) ? data[0] : null;
    }
 else     if (checkHeader == 1) {
      labels=data[0];
    }
 else {
      labels=null;
    }
    if (columnNames != null && labels != null) {
      if (labels.length != columnNames.length)       errors.add("Already have " + columnNames.length + " column labels, but found "+ labels.length+ " in this file");
 else {
        for (int i=0; i < labels.length; ++i)         if (!labels[i].equalsIgnoreCase(columnNames[i])) {
          errors.add("Column " + (i + 1) + " label '"+ labels[i]+ "' does not match '"+ columnNames[i]+ "'");
          break;
        }
        labels=columnNames;
      }
    }
  }
  int ilines=0;
  for (int i=0; i < data.length; ++i) {
    if (data[i].length != ncols) {
      errors.add("error at line " + i + " : incompatible line length. Got "+ data[i].length+ " columns.");
      ++ilines;
    }
  }
  String[] err=null;
  if (!errors.isEmpty())   errors.toArray(err=new String[errors.size()]);
  return new ParseSetupHandler(true,ilines,err,ParserType.CSV,sep,ncols,singleQuotes,labels,data);
}
