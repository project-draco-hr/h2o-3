{
  String[] lines=getFirstLines(bits);
  if (lines.length == 0)   return new ParseSetup(false,0,0,new String[]{"No data!"},ParserType.AUTO,GUESS_SEP,false,checkHeader,0,null,null,null,null,null,FileVec.DFLT_CHUNK_SIZE);
  ArrayList<String> errors=new ArrayList<>();
  String[] labels;
  final String[][] data=new String[lines.length][];
  if (lines.length == 1) {
    if (sep == GUESS_SEP) {
      if (lines[0].split(",").length > 2)       sep=(byte)',';
 else       if (lines[0].split(" ").length > 2)       sep=' ';
 else {
        data[0]=new String[]{lines[0]};
        byte[] ctypes=new byte[1];
        String[][] domains=new String[1][];
        if (NumberUtils.isNumber(data[0][0])) {
          ctypes[0]=Vec.T_NUM;
        }
 else {
          ValueString str=new ValueString(data[0][0]);
          if (ParseTime.isDateTime(str))           ctypes[0]=Vec.T_TIME;
 else           if (ParseTime.isUUID(str))           ctypes[0]=Vec.T_UUID;
 else {
            ctypes[0]=Vec.T_ENUM;
            domains[0]=new String[]{data[0][0]};
          }
        }
        return new ParseSetup(true,0,0,new String[]{"Failed to guess separator."},ParserType.CSV,GUESS_SEP,singleQuotes,checkHeader,1,null,ctypes,domains,naStrings,data,FileVec.DFLT_CHUNK_SIZE);
      }
    }
    data[0]=determineTokens(lines[0],sep,singleQuotes);
    ncols=(ncols > 0) ? ncols : data[0].length;
    if (checkHeader == GUESS_HEADER)     labels=ParseSetup.allStrings(data[0]) ? data[0] : null;
 else     if (checkHeader == HAS_HEADER)     labels=data[0];
 else     labels=null;
  }
 else {
    if (sep == GUESS_SEP) {
      sep=guessSeparator(lines[0],lines[1],singleQuotes);
      if (sep == GUESS_SEP && lines.length > 2) {
        sep=guessSeparator(lines[1],lines[2],singleQuotes);
        if (sep == GUESS_SEP)         sep=guessSeparator(lines[0],lines[2],singleQuotes);
      }
      if (sep == GUESS_SEP)       sep=(byte)' ';
    }
    for (int i=0; i < lines.length; ++i)     data[i]=determineTokens(lines[i],sep,singleQuotes);
    ncols=guessNcols(columnNames,data);
    if (checkHeader == HAS_HEADER || (checkHeader == GUESS_HEADER && ParseSetup.hasHeader(data[0],data[1]) && data[0].length == ncols)) {
      checkHeader=HAS_HEADER;
      labels=data[0];
    }
 else {
      checkHeader=NO_HEADER;
      labels=null;
    }
    if (columnNames != null && labels != null) {
      if (labels.length != columnNames.length)       errors.add("Already have " + columnNames.length + " column labels, but found "+ labels.length+ " in this file");
 else {
        for (int i=0; i < labels.length; ++i)         if (!labels[i].equalsIgnoreCase(columnNames[i])) {
          errors.add("Column " + (i + 1) + " label '"+ labels[i]+ "' does not match '"+ columnNames[i]+ "'");
          break;
        }
        labels=columnNames;
      }
    }
  }
  int ilines=0;
  for (int i=0; i < data.length; ++i) {
    if (data[i].length != ncols) {
      errors.add("error at line " + i + " : incompatible line length. Got "+ data[i].length+ " columns.");
      ++ilines;
    }
  }
  String[] err=null;
  if (!errors.isEmpty())   errors.toArray(err=new String[errors.size()]);
  ParseSetup resSetup=new ParseSetup(true,ilines,labels != null ? 1 : 0,err,ParserType.CSV,sep,singleQuotes,checkHeader,ncols,labels,null,null,naStrings,data);
  if (columnTypes == null || ncols != columnTypes.length) {
    InputStream is=new ByteArrayInputStream(bits);
    CsvParser p=new CsvParser(resSetup);
    InspectDataOut dout=new InspectDataOut(resSetup._number_columns);
    try {
      p.streamParse(is,dout);
      resSetup._column_types=dout.guessTypes();
      resSetup._na_strings=dout.guessNAStrings(resSetup._column_types);
    }
 catch (    Throwable e) {
      throw new RuntimeException(e);
    }
  }
 else {
    resSetup._column_types=columnTypes;
    resSetup._na_strings=null;
  }
  return resSetup;
}
