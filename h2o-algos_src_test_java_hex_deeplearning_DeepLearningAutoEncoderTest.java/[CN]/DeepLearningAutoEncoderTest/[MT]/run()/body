{
  long seed=0xDECAF;
  Frame train=null, test=null;
  try {
    NFSFileVec nfs=NFSFileVec.make(find_test_file(PATH));
    train=ParseDataset.parse(Key.make("train.hex"),nfs._key);
    NFSFileVec nfs2=NFSFileVec.make(find_test_file(PATH2));
    test=ParseDataset.parse(Key.make("test.hex"),nfs2._key);
    for (    float sparsity_beta : new float[]{0,0.1f}) {
      DeepLearningModel.DeepLearningParameters p=new DeepLearningModel.DeepLearningParameters();
      p._train=train._key;
      p._valid=test._key;
      p._autoencoder=true;
      p._response_column=train.names()[train.names().length - 1];
      p._seed=seed;
      p._hidden=new int[]{37,12};
      p._adaptive_rate=true;
      p._train_samples_per_iteration=-1;
      p._sparsity_beta=sparsity_beta;
      p._average_activation=-0.7;
      p._l1=1e-4;
      p._activation=DeepLearningModel.DeepLearningParameters.Activation.TanhWithDropout;
      p._loss=DeepLearningModel.DeepLearningParameters.Loss.Absolute;
      p._epochs=13.3;
      p._force_load_balance=true;
      DeepLearning dl=new DeepLearning(p);
      DeepLearningModel mymodel=null;
      try {
        mymodel=dl.trainModel().get();
      }
 catch (      Throwable t) {
        t.printStackTrace();
        throw new RuntimeException(t);
      }
 finally {
        dl.remove();
      }
      Frame l2_frame_train=null, l2_frame_test=null;
      StringBuilder sb=new StringBuilder();
      try {
        sb.append("Verifying results.\n");
        double quantile=0.95;
        l2_frame_test=mymodel.scoreAutoEncoder(test,Key.make());
        Vec l2_test=l2_frame_test.anyVec();
        sb.append("Mean reconstruction error (test): ").append(l2_test.mean()).append("\n");
        Assert.assertEquals(mymodel.mse(),l2_test.mean(),1e-7);
        Assert.assertTrue("too big a reconstruction error: " + l2_test.mean(),l2_test.mean() < 2.0);
        l2_test.remove();
        Frame reconstr=mymodel.score(train);
        l2_frame_train=mymodel.scoreAutoEncoder(train,Key.make());
        final Vec l2_train=l2_frame_train.anyVec();
        double mean_l2=0;
        for (int r=0; r < reconstr.numRows(); ++r) {
          double my_l2=0;
          for (int c=0; c < reconstr.numCols(); ++c) {
            my_l2+=Math.pow((reconstr.vec(c).at(r) - train.vec(c).at(r)) * mymodel.model_info().data_info()._normMul[c],2);
          }
          my_l2/=reconstr.numCols();
          mean_l2+=my_l2;
        }
        mean_l2/=reconstr.numRows();
        reconstr.delete();
        sb.append("Mean reconstruction error (train): ").append(l2_train.mean()).append("\n");
        Assert.assertEquals(mymodel._output.errors.train_mse,mean_l2,1e-7);
        sb.append("The following training points are reconstructed with an error above the ").append(quantile * 100).append("-th percentile - check for \"goodness\" of training data.\n");
        double thresh_train=mymodel.calcOutlierThreshold(l2_train,quantile);
        for (long i=0; i < l2_train.length(); i++) {
          if (l2_train.at(i) > thresh_train) {
            sb.append(String.format("row %d : l2_train error = %5f\n",i,l2_train.at(i)));
          }
        }
        l2_frame_test.remove();
        l2_frame_test=mymodel.scoreAutoEncoder(test,Key.make());
        l2_test=l2_frame_test.anyVec();
        double mult=10;
        double thresh_test=mult * thresh_train;
        sb.append("\nFinding outliers.\n");
        sb.append("Mean reconstruction error (test): ").append(l2_test.mean()).append("\n");
        Frame df1=mymodel.scoreDeepFeatures(test,0);
        Assert.assertTrue(df1.numCols() == 37);
        Assert.assertTrue(df1.numRows() == test.numRows());
        df1.delete();
        Frame df2=mymodel.scoreDeepFeatures(test,1);
        Assert.assertTrue(df2.numCols() == 12);
        Assert.assertTrue(df2.numRows() == test.numRows());
        df2.delete();
        sb.append("The following test points are reconstructed with an error greater than ").append(mult).append(" times the mean reconstruction error of the training data:\n");
        HashSet<Long> outliers=new HashSet<>();
        for (long i=0; i < l2_test.length(); i++) {
          if (l2_test.at(i) > thresh_test) {
            outliers.add(i);
            sb.append(String.format("row %d : l2 error = %5f\n",i,l2_test.at(i)));
          }
        }
        Assert.assertTrue(outliers.contains(new Long(20)));
        Assert.assertTrue(outliers.contains(new Long(21)));
        Assert.assertTrue(outliers.contains(new Long(22)));
        Assert.assertTrue(outliers.size() == 3);
      }
  finally {
        Log.info(sb);
        if (mymodel != null)         mymodel.delete();
        if (l2_frame_train != null)         l2_frame_train.delete();
        if (l2_frame_test != null)         l2_frame_test.delete();
      }
    }
  }
  finally {
    if (train != null)     train.delete();
    if (test != null)     test.delete();
  }
}
