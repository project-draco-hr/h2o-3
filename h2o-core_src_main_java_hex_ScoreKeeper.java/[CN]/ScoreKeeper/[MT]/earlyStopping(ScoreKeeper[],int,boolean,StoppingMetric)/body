{
  if (k == 0)   return false;
  int len=sk.length - 1;
  if (len < 2 * k)   return false;
  boolean moreIsBetter=(criterion == StoppingMetric.AUC || criterion == StoppingMetric.r2);
  double movingAvg[]=new double[k + 1];
  double lastBeforeK=moreIsBetter ? -Double.MAX_VALUE : Double.MAX_VALUE;
  double bestInLastK=moreIsBetter ? -Double.MAX_VALUE : Double.MAX_VALUE;
  for (int i=0; i < movingAvg.length; ++i) {
    movingAvg[i]=0;
    int startIdx=sk.length - 2 * k + i;
    for (int j=0; j < k; ++j) {
      ScoreKeeper skj=sk[startIdx + j];
      double val;
switch (criterion) {
case AUC:
        val=skj._AUC;
      break;
case MSE:
    val=skj._mse;
  break;
case AUTO:
val=classification ? skj._logloss : skj._mean_residual_deviance;
break;
case logloss:
val=skj._logloss;
break;
case r2:
val=skj._r2;
break;
case misclassification:
val=skj._classError;
break;
default :
throw H2O.unimpl("Undefined stopping criterion.");
}
movingAvg[i]+=val;
}
movingAvg[i]/=k;
assert(!Double.isNaN(movingAvg[i]));
if (i == 0) lastBeforeK=movingAvg[i];
 else bestInLastK=moreIsBetter ? Math.max(movingAvg[i],bestInLastK) : Math.min(movingAvg[i],bestInLastK);
}
assert(lastBeforeK != Double.MAX_VALUE);
assert(bestInLastK != Double.MAX_VALUE);
Log.info("Moving averages (length " + k + ") of last "+ (k + 1)+ " metrics: "+ Arrays.toString(movingAvg));
boolean improved=moreIsBetter ? bestInLastK > lastBeforeK : bestInLastK < lastBeforeK;
Log.info("Checking convergence of " + criterion.getClass().getSimpleName() + ": "+ lastBeforeK+ " --> "+ bestInLastK+ (improved ? " (improved)." : " (got worse)."));
return !improved;
}
