{
  if (k == 0)   return false;
  int len=sk.length - 1;
  if (len < 2 * k)   return false;
  if (criterion == StoppingMetric.AUTO) {
    criterion=classification ? StoppingMetric.logloss : StoppingMetric.deviance;
  }
  boolean moreIsBetter=(criterion == StoppingMetric.AUC || criterion == StoppingMetric.r2);
  double movingAvg[]=new double[k + 1];
  double lastBeforeK=moreIsBetter ? -Double.MAX_VALUE : Double.MAX_VALUE;
  double bestInLastK=moreIsBetter ? -Double.MAX_VALUE : Double.MAX_VALUE;
  for (int i=0; i < movingAvg.length; ++i) {
    movingAvg[i]=0;
    int startIdx=sk.length - 2 * k + i;
    boolean zeroCrossing=false;
    for (int j=0; j < k; ++j) {
      ScoreKeeper skj=sk[startIdx + j];
      double val;
switch (criterion) {
case AUC:
        val=skj._AUC;
      break;
case MSE:
    val=skj._mse;
  break;
case deviance:
val=skj._mean_residual_deviance;
break;
case logloss:
val=skj._logloss;
break;
case r2:
val=skj._r2;
break;
case misclassification:
val=skj._classError;
break;
default :
throw H2O.unimpl("Undefined stopping criterion.");
}
movingAvg[i]+=val;
}
movingAvg[i]/=k;
assert(!Double.isNaN(movingAvg[i]));
if (i == 0) lastBeforeK=movingAvg[i];
 else bestInLastK=moreIsBetter ? Math.max(movingAvg[i],bestInLastK) : Math.min(movingAvg[i],bestInLastK);
}
assert(lastBeforeK != Double.MAX_VALUE);
assert(bestInLastK != Double.MAX_VALUE);
Log.info("Moving averages (length " + k + ") of last "+ (k + 1)+ " "+ criterion.toString()+ " metrics: "+ Arrays.toString(movingAvg));
boolean improved=moreIsBetter ? bestInLastK / lastBeforeK > 1 + rel_improvement : bestInLastK / lastBeforeK < 1 - rel_improvement;
Log.info("Checking model convergence with " + criterion.toString() + " metric: "+ lastBeforeK+ " --> "+ bestInLastK+ (improved ? " (still improving)." : " (converged)."));
return !improved;
}
