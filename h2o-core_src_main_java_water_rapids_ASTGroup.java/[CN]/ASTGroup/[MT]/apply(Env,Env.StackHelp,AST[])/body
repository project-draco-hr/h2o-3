{
  Frame fr=stk.track(asts[1].exec(env)).getFrame();
  final int ncols=fr.numCols();
  ASTNumList groupby=check(fr,asts[2]);
  final Frame fr_keys=gbFrame(fr,groupby.expand4());
  final int ngbCols=fr_keys.numCols();
  int naggs=(asts.length - 3) / 3;
  final AGG[] aggs=new AGG[naggs];
  int naggcols=0;
  for (int idx=3; idx < asts.length; idx+=3) {
    Val v=asts[idx].exec(env);
    String fn=v instanceof ValFun ? v.getFun().str() : v.getStr();
    FCN fcn=FCN.valueOf(fn);
    ASTNumList col=check(fr,asts[idx + 1]);
    if (col.cnt() != 1)     throw new IllegalArgumentException("Group-By functions take only a single column");
    int agg_col=(int)col.min();
    if (fcn == FCN.mode && !fr.vec(agg_col).isCategorical())     throw new IllegalArgumentException("Mode only allowed on categorical columns");
    NAHandling na=NAHandling.valueOf(asts[idx + 2].exec(env).getStr().toUpperCase());
    AGG agg=aggs[(idx - 3) / 3]=new AGG(fcn,agg_col,na,(int)fr.vec(agg_col).max() + 1,naggcols);
    naggcols+=agg.ncols();
  }
  IcedHashMap<GKX,String> gs=findGroups(fr_keys);
  long grs[][]=(gs == null || _testing_force_sorted) ? sortingGroup(fr_keys) : null;
  long nlgrps=grs == null ? gs.size() : ArrayUtils.maxValue(grs[0]);
  if (nlgrps > Integer.MAX_VALUE)   throw H2O.unimpl();
  int ngrps=(int)nlgrps;
  double[][] dss=new double[naggcols][ngrps];
  for (int a=0; a < naggs; a++) {
    double d=aggs[a]._fcn.initVal();
    if (d != 0)     Arrays.fill(dss[aggs[a]._aggcol],d);
  }
  long[][] nrows=new long[naggs][ngrps];
  GK0[] gkxs0;
  if (grs == null) {
    gkxs0=sortGroups(gs);
    HashingCompute hc=new HashingCompute(gs,aggs,ngbCols,dss,nrows).doAll(new Frame(fr_keys).add(fr));
    dss=hc._dss;
    nrows=hc._nrows;
  }
 else {
    throw H2O.unimpl();
  }
  final GK0[] gkxs=gkxs0;
  String[] fcnames=new String[aggs.length];
  for (int i=0; i < aggs.length; i++)   fcnames[i]=aggs[i]._fcn.toString() + "_" + fr.name(aggs[i]._col);
  final double[][] fdss=dss;
  final long[][] fnrows=nrows;
  MRTask mrfill=new MRTask(){
    @Override public void map(    Chunk[] c,    NewChunk[] ncs){
      final int start=(int)c[0].start();
      final int len=c[0]._len;
      for (int i=0; i < len; i++) {
        int gnum=i + start;
        GK0 gk0=gkxs[gnum];
        gk0.setkey(ncs);
        for (int a=0; a < aggs.length; a++)         ncs[a + ngbCols].addNum(aggs[a].postPass(fdss,gnum,fnrows[a][gnum]));
      }
    }
  }
;
  Frame f=buildOutput(fr_keys,naggs,fr,fcnames,ngrps,mrfill);
  return new ValFrame(f);
}
