def generate_main_class(endpoints):
    yield u'/**'
    yield u' * This file is auto-generated by h2o-3/h2o-bindings/bin/gen_java.py'
    yield u' * Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)'
    yield u' */'
    yield u'package water.bindings;'
    yield u''
    yield u'import water.bindings.pojos.*;'
    yield u'import water.bindings.proxies.retrofit.*;'
    yield u'import retrofit2.*;'
    yield u'import retrofit2.converter.gson.GsonConverterFactory;'
    yield u'import com.google.gson.*;'
    yield u'import com.google.gson.reflect.TypeToken;'
    yield u'import com.google.gson.stream.JsonReader;'
    yield u'import com.google.gson.stream.JsonWriter;'
    yield u'import okhttp3.OkHttpClient;'
    yield u'import java.io.IOException;'
    yield u'import java.lang.reflect.Array;'
    yield u'import java.lang.reflect.Type;'
    yield u'import java.util.concurrent.TimeUnit;'
    yield u''
    yield u'public class H2oApi {'
    yield u''
    yield u'  public H2oApi() {}'
    yield u'  public H2oApi(String url) { this.url = url; }'
    yield u''
    yield u'  public H2oApi setUrl(String s) {'
    yield u'    url = s;'
    yield u'    retrofit = null;'
    yield u'    return this;'
    yield u'  }'
    yield u''
    yield u'  public H2oApi setTimeout(int t) {'
    yield u'    timeout_s = t;'
    yield u'    retrofit = null;'
    yield u'    return this;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   * Set time interval for job polling in {@link #waitForJobCompletion(JobKeyV3)}.'
    yield u'   *   @param millis time interval, in milliseconds'
    yield u'   */'
    yield u'  public H2oApi setJobPollInterval(int millis) {'
    yield u'    pollInterval_ms = millis;'
    yield u'    return this;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   * Continuously poll server for the status of the given job, until it completes.'
    yield u'   *   @param jobKey job to query'
    yield u'   *   @return the finished job'
    yield u'   */'
    yield u'  public JobV3 waitForJobCompletion(JobKeyV3 jobKey) {'
    yield u'    return waitForJobCompletion(keyToString(jobKey));'
    yield u'  }'
    yield u'  public JobV3 waitForJobCompletion(String jobId) {'
    yield u'    Jobs jobService = getService(Jobs.class);'
    yield u'    Response<JobsV3> jobsResponse = null;'
    yield u'    int retries = 3;'
    yield u'    JobsV3 jobs = null;'
    yield u'    do {'
    yield u'      try {'
    yield u'        Thread.sleep(pollInterval_ms);'
    yield u'        jobsResponse = jobService.fetch(jobId).execute();'
    yield u'      } catch (IOException e) {'
    yield u'        System.err.println("Caught exception: " + e);'
    yield u'      } catch (InterruptedException e) { /* pass */ }'
    yield u'      if (jobsResponse == null || !jobsResponse.isSuccessful())'
    yield u'        if (retries-- > 0)'
    yield u'          continue;'
    yield u'        else'
    yield u'          throw new RuntimeException("/3/Jobs/" + jobId + " failed 3 times.");'
    yield u'      jobs = jobsResponse.body();'
    yield u'      if (jobs.jobs == null || jobs.jobs.length != 1)'
    yield u'        throw new RuntimeException("Failed to find Job: " + jobId);'
    yield u'    } while (jobs != null && jobs.jobs[0].status.equals("RUNNING"));'
    yield u'    return jobs == null? null : jobs.jobs[0];'
    yield u'  }'
    yield u''
    for route in endpoints:
        apiname = route[u'api_name']
        class_name = route[u'class_name']
        outtype = route[u'output_schema']
        input_fields = route[u'input_params']
        required_fields = [field for field in input_fields if field[u'required']]
        input_fields_wo_excluded = [field for field in input_fields if (field[u'name'] != u'_exclude_fields')]
        yield u'  /**'
        yield bi.wrap(route[u'summary'], indent=u'   * ')
        yield u'   */'
        li = len(input_fields)
        le = len(input_fields_wo_excluded)
        lr = len(required_fields)
        assert (lr <= 3), (u'Too many required fields in method ' + apiname)
        if (lr == li):
            input_fields = None
            input_fields_wo_excluded = None
        elif ((le == li) or (le == lr) or (li >= 4)):
            input_fields_wo_excluded = None
        if (u'parse' == apiname):
            required_fields = None
        for fields in [required_fields, input_fields_wo_excluded, input_fields]:
            if (fields is None):
                continue
            use_schema_param = (len(fields) >= 4)
            value_field_strs = []
            typed_field_strs = []
            for field in fields:
                ftype = translate_type(field[u'type'], field[u'schema_name'])
                fname = translate_name(field[u'name'])
                typed_field_strs.append((u'%s %s' % (ftype, fname)))
                if use_schema_param:
                    fname = (u'params.' + fname)
                if ftype.endswith(u'KeyV3'):
                    s = (u'keyToString(%s)' % fname)
                elif ftype.endswith(u'KeyV3[]'):
                    s = (u'keyArrayToStringArray(%s)' % fname)
                elif ftype.startswith(u'ColSpecifier'):
                    s = (u'colToString(%s)' % fname)
                else:
                    s = fname
                value_field_strs.append(s)
            if use_schema_param:
                args = (route[u'input_schema'] + u' params')
                values = ((u'\n      ' + u',\n      '.join(value_field_strs)) + u'\n    ')
            else:
                args = u', '.join(typed_field_strs)
                values = u', '.join(value_field_strs)
                if (fields == input_fields_wo_excluded):
                    values += u', ""'
            yield u'  public {type} {method}({args}) throws IOException {{'.format(type=outtype, method=apiname, args=args)
            yield u'    {clazz} s = getService({clazz}.class);'.format(clazz=class_name)
            yield u'    return s.{method}({values}).execute().body();'.format(method=route[u'handler_method'], values=values)
            yield u'  }'
        yield u''
    yield u''
    yield (u'  //--------- PRIVATE ' + (u'-' * 98))
    yield u''
    yield u'  private Retrofit retrofit;'
    yield u'  private String url = "http://localhost:54321/";'
    yield u'  private int timeout_s = 60;'
    yield u'  private int pollInterval_ms = 1000;'
    yield u''
    yield u'  private void initializeRetrofit() {'
    yield u'    Gson gson = new GsonBuilder()'
    yield u'      .registerTypeAdapterFactory(new ModelV3TypeAdapter())'
    yield u'      .registerTypeAdapter(KeyV3.class, new KeySerializer())'
    yield u'      .registerTypeAdapter(ColSpecifierV3.class, new ColSerializer())'
    yield u'      .registerTypeAdapter(ModelBuilderSchema.class, new ModelDeserializer())'
    yield u'      .create();'
    yield u''
    yield u'    OkHttpClient client = new OkHttpClient.Builder()'
    yield u'      .connectTimeout(timeout_s, TimeUnit.SECONDS)'
    yield u'      .writeTimeout(timeout_s, TimeUnit.SECONDS)'
    yield u'      .readTimeout(timeout_s, TimeUnit.SECONDS)'
    yield u'      .build();'
    yield u''
    yield u'    this.retrofit = new Retrofit.Builder()'
    yield u'      .client(client)'
    yield u'      .baseUrl(url)'
    yield u'      .addConverterFactory(GsonConverterFactory.create(gson))'
    yield u'      .build();'
    yield u'  }'
    yield u''
    yield u'  private Retrofit getRetrofit() {'
    yield u'    if (retrofit == null) initializeRetrofit();'
    yield u'    return retrofit;'
    yield u'  }'
    yield u''
    yield u'  private <T> T getService(Class<T> clazz) {'
    yield u'    return getRetrofit().create(clazz);'
    yield u'  }'
    yield u''
    yield u''
    yield u'  /**'
    yield u'   * Keys get sent as Strings and returned as objects also containing the type and URL,'
    yield u'   * so they need a custom GSON serializer.'
    yield u'   */'
    yield u'  private static class KeySerializer implements JsonSerializer<KeyV3>, JsonDeserializer<KeyV3> {'
    yield u'    @Override'
    yield u'    public JsonElement serialize(KeyV3 key, Type typeOfKey, JsonSerializationContext context) {'
    yield u'      return new JsonPrimitive(key.name);'
    yield u'    }'
    yield u'    @Override'
    yield u'    public KeyV3 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {'
    yield u'      if (json.isJsonNull()) return null;'
    yield u'      JsonObject jobj = json.getAsJsonObject();'
    yield u'      String type = jobj.get("type").getAsString();'
    yield u'      switch (type) {'
    yield u'        case "Key<Model>": return context.deserialize(jobj, ModelKeyV3.class);'
    yield u'        case "Key<Job>":   return context.deserialize(jobj, JobKeyV3.class);'
    yield u'        case "Key<Grid>":  return context.deserialize(jobj, GridKeyV3.class);'
    yield u'        case "Key<Frame>": return context.deserialize(jobj, FrameKeyV3.class);'
    yield u'        default: throw new JsonParseException("Unable to deserialize key of type " + type);'
    yield u'      }'
    yield u'    }'
    yield u'  }'
    yield u''
    yield u'  private static class ColSerializer implements JsonSerializer<ColSpecifierV3> {'
    yield u'    @Override'
    yield u'    public JsonElement serialize(ColSpecifierV3 col, Type typeOfCol, JsonSerializationContext context) {'
    yield u'      return new JsonPrimitive(col.columnName);'
    yield u'    }'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   * Factory method for parsing a ModelV3 json object into an instance of the model-specific subclass.'
    yield u'   */'
    yield u'  private static class ModelDeserializer implements JsonDeserializer<ModelBuilderSchema> {'
    yield u'    @Override'
    yield u'    public ModelBuilderSchema deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)'
    yield u'      throws JsonParseException {'
    yield u'      if (json.isJsonNull()) return null;'
    yield u'      if (json.isJsonObject()) {'
    yield u'        JsonObject jobj = json.getAsJsonObject();'
    yield u'        if (jobj.has("algo")) {'
    yield u'          String algo = jobj.get("algo").getAsJsonPrimitive().getAsString().toLowerCase();'
    yield u'          switch (algo) {'
    for route in endpoints:
        if ((route[u'class_name'] == u'ModelBuilders') and route[u'api_name'].startswith(u'train')):
            algo = route[u'algo']
            oschema = route[u'output_schema']
            assert (oschema.lower()[:len(algo)] == algo), (u'Wrong output schema for algo %s: %s' % (algo, oschema))
            yield u'            case "{algo}": return context.deserialize(json, {oschema}.class);'.format(**locals())
    yield u'            default:'
    yield u'              throw new JsonParseException("Unable to deserialize model of type " + algo);'
    yield u'          }'
    yield u'        }'
    yield u'      }'
    yield u'      throw new JsonParseException("Invalid ModelBuilderSchema element " + json.toString());'
    yield u'    }'
    yield u'  }'
    yield u''
    yield u'  private static class ModelV3TypeAdapter implements TypeAdapterFactory {'
    yield u'    @Override'
    yield u'    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {'
    yield u'      final Class<? super T> rawType = type.getRawType();'
    yield u'      if (!ModelBuilderSchema.class.isAssignableFrom(rawType)) return null;'
    yield u'      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);'
    yield u'      return new TypeAdapter<T>() {'
    yield u'        @Override'
    yield u'        public void write(JsonWriter out, T value) throws IOException {'
    yield u'          delegate.write(out, value);'
    yield u'        }'
    yield u'        @Override'
    yield u'        public T read(JsonReader in) throws IOException {'
    yield u'          JsonObject jobj = new JsonParser().parse(in).getAsJsonObject();'
    yield u'          if (jobj.has("parameters") && jobj.get("parameters").isJsonArray()) {'
    yield u'            JsonArray jarr = jobj.get("parameters").getAsJsonArray();'
    yield u'            JsonObject paramsNew = new JsonObject();'
    yield u'            for (JsonElement item : jarr) {'
    yield u'              JsonObject itemObj = item.getAsJsonObject();'
    yield u'              paramsNew.add(itemObj.get("name").getAsString(), itemObj.get("actual_value"));'
    yield u'            }'
    yield u'            jobj.add("parameters", paramsNew);'
    yield u'          }'
    yield u'          // noinspection unchecked'
    yield u'          return (T) new Gson().fromJson(jobj, rawType);'
    yield u'        }'
    yield u'      };'
    yield u'    }'
    yield u'  }'
    yield u''
    yield u''
    yield u'  /**'
    yield u'   * Return an array of Strings for an array of keys.'
    yield u'   */'
    yield u'  public static String[] keyArrayToStringArray(KeyV3[] keys) {'
    yield u'    if (keys == null) return null;'
    yield u'    String[] ids = new String[keys.length];'
    yield u'    int i = 0;'
    yield u'    for (KeyV3 key : keys) ids[i++] = key.name;'
    yield u'    return ids;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   * Return an array of Keys for an array of Strings. TODO: remove me'
    yield u'   */'
    yield u'  public static FrameKeyV3[] stringArrayToFrameKeyArray(String[] keys) {'
    yield u'    if (keys == null) return null;'
    yield u'    FrameKeyV3[] ids = new FrameKeyV3[keys.length];'
    yield u'    int i = 0;'
    yield u'    for (String key : keys) { FrameKeyV3 k = new FrameKeyV3(); k.name = key; ids[i++] = k; }'
    yield u'    return ids;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   * Return an array of keys from an array of Strings.'
    yield u"   * @param ids array of string ids to convert to KeyV3's"
    yield u'   * @param clz class of key objects to create. Since we have JobKeyV3, FrameKeyV3, ModelKeyV3, etc -- this'
    yield u'   *            method needs to know which of these keys you want to create'
    yield u'   */'
    yield u'  private static <T extends KeyV3> T[] stringArrayToKeyArray(String[] ids, Class<T> clz) {'
    yield u'    if (ids == null) return null;'
    yield u'    // noinspection unchecked'
    yield u'    T[] keys = (T[]) Array.newInstance(clz, ids.length);'
    yield u'    String keyType = clz.getSimpleName();'
    yield u'    if (keyType.endsWith("KeyV3")) keyType = keyType.substring(0, keyType.length()-5);'
    yield u'    try {'
    yield u'      int i = 0;'
    yield u'      for (String id: ids) {'
    yield u'        keys[i] = clz.newInstance();'
    yield u'        keys[i].name = id;'
    yield u'        keys[i].type = keyType;'
    yield u'        i++;'
    yield u'      }'
    yield u"    } catch (InstantiationException | IllegalAccessException e) { /* can't be */ }"
    yield u'    return keys;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   *'
    yield u'   */'
    yield u'  public static String keyToString(KeyV3 key) {'
    yield u'    return key == null? null : key.name;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   *'
    yield u'   */'
    yield u'  public static FrameKeyV3 stringToFrameKey(String key) {'
    yield u'    if (key == null) return null;'
    yield u'    FrameKeyV3 k = new FrameKeyV3();'
    yield u'    k.name = key;'
    yield u'    return k;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   *'
    yield u'   */'
    yield u'  private static String colToString(ColSpecifierV3 col) {'
    yield u'    return col == null? null : col.columnName;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   *'
    yield u'   */'
    yield u'  public static String stringToCol(String col) {'
    yield u'    if (col == null) return null;'
    yield u'    ColSpecifierV3 c = new ColSpecifierV3();'
    yield u'    c.columnName = col;'
    yield u'    return col;'
    yield u'  }'
    yield u''
    yield u'}'
