def generate_main_class(endpoints):
    yield textwrap.dedent(u'\n        /**\n         * This file is auto-generated by h2o-3/h2o-bindings/bin/gen_java.py\n         * Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)\n         */\n        package water.bindings;\n\n        import water.bindings.pojos.*;\n        import water.bindings.proxies.retrofit.*;\n        import retrofit2.*;\n        import retrofit2.converter.gson.GsonConverterFactory;\n        import com.google.gson.*;\n        import com.google.gson.reflect.TypeToken;\n        import com.google.gson.stream.JsonReader;\n        import com.google.gson.stream.JsonWriter;\n        import okhttp3.OkHttpClient;\n        import java.io.IOException;\n        import java.lang.reflect.Array;\n        import java.lang.reflect.Type;\n        import java.util.concurrent.TimeUnit;\n        import java.lang.reflect.Field;\n\n        public class H2oApi {\n\n          public static String DEFAULT_URL = "http://localhost:54321/";\n\n          public H2oApi() {\n              this(DEFAULT_URL);\n          }\n          public H2oApi(String url) { this.url = url; }\n\n          public H2oApi setUrl(String s) {\n            url = s;\n            retrofit = null;\n            return this;\n          }\n\n          public H2oApi setTimeout(int t) {\n            timeout_s = t;\n            retrofit = null;\n            return this;\n          }\n\n          /**\n           * Set time interval for job polling in {@link #waitForJobCompletion(JobKeyV3)}.\n           *   @param millis time interval, in milliseconds\n           */\n          public H2oApi setJobPollInterval(int millis) {\n            pollInterval_ms = millis;\n            return this;\n          }\n\n          /**\n           * Continuously poll server for the status of the given job, until it completes.\n           *   @param jobKey job to query\n           *   @return the finished job\n           */\n          public JobV3 waitForJobCompletion(JobKeyV3 jobKey) {\n            return waitForJobCompletion(keyToString(jobKey));\n          }\n          public JobV3 waitForJobCompletion(String jobId) {\n            Jobs jobService = getService(Jobs.class);\n            Response<JobsV3> jobsResponse = null;\n            int retries = 3;\n            JobsV3 jobs = null;\n            do {\n              try {\n                Thread.sleep(pollInterval_ms);\n                jobsResponse = jobService.fetch(jobId).execute();\n              } catch (IOException e) {\n                System.err.println("Caught exception: " + e);\n              } catch (InterruptedException e) { /* pass */ }\n              if (jobsResponse == null || !jobsResponse.isSuccessful())\n                if (retries-- > 0)\n                  continue;\n                else\n                  throw new RuntimeException("/3/Jobs/" + jobId + " failed 3 times.");\n              jobs = jobsResponse.body();\n              if (jobs.jobs == null || jobs.jobs.length != 1)\n                throw new RuntimeException("Failed to find Job: " + jobId);\n            } while (jobs != null && jobs.jobs[0].status.equals("RUNNING"));\n            return jobs == null? null : jobs.jobs[0];\n          }\n\n        ')
    for route in endpoints:
        apiname = route[u'api_name']
        class_name = route[u'class_name']
        outtype = route[u'output_schema']
        input_fields = route[u'input_params']
        required_fields = [field for field in input_fields if field[u'required']]
        input_fields_wo_excluded = [field for field in input_fields if (field[u'name'] != u'_exclude_fields')]
        yield u'  /**'
        yield bi.wrap(route[u'summary'], indent=u'   * ')
        yield u'   */'
        li = len(input_fields)
        le = len(input_fields_wo_excluded)
        lr = len(required_fields)
        assert (lr <= 3), (u'Too many required fields in method ' + apiname)
        if (lr == li):
            input_fields = None
            input_fields_wo_excluded = None
        elif ((le == li) or (le == lr) or (li >= 4)):
            input_fields_wo_excluded = None
        if (u'parse' == apiname):
            required_fields = None
        for fields in [required_fields, input_fields_wo_excluded, input_fields]:
            if (fields is None):
                continue
            use_schema_param = (len(fields) >= 4)
            value_field_strs = []
            typed_field_strs = []
            for field in fields:
                ftype = translate_type(field[u'type'], field[u'schema_name'])
                fname = translate_name(field[u'name'])
                typed_field_strs.append((u'%s %s' % (ftype, fname)))
                if use_schema_param:
                    fname = (u'params.' + fname)
                if ftype.endswith(u'KeyV3'):
                    s = (u'keyToString(%s)' % fname)
                elif ftype.endswith(u'KeyV3[]'):
                    s = (u'keyArrayToStringArray(%s)' % fname)
                elif ftype.startswith(u'ColSpecifier'):
                    s = (u'colToString(%s)' % fname)
                else:
                    s = fname
                value_field_strs.append(s)
            if use_schema_param:
                args = (route[u'input_schema'] + u' params')
                values = ((u'\n      ' + u',\n      '.join(value_field_strs)) + u'\n    ')
            else:
                args = u', '.join(typed_field_strs)
                values = u', '.join(value_field_strs)
                if (fields == input_fields_wo_excluded):
                    values += u', ""'
            yield u'  public {type} {method}({args}) throws IOException {{'.format(type=outtype, method=apiname, args=args)
            yield u'    {clazz} s = getService({clazz}.class);'.format(clazz=class_name)
            yield u'    return s.{method}({values}).execute().body();'.format(method=route[u'handler_method'], values=values)
            yield u'  }'
        yield u''
    yield textwrap.dedent(u'\n\n          //--------- PRIVATE " + ("-" * 98)\n\n          private Retrofit retrofit;\n          private String url = DEFAULT_URL;\n          private int timeout_s = 60;\n          private int pollInterval_ms = 1000;\n\n          private void initializeRetrofit() {\n            Gson gson = new GsonBuilder()\n              .registerTypeAdapterFactory(new ModelV3TypeAdapter())\n              .registerTypeAdapter(KeyV3.class, new KeySerializer())\n              .registerTypeAdapter(ColSpecifierV3.class, new ColSerializer())\n              .registerTypeAdapter(ModelBuilderSchema.class, new ModelDeserializer())\n              .registerTypeAdapter(ModelSchemaBaseV3.class, new ModelSchemaDeserializer())\n              .create();\n\n            OkHttpClient client = new OkHttpClient.Builder()\n              .connectTimeout(timeout_s, TimeUnit.SECONDS)\n              .writeTimeout(timeout_s, TimeUnit.SECONDS)\n              .readTimeout(timeout_s, TimeUnit.SECONDS)\n              .build();\n\n            this.retrofit = new Retrofit.Builder()\n              .client(client)\n              .baseUrl(url)\n              .addConverterFactory(GsonConverterFactory.create(gson))\n              .build();\n          }\n\n          private Retrofit getRetrofit() {\n            if (retrofit == null) initializeRetrofit();\n            return retrofit;\n          }\n\n          private <T> T getService(Class<T> clazz) {\n            return getRetrofit().create(clazz);\n          }\n\n\n          /**\n           * Keys get sent as Strings and returned as objects also containing the type and URL,\n           * so they need a custom GSON serializer.\n           */\n          private static class KeySerializer implements JsonSerializer<KeyV3>, JsonDeserializer<KeyV3> {\n            @Override\n            public JsonElement serialize(KeyV3 key, Type typeOfKey, JsonSerializationContext context) {\n              return new JsonPrimitive(key.name);\n            }\n            @Override\n            public KeyV3 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {\n              if (json.isJsonNull()) return null;\n              JsonObject jobj = json.getAsJsonObject();\n              String type = jobj.get("type").getAsString();\n              switch (type) {\n                // TODO: dynamically generate all possible cases\n                case "Key<Model>": return context.deserialize(jobj, ModelKeyV3.class);\n                case "Key<Job>":   return context.deserialize(jobj, JobKeyV3.class);\n                case "Key<Grid>":  return context.deserialize(jobj, GridKeyV3.class);\n                case "Key<Frame>": return context.deserialize(jobj, FrameKeyV3.class);\n                default: throw new JsonParseException("Unable to deserialize key of type " + type);\n              }\n            }\n          }\n\n          private static class ColSerializer implements JsonSerializer<ColSpecifierV3> {\n            @Override\n            public JsonElement serialize(ColSpecifierV3 col, Type typeOfCol, JsonSerializationContext context) {\n              return new JsonPrimitive(col.columnName);\n            }\n          }\n\n        ')
    for (clz, base, target_clz_factory) in [(u'ModelDeserializer', u'ModelBuilderSchema', (lambda schema, algo: schema)), (u'ModelSchemaDeserializer', u'ModelSchemaBaseV3', (lambda schema, algo: ((schema[:len(algo)] + u'Model') + schema[len(algo):])))]:
        yield u'  /**'
        yield (u'   * Factory method for parsing a %s json object into an instance of the model-specific subclass.' % base)
        yield u'   */'
        yield (u'  private static class %s implements JsonDeserializer<%s> {' % (clz, base))
        yield u'    @Override'
        yield (u'    public %s deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)' % base)
        yield u'      throws JsonParseException {'
        yield u'      if (json.isJsonNull()) return null;'
        yield u'      if (json.isJsonObject()) {'
        yield u'        JsonObject jobj = json.getAsJsonObject();'
        yield u'        if (jobj.has("algo")) {'
        yield u'          String algo = jobj.get("algo").getAsJsonPrimitive().getAsString().toLowerCase();'
        yield u'          switch (algo) {'
        for route in endpoints:
            if ((route[u'class_name'] == u'ModelBuilders') and route[u'api_name'].startswith(u'train')):
                algo = route[u'algo']
                oschema = route[u'output_schema']
                assert (oschema.lower()[:len(algo)] == algo), (u'Wrong output schema for algo %s: %s' % (algo, oschema))
                model = target_clz_factory(oschema, algo)
                yield u'            case "{algo}": return context.deserialize(json, {model}.class);'.format(**locals())
        yield u'            default:'
        yield u'              throw new JsonParseException("Unable to deserialize model of type " + algo);'
        yield u'          }'
        yield u'        }'
        yield u'      }'
        yield (u'      throw new JsonParseException("Invalid %s element " + json.toString());' % base)
        yield u'    }'
        yield u'  }'
        yield u''
    yield textwrap.dedent(u'\n          private static class ModelV3TypeAdapter implements TypeAdapterFactory {\n            @Override\n            public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n              final Class<? super T> rawType = type.getRawType();\n              if (!ModelBuilderSchema.class.isAssignableFrom(rawType) &&\n                  !ModelSchemaBaseV3.class.isAssignableFrom(rawType)) return null;\n              final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\n              return new TypeAdapter<T>() {\n                @Override\n                public void write(JsonWriter out, T value) throws IOException {\n                  delegate.write(out, value);\n                }\n                @Override\n                public T read(JsonReader in) throws IOException {\n                  JsonObject jobj = new JsonParser().parse(in).getAsJsonObject();\n                  if (jobj.has("parameters") && jobj.get("parameters").isJsonArray()) {\n                    JsonArray jarr = jobj.get("parameters").getAsJsonArray();\n                    JsonObject paramsNew = new JsonObject();\n                    for (JsonElement item : jarr) {\n                      JsonObject itemObj = item.getAsJsonObject();\n                      paramsNew.add(itemObj.get("name").getAsString(), itemObj.get("actual_value"));\n                    }\n                    jobj.add("parameters", paramsNew);\n                  }\n                  // noinspection unchecked\n                  return (T) new Gson().fromJson(jobj, rawType);\n                }\n              };\n            }\n          }\n\n\n          /**\n           * Return an array of Strings for an array of keys.\n           */\n          public static String[] keyArrayToStringArray(KeyV3[] keys) {\n            if (keys == null) return null;\n            String[] ids = new String[keys.length];\n            int i = 0;\n            for (KeyV3 key : keys) ids[i++] = key.name;\n            return ids;\n          }\n\n          /**\n           * Return an array of keys from an array of Strings.\n           * @param ids array of string ids to convert to KeyV3\'s\n           * @param clz class of key objects to create. Since we have JobKeyV3, FrameKeyV3, ModelKeyV3, etc -- this\n           *            method needs to know which of these keys you want to create\n           */\n          public static <T extends KeyV3> T[] stringArrayToKeyArray(String[] ids, Class<T> clz) {\n            if (ids == null) return null;\n            // noinspection unchecked\n            T[] keys = (T[]) Array.newInstance(clz, ids.length);\n            String keyType = clz.getSimpleName();\n            if (keyType.endsWith("KeyV3")) keyType = keyType.substring(0, keyType.length()-5);\n            try {\n              int i = 0;\n              for (String id: ids) {\n                keys[i] = clz.newInstance();\n                keys[i].name = id;\n                keys[i].type = keyType;\n                i++;\n              }\n            } catch (InstantiationException | IllegalAccessException e) { /* can\'t be */ }\n            return keys;\n          }\n\n          /**\n           *\n           */\n          public static String keyToString(KeyV3 key) {\n            return key == null? null : key.name;\n          }\n\n          /**\n           *\n           */\n          public static FrameKeyV3 stringToFrameKey(String key) {\n            if (key == null) return null;\n            FrameKeyV3 k = new FrameKeyV3();\n            k.name = key;\n            return k;\n          }\n\n          /**\n           *\n           */\n          private static String colToString(ColSpecifierV3 col) {\n            return col == null? null : col.columnName;\n          }\n\n          /**\n           *\n           */\n          public static String stringToCol(String col) {\n            if (col == null) return null;\n            ColSpecifierV3 c = new ColSpecifierV3();\n            c.columnName = col;\n            return col;\n          }\n\n\n          public static void copyFields(Object to, Object from) {\n            Field[] fromFields = from.getClass().getDeclaredFields();\n            Field[] toFields   = to.getClass().getDeclaredFields();\n\n            for (Field fromField : fromFields){\n              Field toField = null;\n              try {\n                toField = to.getClass().getDeclaredField(fromField.getName());\n                fromField.setAccessible(true);\n                toField.setAccessible(true);\n                toField.set(to, fromField.get(from));\n              }\n              catch (Exception e) {\n                continue; // NoSuchField is the normal case\n              }\n            }\n          }\n        }\n        ')
