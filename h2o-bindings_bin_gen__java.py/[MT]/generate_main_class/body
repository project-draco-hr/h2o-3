def generate_main_class(endpoints):
    yield u'/**'
    yield u' * This file is auto-generated by h2o-3/h2o-bindings/bin/gen_java.py'
    yield u' * Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)'
    yield u' */'
    yield u'package water.bindings;'
    yield u''
    yield u'import water.bindings.pojos.*;'
    yield u'import water.bindings.proxies.retrofit.*;'
    yield u'import retrofit2.*;'
    yield u'import retrofit2.converter.gson.GsonConverterFactory;'
    yield u'import com.google.gson.*;'
    yield u'import okhttp3.OkHttpClient;'
    yield u'import java.io.IOException;'
    yield u'import java.lang.reflect.Type;'
    yield u'import java.util.concurrent.TimeUnit;'
    yield u''
    yield u'public class H2oApi {'
    yield u''
    yield u'  public H2oApi() {}'
    yield u'  public H2oApi(String url) { this.url = url; }'
    yield u''
    yield u'  public H2oApi setUrl(String s) {'
    yield u'    url = s;'
    yield u'    retrofit = null;'
    yield u'    return this;'
    yield u'  }'
    yield u''
    yield u'  public H2oApi setTimeout(int t) {'
    yield u'    timeout_s = t;'
    yield u'    retrofit = null;'
    yield u'    return this;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   * Set time interval for job polling in {@link #waitForJobCompletion(JobKeyV3)}.'
    yield u'   *   @param millis time interval, in milliseconds'
    yield u'   */'
    yield u'  public H2oApi setJobPollInterval(int millis) {'
    yield u'    pollInterval_ms = millis;'
    yield u'    return this;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   * Continuously poll server for the status of the given job, until it completes.'
    yield u'   *   @param jobKey job to query'
    yield u'   *   @return the finished job'
    yield u'   */'
    yield u'  public JobV3 waitForJobCompletion(JobKeyV3 jobKey) {'
    yield u'    return waitForJobCompletion(keyToString(jobKey));'
    yield u'  }'
    yield u'  public JobV3 waitForJobCompletion(String jobId) {'
    yield u'    Jobs jobService = getService(Jobs.class);'
    yield u'    Response<JobsV3> jobsResponse = null;'
    yield u'    int retries = 3;'
    yield u'    JobsV3 jobs = null;'
    yield u'    do {'
    yield u'      try {'
    yield u'        Thread.sleep(pollInterval_ms);'
    yield u'        jobsResponse = jobService.fetch(jobId).execute();'
    yield u'      } catch (IOException e) {'
    yield u'        System.err.println("Caught exception: " + e);'
    yield u'      } catch (InterruptedException e) { /* pass */ }'
    yield u'      if (jobsResponse == null || !jobsResponse.isSuccessful())'
    yield u'        if (retries-- > 0)'
    yield u'          continue;'
    yield u'        else'
    yield u'          throw new RuntimeException("/3/Jobs/" + jobId + " failed 3 times.");'
    yield u'      jobs = jobsResponse.body();'
    yield u'      if (jobs.jobs == null || jobs.jobs.length != 1)'
    yield u'        throw new RuntimeException("Failed to find Job: " + jobId);'
    yield u'    } while (jobs != null && jobs.jobs[0].status.equals("RUNNING"));'
    yield u'    return jobs == null? null : jobs.jobs[0];'
    yield u'  }'
    yield u''
    for route in endpoints:
        apiname = route[u'api_name']
        class_name = route[u'class_name']
        outtype = route[u'output_schema']
        input_fields = route[u'input_params']
        required_fields = [field for field in input_fields if field[u'required']]
        input_fields_wo_excluded = [field for field in input_fields if (field[u'name'] != u'_exclude_fields')]
        yield u'  /**'
        yield bi.wrap(route[u'summary'], indent=u'   * ')
        yield u'   */'
        li = len(input_fields)
        le = len(input_fields_wo_excluded)
        lr = len(required_fields)
        assert (lr <= 3), (u'Too many required fields in method ' + apiName)
        if (lr == li):
            input_fields = None
            input_fields_wo_excluded = None
        elif ((le == li) or (le == lr) or (li >= 4)):
            input_fields_wo_excluded = None
        for fields in [required_fields, input_fields_wo_excluded, input_fields]:
            if (fields is None):
                continue
            use_schema_param = (len(fields) >= 4)
            value_field_strs = []
            typed_field_strs = []
            for field in fields:
                ftype = translate_type(field[u'type'], field[u'schema_name'])
                fname = translate_name(field[u'name'])
                typed_field_strs.append((u'%s %s' % (ftype, fname)))
                if use_schema_param:
                    fname = (u'params.' + fname)
                if ftype.endswith(u'KeyV3'):
                    s = (u'keyToString(%s)' % fname)
                elif ftype.endswith(u'KeyV3[]'):
                    s = (u'keyArrayToStringArray(%s)' % fname)
                elif ftype.startswith(u'ColSpecifier'):
                    s = (u'colToString(%s)' % fname)
                else:
                    s = fname
                value_field_strs.append(s)
            if use_schema_param:
                args = (route[u'input_schema'] + u' params')
                values = ((u'\n      ' + u',\n      '.join(value_field_strs)) + u'\n    ')
            else:
                args = u', '.join(typed_field_strs)
                values = u', '.join(value_field_strs)
                if (fields == input_fields_wo_excluded):
                    values += u', ""'
            yield u'  public {type} {method}({args}) throws IOException {{'.format(type=outtype, method=apiname, args=args)
            yield u'    {clazz} s = getService({clazz}.class);'.format(clazz=class_name)
            yield u'    return s.{method}({values}).execute().body();'.format(method=route[u'handler_method'], values=values)
            yield u'  }'
        yield u''
    yield u''
    yield (u'  //--------- PRIVATE ' + (u'-' * 98))
    yield u''
    yield u'  private Retrofit retrofit;'
    yield u'  private String url = "http://localhost/54321/";'
    yield u'  private int timeout_s = 60;'
    yield u'  private int pollInterval_ms = 1000;'
    yield u''
    yield u'  private void initializeRetrofit() {'
    yield u'    Gson gson = new GsonBuilder()'
    yield u'      .registerTypeAdapter(KeyV3.class, new KeySerializer())'
    yield u'      .registerTypeAdapter(ColSpecifierV3.class, new ColSerializer())'
    yield u'      .registerTypeAdapter(ModelsV3.class, new ModelDeserializer())'
    yield u'      .create();'
    yield u''
    yield u'    OkHttpClient client = new OkHttpClient.Builder()'
    yield u'      .connectTimeout(timeout_s, TimeUnit.SECONDS)'
    yield u'      .writeTimeout(timeout_s, TimeUnit.SECONDS)'
    yield u'      .readTimeout(timeout_s, TimeUnit.SECONDS)'
    yield u'      .build();'
    yield u''
    yield u'    this.retrofit = new Retrofit.Builder()'
    yield u'      .client(client)'
    yield u'      .baseUrl(url)'
    yield u'      .addConverterFactory(GsonConverterFactory.create(gson))'
    yield u'      .build();'
    yield u'  }'
    yield u''
    yield u'  private Retrofit getRetrofit() {'
    yield u'    if (retrofit == null) initializeRetrofit();'
    yield u'    return retrofit;'
    yield u'  }'
    yield u''
    yield u'  private <T> T getService(Class<T> clazz) {'
    yield u'    return getRetrofit().create(clazz);'
    yield u'  }'
    yield u''
    yield u''
    yield u'  /**'
    yield u'   * Keys get sent as Strings and returned as objects also containing the type and URL,'
    yield u'   * so they need a custom GSON serializer.'
    yield u'   */'
    yield u'  private static class KeySerializer implements JsonSerializer<KeyV3> {'
    yield u'    @Override'
    yield u'    public JsonElement serialize(KeyV3 key, Type typeOfKey, JsonSerializationContext context) {'
    yield u'      return new JsonPrimitive(key.name);'
    yield u'    }'
    yield u'  }'
    yield u'  private static class ColSerializer implements JsonSerializer<ColSpecifierV3> {'
    yield u'    @Override'
    yield u'    public JsonElement serialize(ColSpecifierV3 col, Type typeOfCol, JsonSerializationContext context) {'
    yield u'      return new JsonPrimitive(col.columnName);'
    yield u'    }'
    yield u'  }'
    yield u'  /**'
    yield u'   * Factory method for parsing a ModelsV3 json object into an instance of the model-specific subclass.'
    yield u'   */'
    yield u'  private static class ModelDeserializer implements JsonDeserializer<ModelsV3> {'
    yield u'    @Override'
    yield u'    public ModelsV3 deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)'
    yield u'      throws JsonParseException {'
    yield u'      if (json.isJsonNull()) return null;'
    yield u'      if (json.isJsonObject()) {'
    yield u'        JsonObject jobj = json.getAsJsonObject();'
    yield u'        if (jobj.has("algo")) {'
    yield u'          String algo = jobj.get("algo").getAsJsonPrimitive().getAsString().toLowerCase();'
    yield u'          switch (algo) {'
    for route in endpoints:
        if ((route[u'class_name'] == u'ModelBuilders') and route[u'api_name'].startswith(u'train')):
            algo = route[u'algo']
            oschema = route[u'output_schema']
            assert (oschema.lower()[:len(algo)] == algo), (u'Wrong output schema for algo %s: %s' % (algo, oschema))
            model = ((oschema[:len(algo)] + u'Model') + oschema[len(algo):])
            yield u'            case "{algo}": return context.deserialize(json, {model}.class);'.format(**locals())
    yield u'            default:'
    yield u'              throw new JsonParseException("Unable to deserialize model of type " + algo);'
    yield u'          }'
    yield u'        }'
    yield u'      }'
    yield u'      throw new JsonParseException("Invalid ModelsV3 element " + json.toString());'
    yield u'    }'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   * Return an array of Strings for an array of keys.'
    yield u'   */'
    yield u'  private static String[] keyArrayToStringArray(KeyV3[] keys) {'
    yield u'    if (keys == null) return null;'
    yield u'    String[] ids = new String[keys.length];'
    yield u'    int i = 0;'
    yield u'    for (KeyV3 key : keys) ids[i++] = key.name;'
    yield u'    return ids;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   *'
    yield u'   */'
    yield u'  private static String keyToString(KeyV3 key) {'
    yield u'    return key == null? null : key.name;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   *'
    yield u'   */'
    yield u'  private static String colToString(ColSpecifierV3 col) {'
    yield u'    return col == null? null : col.columnName;'
    yield u'  }'
    yield u''
    yield u'}'
