def generate_main_class(endpoints, schemas_map):
    yield u'/**'
    yield u' * This file is auto-generated by h2o-3/h2o-bindings/bin/gen_java.py'
    yield u' * Copyright 2016 H2O.ai;  Apache License Version 2.0 (see LICENSE for details)'
    yield u' */'
    yield u'package water.bindings;'
    yield u''
    yield u'import water.bindings.pojos.*;'
    yield u'import water.bindings.proxies.retrofit.*;'
    yield u'import retrofit2.*;'
    yield u'import retrofit2.converter.gson.GsonConverterFactory;'
    yield u'import com.google.gson.*;'
    yield u'import okhttp3.OkHttpClient;'
    yield u'import java.io.IOException;'
    yield u'import java.lang.reflect.Type;'
    yield u'import java.util.concurrent.TimeUnit;'
    yield u''
    yield u'public class H2oApi {'
    yield u''
    yield u'  public H2oApi() {}'
    yield u'  public H2oApi(String url) { this.url = url; }'
    yield u''
    yield u'  public void setUrl(String s) {'
    yield u'    url = s;'
    yield u'    retrofit = null;'
    yield u'  }'
    yield u''
    yield u'  public void setTimeout(int t) {'
    yield u'    timeout_s = t;'
    yield u'    retrofit = null;'
    yield u'  }'
    yield u''
    for route in endpoints:
        apiname = route[u'api_name']
        class_name = route[u'class_name']
        outtype = route[u'output_schema']
        input_fields = route[u'input_params']
        required_fields = [field for field in input_fields if field[u'required']]
        input_fields_wo_excluded = [field for field in input_fields if (field[u'name'] != u'_exclude_fields')]
        yield u'  /**'
        yield bi.wrap(route[u'summary'], indent=u'   * ')
        yield u'   */'
        li = len(input_fields)
        le = len(input_fields_wo_excluded)
        lr = len(required_fields)
        assert (lr <= 3), (u'Too many required fields in method ' + apiName)
        if (lr == li):
            input_fields = None
            input_fields_wo_excluded = None
        elif ((le == li) or (le == lr) or (li >= 4)):
            input_fields_wo_excluded = None
        for fields in [required_fields, input_fields_wo_excluded, input_fields]:
            if (fields is None):
                continue
            use_schema_param = (len(fields) >= 4)
            value_field_strs = []
            typed_field_strs = []
            for field in fields:
                ftype = translate_type(field[u'type'], field[u'schema_name'])
                fname = translate_name(field[u'name'])
                typed_field_strs.append((u'%s %s' % (ftype, fname)))
                if use_schema_param:
                    fname = (u'params.' + fname)
                if ftype.endswith(u'KeyV3'):
                    s = (u'keyToString(%s)' % fname)
                elif ftype.endswith(u'KeyV3[]'):
                    s = (u'keyArrayToStringArray(%s)' % fname)
                elif ftype.startswith(u'ColSpecifier'):
                    s = (u'colToString(%s)' % fname)
                else:
                    s = fname
                value_field_strs.append(s)
            if use_schema_param:
                args = (route[u'input_schema'] + u' params')
                values = ((u'\n      ' + u',\n      '.join(value_field_strs)) + u'\n    ')
            else:
                args = u', '.join(typed_field_strs)
                values = u', '.join(value_field_strs)
                if (fields == input_fields_wo_excluded):
                    values += u', ""'
            yield u'  public {type} {method}({args}) throws IOException {{'.format(type=outtype, method=apiname, args=args)
            yield u'    {clazz} s = getService({clazz}.class);'.format(clazz=class_name)
            yield u'    return s.{method}({values}).execute().body();'.format(method=route[u'handler_method'], values=values)
            yield u'  }'
        yield u''
    yield u''
    yield (u'  //--------- PRIVATE ' + (u'-' * 98))
    yield u''
    yield u'  private Retrofit retrofit;'
    yield u'  private String url = "http://localhost/54321/";'
    yield u'  private int timeout_s = 60;'
    yield u''
    yield u'  private void initializeRetrofit() {'
    yield u'    Gson gson = new GsonBuilder()'
    yield u'      .registerTypeAdapter(KeyV3.class, new KeySerializer())'
    yield u'      .registerTypeAdapter(ColSpecifierV3.class, new ColSerializer())'
    yield u'      .create();'
    yield u''
    yield u'    OkHttpClient client = new OkHttpClient.Builder()'
    yield u'      .connectTimeout(timeout_s, TimeUnit.SECONDS)'
    yield u'      .writeTimeout(timeout_s, TimeUnit.SECONDS)'
    yield u'      .readTimeout(timeout_s, TimeUnit.SECONDS)'
    yield u'      .build();'
    yield u''
    yield u'    this.retrofit = new Retrofit.Builder()'
    yield u'      .client(client)'
    yield u'      .baseUrl(url)'
    yield u'      .addConverterFactory(GsonConverterFactory.create(gson))'
    yield u'      .build();'
    yield u'  }'
    yield u''
    yield u'  private Retrofit getRetrofit() {'
    yield u'    if (retrofit == null) initializeRetrofit();'
    yield u'    return retrofit;'
    yield u'  }'
    yield u''
    yield u'  private <T> T getService(Class<T> clazz) {'
    yield u'    return getRetrofit().create(clazz);'
    yield u'  }'
    yield u''
    yield u''
    yield u'  /**'
    yield u'   * Keys get sent as Strings and returned as objects also containing the type and URL,'
    yield u'   * so they need a custom GSON serializer.'
    yield u'   */'
    yield u'  private static class KeySerializer implements JsonSerializer<KeyV3> {'
    yield u'    public JsonElement serialize(KeyV3 key, Type typeOfKey, JsonSerializationContext context) {'
    yield u'      return new JsonPrimitive(key.name);'
    yield u'    }'
    yield u'  }'
    yield u'  private static class ColSerializer implements JsonSerializer<ColSpecifierV3> {'
    yield u'    public JsonElement serialize(ColSpecifierV3 col, Type typeOfCol, JsonSerializationContext context) {'
    yield u'      return new JsonPrimitive(col.columnName);'
    yield u'    }'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   * Return an array of Strings for an array of keys.'
    yield u'   */'
    yield u'  private static String[] keyArrayToStringArray(KeyV3[] keys) {'
    yield u'    if (keys == null) return null;'
    yield u'    String[] ids = new String[keys.length];'
    yield u'    int i = 0;'
    yield u'    for (KeyV3 key : keys) ids[i++] = key.name;'
    yield u'    return ids;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   *'
    yield u'   */'
    yield u'  private static String keyToString(KeyV3 key) {'
    yield u'    return key == null? null : key.name;'
    yield u'  }'
    yield u''
    yield u'  /**'
    yield u'   *'
    yield u'   */'
    yield u'  private static String colToString(ColSpecifierV3 col) {'
    yield u'    return col == null? null : col.columnName;'
    yield u'  }'
    yield u''
    yield u'}'
