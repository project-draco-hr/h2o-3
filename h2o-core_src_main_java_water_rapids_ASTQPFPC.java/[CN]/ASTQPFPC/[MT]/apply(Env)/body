{
  Frame f=e.popAry();
  Vec classVec=f.vecs()[_cidx];
  for (  Vec v : f.vecs()) {
    if (v == classVec)     continue;
    if (!v.isNumeric())     throw new IllegalArgumentException("Columns must be numeric!");
  }
  final int nclasses=classVec.domain().length;
  long[] selectValues=new long[nclasses];
  for (int i=0; i < selectValues.length; ++i)   selectValues[i]=i;
  String[] colnames=new String[f.numCols() - 1];
  String exName=f._names[_cidx];
  int p=0;
  for (int i=0; i < colnames.length; ++i)   if (!exName.equals(f._names[i]))   colnames[p++]=f._names[i];
  Vec[] vecs=new Vec[f.numCols() - 1];
  int i=0;
  for (  Vec v : f.vecs())   if (v != classVec)   vecs[i++]=v;
  ParallelSubsetTask t;
  H2O.submitTask(t=new ParallelSubsetTask(vecs,classVec,selectValues,_probs,colnames,classVec.domain())).join();
  final double[][][] dist=t._dist;
  final String[] rownames=ArrayUtils.flat(t._rownames);
  Vec layout=Vec.makeZero(vecs.length * nclasses);
  Vec[] resultVecs=new Vec[1 + _probs.length];
  resultVecs[0]=layout.makeCopy(rownames,Vec.T_ENUM);
  for (int j=1; j < resultVecs.length; ++j)   resultVecs[j]=layout.makeCopy(null);
  String[] names=new String[1 + _probs.length];
  names[0]="rownames";
  for (int j=1; j < names.length; ++j)   names[j]="X" + _probs[j - 1];
  Frame fr2=new Frame(names,resultVecs);
  new MRTask(){
    @Override public void map(    Chunk[] c){
      long start=c[0].start();
      int i, j;
      for (int r=0; r < c[0]._len; ++r) {
        i=(int)(r + start) / nclasses;
        j=(int)(r + start) % nclasses;
        c[0].set(r,r + start);
        for (int v=1; v < c.length; ++v)         c[v].set(r,dist[i][j][v - 1]);
      }
    }
  }
.doAll(fr2);
  layout.remove();
  e.pushAry(fr2);
}
