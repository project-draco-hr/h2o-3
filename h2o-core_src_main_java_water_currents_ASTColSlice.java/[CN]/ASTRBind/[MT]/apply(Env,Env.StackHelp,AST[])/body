{
  Frame fr=null;
  int nchks=0;
  Val vals[]=new Val[asts.length];
  for (int i=1; i < asts.length; i++) {
    vals[i]=stk.track(asts[i].exec(env));
    if (vals[i].isFrame()) {
      fr=vals[i].getFrame();
      nchks+=fr.anyVec().nChunks();
    }
 else     nchks++;
  }
  Vec zz=null;
  if (fr == null) {
    fr=new Frame(new String[]{Frame.defaultColName(0)},new Vec[]{zz=Vec.makeZero(0)});
    if (asts.length == 1)     return new ValFrame(fr);
  }
  final Frame frs[]=new Frame[asts.length];
  final byte[] types=fr.types();
  final int ncols=fr.numCols();
  final long[] espc=new long[nchks + 1];
  int coffset=0;
  for (int i=1; i < asts.length; i++) {
    Val val=vals[i];
    Frame fr0=val.isFrame() ? val.getFrame() : stk.track(new Frame(fr._names,Vec.makeCons(val.getNum(),1L,fr.numCols())));
    if (fr.numCols() != fr0.numCols())     throw new IllegalArgumentException("rbind frames must have all the same columns, found " + fr.numCols() + " and "+ fr0.numCols()+ " columns.");
    if (!Arrays.deepEquals(fr._names,fr0._names))     throw new IllegalArgumentException("rbind frames must have all the same column names, found " + Arrays.toString(fr._names) + " and "+ Arrays.toString(fr0._names));
    if (!Arrays.equals(types,fr0.types()))     throw new IllegalArgumentException("rbind frames must have all the same column types, found " + Arrays.toString(types) + " and "+ Arrays.toString(fr0.types()));
    frs[i]=fr0;
    long roffset=espc[coffset];
    long[] espc2=fr0.anyVec().get_espc();
    for (int j=1; j < espc2.length; j++)     espc[coffset + j]=(roffset + espc2[j]);
    coffset+=espc2.length - 1;
  }
  if (zz != null)   zz.remove();
  Key<Vec>[] keys=fr.anyVec().group().addVecs(fr.numCols());
  Vec[] vecs=new Vec[fr.numCols()];
  for (int i=0; i < vecs.length; i++)   vecs[i]=new Vec(keys[i],espc,null,types[i]);
  ParallelRbinds t;
  H2O.submitTask(t=new ParallelRbinds(frs,espc,vecs)).join();
  return new ValFrame(new Frame(fr.names(),t._vecs));
}
