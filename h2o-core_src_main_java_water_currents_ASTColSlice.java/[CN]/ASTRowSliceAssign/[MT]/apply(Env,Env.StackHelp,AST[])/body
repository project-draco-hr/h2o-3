{
  Frame dst=stk.track(asts[1].exec(env)).getFrame();
  Vec[] dvecs=dst.vecs();
  ASTNumList nlist;
  if (asts[3] instanceof ASTNumList) {
    nlist=(ASTNumList)asts[3];
  }
 else   if ((asts[3] instanceof ASTNum)) {
    nlist=new ASTNumList(asts[2].exec(env).getNum());
  }
 else   throw new IllegalArgumentException("Requires a number-list as the last argument, but found a " + asts[3].getClass());
  if (!(0 <= nlist.min() && nlist.max() <= dst.numRows()))   throw new IllegalArgumentException("Row must be an integer from 0 to " + (dst.numRows() - 1));
  long nrows=nlist.cnt();
  Val vsrc=stk.track(asts[2].exec(env));
  if (vsrc.isFrame()) {
    Frame src=vsrc.getFrame();
    if (dst.numCols() != src.numCols())     throw new IllegalArgumentException("Source and destination frames must have the same count and type of columns");
    Vec[] svecs=src.vecs();
    for (int col=0; col < dvecs.length; col++)     if (dvecs[col].get_type() != svecs[col].get_type())     throw new IllegalArgumentException("Columns must be the same type; column " + col + ", \'"+ dst._names[col]+ "\', is of type "+ dvecs[col].get_type_str()+ " and the source is "+ svecs[col].get_type_str());
    if (src.numRows() != nrows)     throw new IllegalArgumentException("Requires same count of rows in the number-list (" + nrows + ") as in the source ("+ src.numRows()+ ")");
    if (nrows == 1) {
      replace_row(dvecs,(long)nlist.expand()[0],svecs,0);
      return new ValFrame(dst);
    }
    throw water.H2O.unimpl();
  }
 else   if (vsrc.isNum()) {
    final double d=vsrc.getNum();
    if (nrows == 1) {
      replace_row(dvecs,(long)nlist.expand()[0],d);
      return new ValFrame(dst);
    }
    final ASTNumList nums=nlist;
    new MRTask(){
      @Override public void map(      Chunk[] cs){
        long start=cs[0].start();
        long end=start + cs[0]._len;
        double min=nums.min(), max=nums.max() - 1;
        if (!(max < start || min > end)) {
          int startOffset=(int)(min > start ? min : start);
          for (int i=startOffset; i < cs[0]._len; ++i)           if (nums.has(start + i))           for (int c=0; c < cs.length; ++c)           cs[c].set(i,d);
        }
      }
    }
.doAll(dst);
    return new ValFrame(dst);
  }
  throw new IllegalArgumentException("Source must be a Frame or Number, but found a " + vsrc.getClass());
}
