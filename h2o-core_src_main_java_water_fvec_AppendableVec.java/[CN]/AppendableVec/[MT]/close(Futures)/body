{
  int nchunk=_tmp_espc.length;
  DKV.remove(chunkKey(nchunk),fs);
  while (nchunk > 1 && _tmp_espc[nchunk - 1] == 0) {
    nchunk--;
    DKV.remove(chunkKey(nchunk),fs);
  }
  int[] ctypes=new int[STRING + 1];
  for (int i=0; i < nchunk; ++i)   ctypes[_chunkTypes[i]]++;
  boolean genEnumCol=false;
  if (ctypes[ENUM] == 0 && ctypes[TIME] == 0 && ctypes[UUID] == 0 && ctypes[STRING] == 0)   genEnumCol=true;
  if (domain() != null && (genEnumCol || ctypes[ENUM] > ctypes[NUMBER])) {
    ctypes[ENUM]+=ctypes[NUMBER];
    ctypes[NUMBER]=0;
    ctypes[ENUM]+=ctypes[NA];
    ctypes[NA]=0;
    if (nchunk == 0)     ctypes[ENUM]++;
  }
  int idx=0;
  for (int i=0; i < ctypes.length; i++)   if (i != NA && ctypes[i] > ctypes[idx])   idx=i;
  if (idx != ENUM)   setDomain(null);
  for (int i=0; i < nchunk; ++i)   if (_chunkTypes[i] != idx && !(idx == ENUM && _chunkTypes[i] == NUMBER && genEnumCol))   DKV.put(chunkKey(i),new C0DChunk(Double.NaN,(int)_tmp_espc[i]),fs);
  byte type;
switch (idx) {
case ENUM:
    type=T_ENUM;
  break;
case NUMBER:
type=T_NUM;
break;
case TIME:
type=T_TIME;
break;
case UUID:
type=T_UUID;
break;
case STRING:
type=T_STR;
break;
default :
type=T_BAD;
break;
}
long espc[]=new long[nchunk + 1];
long x=0;
for (int i=0; i < nchunk; i++) {
espc[i]=x;
x+=_tmp_espc[i];
}
espc[nchunk]=x;
Vec vec=new Vec(_key,espc,domain(),type);
DKV.put(_key,vec,fs);
return vec;
}
