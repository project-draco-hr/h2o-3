{
  for (  Chunk c : chunks)   if (_skipMissing && c.isNA(rid)) {
    row.good=false;
    return row;
  }
  int numStart=numStart();
  for (int i=0; i < _cats; ++i) {
    int c;
    if (chunks[i].isNA(rid)) {
      row.binIds[row.nBins++]=_catOffsets[i + 1] - 1;
    }
 else {
      c=getCategoricalId(i,(int)chunks[i].at8(rid));
      if (c >= 0)       row.binIds[row.nBins++]=c;
    }
  }
  final int n=chunks.length - _responses;
  for (int i=0; i < n; ++i) {
    double d=chunks[i].atd(rid);
    if (_normMul != null)     d=(d - _normSub[i - _cats]) * _normMul[i - _cats];
    row.numVals[i + numStart]=d;
  }
  for (int i=0; i < _responses; ++i) {
    row.response[i]=chunks[chunks.length - _responses + i].atd(rid);
    if (_normRespMul != null)     row.response[i]=(row.response[i] - _normRespSub[i]) * _normRespMul[i];
    if (Double.isNaN(row.response[i])) {
      row.good=false;
      return row;
    }
  }
  row.good=true;
  return row;
}
