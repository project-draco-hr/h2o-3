{
  row.bad=false;
  row.rid=rid + chunks[0].start();
  row.cid=rid;
  if (_weights)   row.weight=chunks[weightChunkId()].atd(rid);
  if (row.weight == 0)   return row;
  if (_skipMissing)   for (  Chunk c : chunks)   if (c.isNA(rid)) {
    row.bad=true;
    return row;
  }
  int nbins=0;
  for (int i=0; i < _cats; ++i) {
    if (chunks[i].isNA(rid)) {
      if (_imputeMissing) {
        int c=getCategoricalId(i,_catModes[i]);
        if (c >= 0)         row.binIds[nbins++]=c;
      }
 else       row.binIds[nbins++]=_catOffsets[i + 1] - 1;
    }
 else {
      int c=getCategoricalId(i,(int)chunks[i].at8(rid));
      if (c >= 0)       row.binIds[nbins++]=c;
    }
  }
  row.nBins=nbins;
  final int n=_nums;
  for (int i=0; i < n; ++i) {
    double d=chunks[_cats + i].atd(rid);
    if (_imputeMissing && Double.isNaN(d))     d=_numMeans[i];
    if (_normMul != null && _normSub != null)     d=(d - _normSub[i]) * _normMul[i];
    row.numVals[i]=d;
  }
  for (int i=0; i < _responses; ++i) {
    try {
      row.response[i]=chunks[responseChunkId(i)].atd(rid);
    }
 catch (    Throwable t) {
      throw new RuntimeException(t);
    }
    if (_normRespMul != null)     row.response[i]=(row.response[i] - _normRespSub[i]) * _normRespMul[i];
    if (Double.isNaN(row.response[i])) {
      row.bad=true;
      return row;
    }
  }
  if (_offset)   row.offset=chunks[offsetChunkId()].atd(rid);
  return row;
}
