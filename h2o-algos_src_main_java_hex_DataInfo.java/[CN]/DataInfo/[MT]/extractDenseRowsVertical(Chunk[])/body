{
  Row[] rows=new Row[chunks[0]._len];
  long start=chunks[0].start();
  for (int i=0; i < rows.length; ++i) {
    rows[i]=new Row(false,_nums,_cats,_responses,i,start);
    if (_offset) {
      rows[i].offset=chunks[offsetChunkId()].atd(i);
      if (Double.isNaN(rows[i].offset))       rows[i].bad=true;
    }
    if (_weights) {
      rows[i].weight=chunks[weightChunkId()].atd(i);
      if (Double.isNaN(rows[i].weight))       rows[i].bad=true;
    }
  }
  for (int i=0; i < _cats; ++i) {
    for (int r=0; r < chunks[0]._len; ++r) {
      Row row=rows[r];
      if (row.bad)       continue;
      if (chunks[i].isNA(r)) {
        if (_skipMissing) {
          row.bad=true;
        }
 else         row.binIds[row.nBins++]=_catOffsets[i + 1] - 1;
      }
 else {
        int c=getCategoricalId(i,(int)chunks[i].at8(r));
        if (c >= 0)         row.binIds[row.nBins++]=c;
      }
    }
  }
  int numStart=numStart();
  for (int cid=0; cid < _nums; ++cid) {
    Chunk c=chunks[_cats + cid];
    for (int r=0; r < c._len; ++r) {
      Row row=rows[r];
      if (row.bad)       continue;
      if (c.isNA(r))       row.bad=_skipMissing;
      double d=c.atd(r);
      if (_normMul != null && _normSub != null)       d=(d - _normSub[cid]) * _normMul[cid];
      row.numVals[numStart + cid]=d;
    }
  }
  for (int i=1; i <= _responses; ++i) {
    Chunk rChunk=chunks[responseChunkId(i - 1)];
    for (int r=0; r < chunks[0]._len; ++r) {
      Row row=rows[r];
      if (row.bad)       continue;
      row.response[row.response.length - i]=rChunk.atd(r);
      if (_normRespMul != null) {
        row.response[i - 1]=(row.response[i - 1] - _normRespSub[i - 1]) * _normRespMul[i - 1];
      }
      if (Double.isNaN(row.response[row.response.length - i]))       row.bad=true;
    }
  }
  return rows;
}
