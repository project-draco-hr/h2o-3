{
  if (!_skipMissing)   throw H2O.unimpl();
  Row[] rows=new Row[chunks[0]._len];
  double etaOffset=0;
  if (_normMul != null)   for (int i=0; i < _nums; ++i)   etaOffset-=beta[i] * _normSub[i] * _normMul[i];
  for (int i=0; i < rows.length; ++i)   rows[i]=new Row(true,Math.max(_bins >> 10,16) + _cats,Math.max(16,(_nums - _bins) >> 10),_responses,etaOffset);
  for (int i=0; i < _cats; ++i) {
    for (int r=0; r < chunks[0]._len; ++r) {
      Row row=rows[r];
      if (row.good)       continue;
      if (chunks[i].isNA(r)) {
        if (_skipMissing) {
          row.good=true;
          continue;
        }
        row.binIds[row.nBins++]=_catOffsets[i + 1] - 1;
      }
 else {
        int c=getCategoricalId(i,(int)chunks[i].at8(r));
        if (c >= 0)         row.binIds[row.nBins++]=c;
      }
    }
  }
  int numStart=numStart();
  for (int cid=0; cid < _bins; ++cid) {
    Chunk c=chunks[cid + _cats];
    for (int r=c.nextNZ(-1); r < c._len; r=c.nextNZ(r)) {
      Row row=rows[r];
      if (row.good)       continue;
      if (c.isNA(r)) {
        row.good=_skipMissing;
        continue;
      }
      row.addBinId(cid + numStart);
    }
  }
  for (int cid=0; cid < _nums; ++cid) {
    Chunk c=chunks[_cats + cid];
    for (int r=c.nextNZ(-1); r < c._len; r=c.nextNZ(r)) {
      Row row=rows[r];
      if (c.isNA(r))       row.good=_skipMissing;
      if (row.good)       continue;
      if (_normMul != null)       row.addNum(cid + numStart + _bins,c.atd(r) * _normMul[cid]);
    }
  }
  for (int r=0; r < chunks[0]._len; ++r) {
    Row row=rows[r];
    for (int i=1; i <= _responses; ++i) {
      row.response[row.response.length - i]=chunks[chunks.length - 1].atd(r);
      if (_normRespMul != null)       row.response[i]=(row.response[i] - _normRespSub[i]) * _normRespMul[i];
      if (Double.isNaN(row.response[row.response.length - i]))       row.good=true;
    }
  }
  return rows;
}
