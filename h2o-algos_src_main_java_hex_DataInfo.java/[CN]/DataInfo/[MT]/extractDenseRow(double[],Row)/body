{
  row.bad=false;
  row.rid=0;
  row.cid=0;
  if (row.weight == 0)   return row;
  if (_skipMissing)   for (  double d : vals)   if (Double.isNaN(d)) {
    row.bad=true;
    return row;
  }
  int nbins=0;
  for (int i=0; i < _cats; ++i) {
    int c=getCategoricalId(i,Double.isNaN(vals[i]) ? _catModes[i] : (int)vals[i]);
    if (c >= 0)     row.binIds[nbins++]=c;
  }
  row.nBins=nbins;
  final int n=_nums;
  for (int i=0; i < n; ++i) {
    if (isInteractionVec(i)) {
      int offset;
      InteractionWrappedVec iwv=((InteractionWrappedVec)_adaptedFrame.vec(_cats + i));
      int v1=_adaptedFrame.find(iwv.v1());
      int v2=_adaptedFrame.find(iwv.v2());
      if (v1 < _cats)       offset=getCategoricalId(v1,Double.isNaN(vals[v1]) ? _catModes[v1] : (int)vals[v1]);
 else       if (v2 < _cats)       offset=getCategoricalId(v2,Double.isNaN(vals[v2]) ? _catModes[v1] : (int)vals[v2]);
 else       offset=0;
      row.numVals[i + offset]=vals[_cats + i];
    }
    double d=vals[_cats + i];
    if (Double.isNaN(d))     d=_numMeans[i];
    if (_normMul != null && _normSub != null)     d=(d - _normSub[i]) * _normMul[i];
    row.numVals[i]=d;
  }
  int off=responseChunkId(0);
  for (int i=off; i < Math.min(vals.length,off + _responses); ++i) {
    try {
      row.response[i]=vals[responseChunkId(i)];
    }
 catch (    Throwable t) {
      throw new RuntimeException(t);
    }
    if (_normRespMul != null)     row.response[i]=(row.response[i] - _normRespSub[i]) * _normRespMul[i];
    if (Double.isNaN(row.response[i])) {
      row.bad=true;
      return row;
    }
  }
  return row;
}
