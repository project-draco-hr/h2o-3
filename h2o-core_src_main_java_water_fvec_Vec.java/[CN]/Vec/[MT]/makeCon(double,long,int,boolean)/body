{
  int nchunks=(int)Math.max(1,len >> log_rows_per_chunk);
  long[] espc=new long[nchunks + 1];
  for (int i=0; i < nchunks; i++)   espc[i]=((long)i) << log_rows_per_chunk;
  espc[nchunks]=len;
  VectorGroup vg=VectorGroup.VG_LEN1;
  Vec v0=makeCon(x,vg,ESPC.rowLayout(vg._key,espc));
  int chunks=(int)Math.min(4 * H2O.NUMCPUS * H2O.CLOUD.size(),v0.length());
  if (redistribute && v0.nChunks() < chunks && v0.length() > 10 * chunks) {
    Key newKey=Key.make(Key.rand() + ".makeConRebalance" + chunks);
    Frame f=new Frame(v0);
    RebalanceDataSet rb=new RebalanceDataSet(f,newKey,chunks);
    H2O.submitTask(rb);
    rb.join();
    Keyed.remove(v0._key);
    v0=(((Frame)DKV.getGet(newKey)).anyVec()).makeCopy();
    Keyed.remove(newKey);
  }
  return v0;
}
