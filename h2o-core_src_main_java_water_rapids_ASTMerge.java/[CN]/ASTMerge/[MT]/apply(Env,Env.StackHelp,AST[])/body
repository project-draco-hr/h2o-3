{
  Frame l=stk.track(asts[1].exec(env)).getFrame();
  Frame r=stk.track(asts[2].exec(env)).getFrame();
  String[] bynames=l._names;
  if (asts[3] instanceof ASTStr) {
    bynames=new String[]{asts[3].str()};
  }
 else   if (asts[3] instanceof ASTNum) {
    bynames=new String[]{l.names()[(int)((ASTNum)asts[3])._v.getNum()]};
  }
 else   if (asts[3] instanceof ASTStrList) {
    bynames=((ASTStrList)asts[3])._strs;
  }
 else   if (asts[3] instanceof ASTNumList) {
    ASTNumList colIdxs=((ASTNumList)asts[3]);
    if (!colIdxs.isEmpty()) {
      int[] idxs=colIdxs.expand4();
      bynames=new String[idxs.length];
      for (int i=0; i < idxs.length; ++i)       bynames[i]=l.names()[i];
    }
  }
  boolean allLeft=asts[4].exec(env).getNum() == 1;
  boolean allRite=asts[5].exec(env).getNum() == 1;
  int ncols=0;
  for (int i=0; i < bynames.length; i++) {
    int lidx=l.find(bynames[i]);
    int ridx=r.find(bynames[i]);
    if (ridx != -1 && lidx != -1) {
      l.swap(lidx,ncols);
      r.swap(ridx,ncols);
      Vec lv=l.vecs()[ncols];
      Vec rv=r.vecs()[ncols];
      if (lv.get_type() != rv.get_type())       throw new IllegalArgumentException("Merging columns must be the same type, column " + l._names[ncols] + " found types "+ lv.get_type_str()+ " and "+ rv.get_type_str());
      if (lv.isString())       throw new IllegalArgumentException("Cannot merge Strings; flip toEnum first");
      if (lv.isNumeric() && !lv.isInt())       throw new IllegalArgumentException("Equality tests on doubles rarely work, please round to integers only before merging");
      ncols++;
    }
  }
  if (ncols == 0)   throw new IllegalArgumentException("Frames must have at least one column in common to merge them");
  long lsize=0, rsize=0;
  for (int i=ncols; i < l.numCols(); i++)   lsize+=l.vecs()[i].byteSize();
  for (int i=ncols; i < r.numCols(); i++)   rsize+=r.vecs()[i].byteSize();
  Frame small=lsize < rsize ? l : r;
  Frame large=lsize < rsize ? r : l;
  int[][] enum_maps=new int[ncols][];
  int[][] id_maps=new int[ncols][];
  for (int i=0; i < ncols; i++) {
    Vec lv=large.vecs()[i];
    if (lv.isEnum()) {
      EnumWrappedVec ewv=new EnumWrappedVec(lv.domain(),small.vecs()[i].domain());
      int[] ids=enum_maps[i]=ewv.enum_map();
      DKV.remove(ewv._key);
      id_maps[i]=new int[ids.length];
      for (int j=0; j < ids.length; j++)       id_maps[i][j]=j;
    }
  }
  large=large.deepCopy(null);
  Key uniq=new MergeSet(ncols,id_maps,small).doAllNodes()._uniq;
  String[] names=Arrays.copyOfRange(small._names,ncols,small._names.length);
  String[][] domains=Arrays.copyOfRange(small.domains(),ncols,small.domains().length);
  Frame res=new DoJoin(ncols,uniq,enum_maps,allLeft).doAll(small.numCols() - ncols,large).outputFrame(names,domains);
  return new ValFrame(large.add(res));
}
