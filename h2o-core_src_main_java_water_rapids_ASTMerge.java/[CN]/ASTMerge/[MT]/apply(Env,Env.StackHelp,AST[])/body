{
  Frame l=stk.track(asts[1].exec(env)).getFrame();
  Frame r=stk.track(asts[2].exec(env)).getFrame();
  boolean allLeft=asts[3].exec(env).getNum() == 1;
  boolean allRite=asts[4].exec(env).getNum() == 1;
  int[] byLeft=check(asts[5]);
  int[] byRight=check(asts[6]);
  String method=asts[7].exec(env).getStr();
  int ncols=0;
  for (int i=0; i < l._names.length; i++) {
    int idx=r.find(l._names[i]);
    if (idx != -1) {
      l.swap(i,ncols);
      r.swap(idx,ncols);
      Vec lv=l.vecs()[ncols];
      Vec rv=r.vecs()[ncols];
      if (lv.get_type() != rv.get_type())       throw new IllegalArgumentException("Merging columns must be the same type, column " + l._names[ncols] + " found types "+ lv.get_type_str()+ " and "+ rv.get_type_str());
      if (lv.isString())       throw new IllegalArgumentException("Cannot merge Strings; flip toCategoricalVec first");
      if (lv.isNumeric() && !lv.isInt())       throw new IllegalArgumentException("Equality tests on doubles rarely work, please round to integers only before merging");
      ncols++;
    }
  }
  if (ncols == 0)   throw new IllegalArgumentException("Frames must have at least one column in common to merge them");
  boolean walkLeft;
  if (allLeft == allRite) {
    long lsize=0, rsize=0;
    for (int i=ncols; i < l.numCols(); i++)     lsize+=l.vecs()[i].byteSize();
    for (int i=ncols; i < r.numCols(); i++)     rsize+=r.vecs()[i].byteSize();
    walkLeft=lsize < rsize;
  }
 else {
    walkLeft=allLeft;
  }
  Frame walked=walkLeft ? l : r;
  Frame hashed=walkLeft ? r : l;
  if (!walkLeft) {
    boolean tmp=allLeft;
    allLeft=allRite;
    allRite=tmp;
  }
  int[][] id_maps=new int[ncols][];
  for (int i=0; i < ncols; i++) {
    Vec lv=walked.vecs()[i];
    if (lv.isCategorical())     id_maps[i]=CategoricalWrappedVec.computeMap(hashed.vecs()[i].domain(),lv.domain());
  }
  new MRTask(){
    @Override public void setupLocal(){
      System.gc();
    }
  }
.doAllNodes();
  if (method.equals("radix")) {
    return sortingMerge(l,r,allLeft,allRite,ncols,id_maps);
  }
  final MergeSet ms=new MergeSet(ncols,id_maps,allRite).doAll(hashed);
  final Key uniq=ms._uniq;
  IcedHashMap<Row,String> rows=MergeSet.MERGE_SETS.get(uniq)._rows;
  new MRTask(){
    @Override public void setupLocal(){
      MergeSet.MERGE_SETS.remove(uniq);
    }
  }
.doAllNodes();
  if (method.equals("auto") && (rows == null || rows.size() > MAX_HASH_SIZE))   return sortingMerge(l,r,allLeft,allRite,ncols,id_maps);
  if (allLeft && !(allRite && ms._dup)) {
    walked=walked.deepCopy(null);
    String[] names=Arrays.copyOfRange(hashed._names,ncols,hashed._names.length);
    String[][] domains=Arrays.copyOfRange(hashed.domains(),ncols,hashed.domains().length);
    byte[] types=Arrays.copyOfRange(hashed.types(),ncols,hashed.numCols());
    Frame res=new AllLeftNoDupe(ncols,rows,hashed,allRite).doAll(types,walked).outputFrame(names,domains);
    return new ValFrame(walked.add(res));
  }
  if (!allRite) {
    String[] names=Arrays.copyOf(walked.names(),walked.numCols() + hashed.numCols() - ncols);
    System.arraycopy(hashed.names(),ncols,names,walked.numCols(),hashed.numCols() - ncols);
    String[][] domains=Arrays.copyOf(walked.domains(),walked.numCols() + hashed.numCols() - ncols);
    System.arraycopy(hashed.domains(),ncols,domains,walked.numCols(),hashed.numCols() - ncols);
    byte[] types=walked.types();
    types=Arrays.copyOf(types,types.length + hashed.numCols() - ncols);
    System.arraycopy(hashed.types(),ncols,types,walked.numCols(),hashed.numCols() - ncols);
    return new ValFrame(new AllRiteWithDupJoin(ncols,rows,hashed,allLeft).doAll(types,walked).outputFrame(names,domains));
  }
  throw H2O.unimpl();
}
