{
  double mse=_sumsqe / _wcount;
  double mae=_abserror / _wcount;
  if (adaptedFrame == null)   adaptedFrame=f;
  double meanResDeviance=0;
  if (m != null && m._parms._distribution == Distribution.Family.huber) {
    assert(_sumdeviance == 0);
    if (preds != null) {
      Vec actual=adaptedFrame.vec(m._parms._response_column);
      Vec absdiff=new MRTask(){
        @Override public void map(        Chunk[] cs,        NewChunk[] nc){
          for (int i=0; i < cs[0].len(); ++i)           nc[0].addNum(Math.abs(cs[0].atd(i) - cs[1].atd(i)));
        }
      }
.doAll(1,(byte)3,new Frame(new String[]{"preds","actual"},new Vec[]{preds.anyVec(),actual})).outputFrame().anyVec();
      Distribution dist=new Distribution(m._parms);
      Vec weight=adaptedFrame.vec(m._parms._weights_column);
      double huberDelta=MathUtils.computeWeightedQuantile(weight,absdiff,m._parms._huber_alpha);
      absdiff.remove();
      dist.setHuberDelta(huberDelta);
      meanResDeviance=new MeanResidualDeviance(dist,preds.anyVec(),actual,weight).exec().meanResidualDeviance;
    }
  }
 else {
    meanResDeviance=_sumdeviance / _wcount;
  }
  return m._output.addModelMetrics(new ModelMetricsRegression(m,f,_count,mse,weightedSigma(),mae,meanResDeviance));
}
