{
  Frame fr=stk.track(asts[1].exec(env)).getFrame();
  int ncols=fr.numCols();
  ASTNumList groupby=check(ncols,asts[2]);
  int[] gbCols=groupby.expand4();
  ASTNumList orderby=check(ncols,asts[3]);
  if (orderby.isEmpty())   orderby=new ASTNumList(0,gbCols.length);
 else   throw H2O.unimpl();
  final int[] ordCols=orderby.expand4();
  final AGG[] aggs=new AGG[(asts.length - 1) / 3];
  for (int idx=4; idx < asts.length; idx+=3) {
    FCN fcn=FCN.valueOf(asts[idx].exec(env).getFun().str());
    ASTNumList col=check(ncols,asts[idx + 1]);
    if (col.cnt() != 1)     throw new IllegalArgumentException("Group-By functions take only a single column");
    NAHandling na=NAHandling.valueOf(asts[idx + 2].exec(env).getStr().toUpperCase());
    aggs[(idx - 4) / 3]=new AGG(fcn,(int)col.min(),na);
  }
  aggs[aggs.length - 1]=new AGG(FCN.nrow,0,NAHandling.ALL);
  long start=System.currentTimeMillis();
  GBTask p1=new GBTask(gbCols,aggs).doAll(fr);
  final G[] grps=p1._gss.keySet().toArray(new G[p1._gss.size()]);
  Log.info("Group By Task done in " + (System.currentTimeMillis() - start) / 1000. + " (s)");
  Arrays.sort(grps,new java.util.Comparator<G>(){
    @Override public int compare(    G g1,    G g2){
      for (      int i : ordCols) {
        if (Double.isNaN(g1._gs[i]) && !Double.isNaN(g2._gs[i]))         return -1;
        if (!Double.isNaN(g1._gs[i]) && Double.isNaN(g2._gs[i]))         return 1;
        if (g1._gs[i] != g2._gs[i])         return g1._gs[i] < g2._gs[i] ? -1 : 1;
      }
      return 0;
    }
    @Override public boolean equals(    Object o){
      throw H2O.unimpl();
    }
  }
);
  final int nCols=gbCols.length + aggs.length;
  String[] names=new String[nCols];
  String[][] domains=new String[nCols][];
  for (int i=0; i < gbCols.length; i++) {
    names[i]=fr.name(gbCols[i]);
    domains[i]=fr.domains()[gbCols[i]];
  }
  for (int i=0; i < aggs.length; i++)   names[i + gbCols.length]=aggs[i]._fcn.toString() + "_" + fr.name(aggs[i]._col);
  Vec v=Vec.makeZero(grps.length);
  Frame f=new MRTask(){
    @Override public void map(    Chunk[] c,    NewChunk[] ncs){
      int start=(int)c[0].start();
      for (int i=0; i < c[0]._len; ++i) {
        G g=grps[i + start];
        int j;
        for (j=0; j < g._gs.length; j++)         ncs[j].addNum(g._gs[j]);
        for (int a=0; a < aggs.length - 1; a++)         ncs[j++].addNum(aggs[a]._fcn.postPass(g._ds,a));
      }
    }
  }
.doAll(nCols,v).outputFrame(names,domains);
  f.remove(nCols - 1).remove();
  v.remove();
  return new ValFrame(f);
}
