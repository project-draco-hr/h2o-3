{
  Frame fr=stk.track(asts[1].exec(env)).getFrame();
  int ncols=fr.numCols();
  ASTNumList groupby=check(ncols,asts[2]);
  int[] gbCols=groupby.expand4();
  ASTNumList orderby=check(ncols,asts[3]);
  final AGG[] aggs=new AGG[asts.length / 3];
  aggs[0]=new AGG(FCN.nrow,0,NAHandling.ALL);
  for (int idx=4; idx < asts.length; idx+=3) {
    FCN fcn=FCN.valueOf(asts[idx].exec(env).getFun().str());
    ASTNumList col=check(ncols,asts[idx + 1]);
    if (col.cnt() != 1)     throw new IllegalArgumentException("Group-By functions take only a single column");
    NAHandling na=NAHandling.valueOf(asts[idx + 2].exec(env).getStr().toUpperCase());
    aggs[idx / 3]=new AGG(fcn,(int)col.min(),na);
  }
  long start=System.currentTimeMillis();
  GBTask p1=new GBTask(gbCols,aggs).doAll(fr);
  final G[] grps=p1._gss.keySet().toArray(new G[p1._gss.size()]);
  Log.info("Group By Task done in " + (System.currentTimeMillis() - start) / 1000. + " (s)");
  if (!orderby.isEmpty())   Arrays.sort(grps);
  final int nCols=gbCols.length + aggs.length;
  String[] names=new String[nCols];
  String[][] domains=new String[nCols][];
  for (int i=0; i < gbCols.length; i++) {
    names[i]=fr.name(gbCols[i]);
    domains[i]=fr.domains()[gbCols[i]];
  }
  for (int i=0; i < aggs.length; i++)   names[i + gbCols.length]=aggs[i]._fcn.toString() + "_" + fr.name(aggs[i]._col);
  Vec v=Vec.makeZero(grps.length);
  Frame f=new MRTask(){
    @Override public void map(    Chunk[] c,    NewChunk[] ncs){
      int start=(int)c[0].start();
      for (int i=0; i < c[0]._len; ++i) {
        G g=grps[i + start];
        int j;
        for (j=0; j < g._ds.length; j++)         ncs[j].addNum(g._ds[j]);
        for (int a=0; a < aggs.length; a++)         ncs[j++].addNum(aggs[a]._fcn.postPass(g._ds,a));
      }
    }
  }
.doAll(nCols,v).outputFrame(names,domains);
  return new ValFrame(f);
}
