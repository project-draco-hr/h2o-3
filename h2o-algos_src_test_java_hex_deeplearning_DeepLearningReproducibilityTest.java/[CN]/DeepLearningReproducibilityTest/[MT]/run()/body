{
  long seed=new Random().nextLong();
  DeepLearningModel mymodel=null;
  Frame train=null;
  Frame test=null;
  Frame data=null;
  Map<Integer,Float> repeatErrs=new TreeMap<>();
  int N=6;
  StringBuilder sb=new StringBuilder();
  float repro_error=0;
  for (  boolean repro : new boolean[]{true,false}) {
    Scope.enter();
    Frame[] preds=new Frame[N];
    for (int repeat=0; repeat < N; ++repeat) {
      try {
        NFSFileVec file=NFSFileVec.make(find_test_file("smalldata/junit/weather.csv"));
        data=ParseDataset2.parse(Key.make("data.hex"),file._key);
        train=data;
        test=data;
        DeepLearningParameters p=new DeepLearningParameters();
        p._train=train._key;
        p._valid=test._key;
        p._convert_to_enum=true;
        p._destination_key=Key.make();
        p._response_column=train.names()[train.names().length - 1];
        p._ignored_columns=new String[]{"EvapMM","RISK_MM"};
        p._activation=DeepLearningParameters.Activation.RectifierWithDropout;
        p._hidden=new int[]{32,58};
        p._l1=1e-5;
        p._l2=3e-5;
        p._seed=0xbebe;
        p._input_dropout_ratio=0.2;
        p._hidden_dropout_ratios=new double[]{0.4,0.1};
        p._epochs=3.32;
        p._quiet_mode=true;
        p._reproducible=repro;
        DeepLearning dl=new DeepLearning(p);
        try {
          mymodel=dl.trainModel().get();
        }
 catch (        Throwable t) {
          t.printStackTrace();
          throw new RuntimeException(t);
        }
 finally {
          dl.remove();
        }
        mymodel=DKV.getGet(p._destination_key);
        preds[repeat]=mymodel.score(test);
        repeatErrs.put(repeat,mymodel.error());
      }
 catch (      Throwable t) {
        t.printStackTrace();
        throw new RuntimeException(t);
      }
 finally {
        if (mymodel != null) {
          mymodel.delete_xval_models();
          mymodel.delete_best_model();
          mymodel.delete();
        }
        if (train != null)         train.delete();
        if (test != null)         test.delete();
        if (data != null)         data.delete();
      }
    }
    sb.append("Reproducibility: ").append(repro ? "on" : "off").append("\n");
    sb.append("Repeat # --> Validation Error\n");
    for (    String s : Arrays.toString(repeatErrs.entrySet().toArray()).split(","))     sb.append(s.replace("="," --> ")).append("\n");
    sb.append('\n');
    Log.info(sb.toString());
    try {
      if (repro) {
        for (        Float error : repeatErrs.values())         assertTrue(error.equals(repeatErrs.get(0)));
        for (        Frame f : preds) {
          assertTrue(TestUtil.isBitIdentical(f,preds[0]));
        }
        repro_error=repeatErrs.get(0);
      }
 else {
        double mean=0;
        for (        Float error : repeatErrs.values()) {
          mean+=error;
        }
        mean/=N;
        Log.info("mean error: " + mean);
        double stddev=0;
        for (        Float error : repeatErrs.values()) {
          stddev+=(error - mean) * (error - mean);
        }
        stddev/=N;
        stddev=Math.sqrt(stddev);
        assertTrue(stddev < 0.15 / Math.sqrt(N));
      }
    }
  finally {
      for (      Frame f : preds)       if (f != null)       f.delete();
    }
    Scope.exit();
  }
}
