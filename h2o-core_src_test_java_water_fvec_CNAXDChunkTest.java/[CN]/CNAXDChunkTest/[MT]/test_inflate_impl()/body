{
  NewChunk nc=new NewChunk(null,0);
  int K=100;
  double[] vals=new double[K];
  for (int i=0; i < K - 1; i++)   vals[i]=Double.NaN;
  for (  double v : vals)   nc.addNum(v);
  double extra=1.2;
  nc.addNum(extra);
  Chunk cc=nc.compress();
  Assert.assertEquals(K + 1,cc._len);
  Assert.assertTrue(cc instanceof CNAXDChunk);
  for (int i=0; i < K; ++i)   Assert.assertEquals(vals[i],cc.atd(i),0);
  for (int i=0; i < K; ++i)   Assert.assertEquals(vals[i],cc.at_abs(i),0);
  for (int i=0; i < K - 1; ++i)   Assert.assertTrue(cc.isNA(i));
  for (int i=0; i < K - 1; ++i)   Assert.assertTrue(cc.isNA_abs(i));
  Assert.assertEquals(extra,cc.atd(K),0);
  Assert.assertEquals(extra,cc.at_abs(K),0);
  Assert.assertFalse(cc.isNA(K));
  Assert.assertFalse(cc.isNA_abs(K));
  nc=new NewChunk(null,0);
  cc.inflate_impl(nc);
  nc.values(0,nc._len);
  Assert.assertEquals(K + 1,nc._len);
  Assert.assertEquals(2,nc._sparseLen);
  Iterator<NewChunk.Value> it=nc.values(0,K + 1);
  Assert.assertTrue(it.next().rowId0() == K - 1);
  Assert.assertTrue(it.next().rowId0() == K);
  Assert.assertFalse(it.hasNext());
  for (int i=0; i < K; ++i)   Assert.assertEquals(vals[i],nc.atd(i),0);
  for (int i=0; i < K; ++i)   Assert.assertEquals(vals[i],nc.at_abs(i),0);
  for (int i=0; i < K - 1; ++i)   Assert.assertTrue(nc.isNA(i));
  for (int i=0; i < K - 1; ++i)   Assert.assertTrue(nc.isNA_abs(i));
  Chunk cc2=nc.compress();
  Assert.assertEquals(K + 1,cc2._len);
  Assert.assertTrue(cc2 instanceof CNAXDChunk);
  for (int i=0; i < K; ++i)   Assert.assertEquals(vals[i],cc2.atd(i),0);
  for (int i=0; i < K; ++i)   Assert.assertEquals(vals[i],cc2.at_abs(i),0);
  for (int i=0; i < K - 1; ++i)   Assert.assertTrue(cc2.isNA(i));
  for (int i=0; i < K - 1; ++i)   Assert.assertTrue(cc2.isNA_abs(i));
  Assert.assertEquals(extra,cc2.atd(K),0);
  Assert.assertEquals(extra,cc2.at_abs(K),0);
  Assert.assertFalse(cc2.isNA(K));
  Assert.assertFalse(cc2.isNA_abs(K));
  Assert.assertTrue(Arrays.equals(cc._mem,cc2._mem));
}
