{
  Frame fr=env.popAry();
  for (  long l : _cols) {
    if (l > fr.numCols() || l < 0)     throw new IllegalArgumentException("Column " + (l + 1) + " out of range for frame columns "+ fr.numCols());
  }
  Pass1A p1a=new Pass1A(_cols).doAll(fr);
  H2O.submitTask(new ParallelGroupProcess(p1a._grps)).join();
  new Pass1B(p1a._grps,_cols).doAll(fr);
  Pass2 p2;
  Group[] grps=p1a._grps._g.toArray(new Group[p1a._grps._g.size()]);
  H2O.submitTask(p2=new Pass2(fr,grps)).join();
  Key[] groupFrames=p2._keys;
  Pass3 p3;
  H2O.submitTask(p3=new Pass3(groupFrames,ASTOp.get(_fun).make(),grps,_fun_args)).join();
  Vec layoutVec=Vec.makeZero(p3._remoteTasks.length);
  final RemoteRapids[] results=p3._remoteTasks;
  final int ncols=results[0]._result.length;
  String names[]=new String[ncols];
  String[][] domains=new String[ncols][];
  int i=0;
  for (; i < _cols.length; ) {
    names[i]=fr.names()[(int)_cols[i]];
    domains[i]=fr.domains()[(int)_cols[i++]];
  }
  int j=1;
  for (; i < ncols; ) {
    names[i++]="C" + j++;
  }
  Frame fr2=new MRTask(){
    @Override public void map(    Chunk[] c,    NewChunk[] nc){
      int start=(int)c[0].start();
      double d;
      for (int i=0; i < c[0]._len; ++i) {
        d=results[i + start]._result[nc.length - 1];
        if (Double.isNaN(d))         continue;
        for (int j=0; j < nc.length; ++j)         nc[j].addNum(results[i + start]._result[j]);
      }
    }
  }
.doAll(ncols,layoutVec).outputFrame(names,domains);
  env.pushAry(fr2);
}
