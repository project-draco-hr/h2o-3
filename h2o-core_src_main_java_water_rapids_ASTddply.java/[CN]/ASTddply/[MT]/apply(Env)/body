{
  Frame fr=env.popAry();
  for (  long l : _cols) {
    if (l > fr.numCols() || l < 0)     throw new IllegalArgumentException("Column " + (l + 1) + " out of range for frame columns "+ fr.numCols());
  }
  Pass1A p1a=new Pass1A(_cols).doAll(fr);
  Group[] grps=p1a._grps.keySet().toArray(new Group[p1a._grps.size()]);
  int ngrps=grps.length;
  while (grps[ngrps - 1] == null)   ngrps--;
  Group[] groups=new Group[ngrps];
  System.arraycopy(grps,0,groups,0,ngrps);
  grps=groups;
  Pass2 p2;
  H2O.submitTask(p2=new Pass2(fr,grps)).join();
  Key[] groupFrames=p2._keys;
  Pass3 p3;
  H2O.submitTask(p3=new Pass3(groupFrames,ASTOp.get(_fun).make(),grps,_fun_args)).join();
  Vec layoutVec=Vec.makeZero(p3._remoteTasks.length);
  final RemoteRapids[] results=p3._remoteTasks;
  for (int k=0; k < p2._tasks.length; ++k) {
    for (    Key key : p2._tasks[k]._subsetVecKeys)     Keyed.remove(key);
  }
  int nonnull=-1;
  for (int i=0; i < results.length; ++i) {
    results[i]=results[i]._result == null ? null : results[i];
    if (results[i] != null)     nonnull=i;
  }
  if (nonnull == -1) {
    env.pushAry(new Frame(Vec.makeCon(0,0)));
    return;
  }
  final int ncols=results[nonnull]._result.length;
  String names[]=new String[ncols];
  String[][] domains=new String[ncols][];
  int i=0;
  for (; i < _cols.length; ) {
    names[i]=fr.names()[(int)_cols[i]];
    domains[i]=fr.domains()[(int)_cols[i++]];
  }
  int j=1;
  for (; i < ncols; ) {
    names[i++]="C" + j++;
  }
  Frame fr2=new MRTask(){
    @Override public void map(    Chunk[] c,    NewChunk[] nc){
      int start=(int)c[0].start();
      double d;
      for (int i=0; i < c[0]._len; ++i) {
        if (results[i + start] == null)         continue;
        d=results[i + start]._result[nc.length - 1];
        if (Double.isNaN(d))         continue;
        for (int j=0; j < nc.length; ++j)         nc[j].addNum(results[i + start]._result[j]);
      }
    }
  }
.doAll(ncols,layoutVec).outputFrame(names,domains);
  layoutVec.remove();
  env.pushAry(fr2);
}
