{
  Futures fs=new Futures();
  Vec[] vecs=new Vec[in.length];
  Key keys[]=Vec.VectorGroup.VG_LEN1.addVecs(vecs.length);
  for (int c=0; c < vecs.length; c++) {
    AppendableVec vec=new AppendableVec(keys[c]);
    NewChunk chunk=new NewChunk(vec,0);
    chunk.addNum(in[c]);
    chunk.close(0,fs);
    vecs[c]=vec.close(fs);
  }
  fs.blockForPending();
  Key local_key=Key.make();
  Frame fr=new Frame(local_key,null,vecs);
  _table._frames.put(local_key.toString(),fr);
  exec(env,new ASTFrame(fr),args);
  if (env.isNum()) {
    if (out == null || out.length < 1)     out=new double[1];
    out[0]=env.popDbl();
  }
 else   if (env.isAry()) {
    fr=env.pop0Ary();
    if (fr.numCols() > 1 && fr.numRows() != 1)     throw H2O.unimpl("Number of rows returned is > 1");
    if (fr.numCols() > 1) {
      out=new double[fr.numCols()];
      for (int v=0; v < fr.vecs().length; ++v)       out[v]=fr.vecs()[v].at(0);
    }
 else {
      Vec vec=fr.anyVec();
      if (out == null || out.length < vec.length())       out=new double[(int)vec.length()];
      for (long i=0; i < vec.length(); i++)       out[(int)i]=vec.at(i);
    }
  }
 else {
    throw H2O.unimpl();
  }
  env.cleanup(fr);
  return out;
}
