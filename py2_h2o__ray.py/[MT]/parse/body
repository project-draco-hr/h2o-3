def parse(self, key, hex_key=None, timeoutSecs=300, retryDelaySecs=0.2, initialDelaySecs=None, pollTimeoutSecs=180, noise=None, benchmarkLogging=None, noPoll=False, intermediateResults=False, **kwargs):
    '\n    Parse an imported raw file or files into a Frame.\n    '
    params_dict = {'srcs': None, 'hex': hex_key, 'pType': None, 'sep': None, 'ncols': None, 'checkHeader': None, 'singleQuotes': None, 'columnNames': None, 'delete_on_done': None, 'blocking': None, }
    if (not isinstance(key, basestring)):
        if (not key):
            raise Exception(('key seems to be bad in parse. Should be list or string. %s' % key))
        srcs = (('[' + ','.join(key)) + ']')
    else:
        srcs = (('[' + key) + ']')
    params_dict['srcs'] = srcs
    h2o_methods.check_params_update_kwargs(params_dict, kwargs, 'parse before setup merge', print_params=False)
    params_setup = {'srcs': srcs, }
    setup_result = self.do_json_request(jsonRequest='ParseSetup.json', timeout=timeoutSecs, params=params_setup)
    verboseprint('ParseSetup result:', dump_json(setup_result))
    if setup_result['srcs']:
        setupSrcs = (('[' + ','.join([src['name'] for src in setup_result['srcs']])) + ']')
    else:
        setupSrcs = None
    if setup_result['columnNames']:
        ascii_column_names = (('[' + ','.join(setup_result['columnNames'])) + ']')
    else:
        ascii_column_names = None
    parse_params = {'srcs': setupSrcs, 'hex': setup_result['hexName'], 'pType': setup_result['pType'], 'sep': setup_result['sep'], 'ncols': setup_result['ncols'], 'checkHeader': setup_result['checkHeader'], 'singleQuotes': setup_result['singleQuotes'], 'columnNames': ascii_column_names, 'delete_on_done': params_dict['delete_on_done'], 'blocking': params_dict['blocking'], }
    tooManyColNamesToPrint = (setup_result['columnNames'] and (len(setup_result['columnNames']) > 2000))
    if tooManyColNamesToPrint:
        h2p.yellow_print('Not printing the parameters to Parse because the columnNames are too lengthy.')
        h2p.yellow_print('See sandbox/commands.log')
    h2o_methods.check_params_update_kwargs(parse_params, params_dict, 'parse after merge into parse setup', print_params=(not tooManyColNamesToPrint), ignoreNone=True)
    parse_result = self.do_json_request(jsonRequest='Parse.json', params=parse_params, timeout=timeoutSecs)
    verboseprint('Parse result:', dump_json(parse_result))
    job_key = parse_result['job']['name']
    hex_key = parse_params['hex']
    if noPoll:
        return this.jobs(job_key)
    if intermediateResults:
        key = hex_key
    else:
        key = None
    job_result = self.poll_job(job_key, timeoutSecs=timeoutSecs, key=key)
    if job_result:
        jobs = job_result['jobs'][0]
        description = jobs['description']
        dest = jobs['dest']
        msec = jobs['msec']
        status = jobs['status']
        progress = jobs['progress']
        dest_key = dest['name']
        if (status == 'FAILED'):
            print dump_json(job_result)
            raise Exception(('Taking exception on parse job status: %s %s %s %s %s' % (status, progress, msec, dest_key, description)))
        return self.frames(dest_key)
    else:
        raise Exception("parse didn't get a job_result when it expected one")
