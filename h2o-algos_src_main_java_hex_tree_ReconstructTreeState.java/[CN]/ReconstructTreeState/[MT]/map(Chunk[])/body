{
  double[] data=new double[_ncols];
  double[] preds=new double[_nclass + 1];
  int ntrees=_trees.length;
  Chunk coobt=chk_oobt(chks);
  Chunk cys=chk_resp(chks);
  for (int tidx=0; tidx < ntrees; tidx++) {
    Random rng=rngForTree(_trees[tidx],coobt.cidx());
    for (int row=0; row < coobt._len; row++) {
      boolean sampleRow=_oob ? rng.nextFloat() >= _rate || Double.isNaN(cys.atd(row)) : false;
      if (!_oob || sampleRow) {
        for (int i=0; i < _ncols; i++)         data[i]=chks[i].atd(row);
        Arrays.fill(preds,0);
        score0(data,preds,_trees[tidx]);
        if (_nclass == 1)         preds[1]=preds[0];
        for (int c=0; c < _nclass; c++) {
          double prediction=preds[1 + c];
          if (preds[1 + c] != 0) {
            Chunk ctree=chk_tree(chks,c);
            long count=coobt.at8(row);
            if (_oob && _nclass >= 2)             ctree.set(row,(float)(ctree.atd(row) * count + prediction) / (count + 1));
 else             ctree.set(row,(float)(ctree.atd(row) + prediction));
          }
        }
        if (sampleRow)         coobt.set(row,coobt.atd(row) + 1);
      }
    }
  }
}
