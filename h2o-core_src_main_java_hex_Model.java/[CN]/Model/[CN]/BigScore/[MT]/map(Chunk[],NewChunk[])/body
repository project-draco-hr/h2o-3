{
  int n=chks.length;
  Chunk offsetChunk=null, weightsChunk=null, responseChunk=null;
  if (_output.hasOffset())   offsetChunk=chks[_output.offsetIdx()];
  if (_hasWeights && _computeMetrics)   weightsChunk=chks[_output.weightsIdx()];
  boolean hasWeightsOrOffset=offsetChunk != null || weightsChunk != null;
  if (hasWeightsOrOffset) {
    if (offsetChunk == null)     offsetChunk=new C0DChunk(0,chks[0]._len);
    if (weightsChunk == null)     weightsChunk=new C0DChunk(1,chks[0]._len);
    chks=Arrays.copyOf(chks,n);
  }
  double[] tmp=new double[_output.nfeatures()];
  float[] actual=null;
  _mb=Model.this.makeMetricBuilder(_domain);
  if (_computeMetrics) {
    if (Model.this instanceof SupervisedModel) {
      actual=new float[1];
      responseChunk=chks[_output.responseIdx()];
    }
 else     actual=new float[chks.length];
  }
  double[] preds=_mb._work;
  int len=chks[0]._len;
  for (int row=0; row < len; row++) {
    double[] p=hasWeightsOrOffset ? score0(chks,weightsChunk.atd(row),offsetChunk.atd(row),row,tmp,preds) : score0(chks,row,tmp,preds);
    if (_computeMetrics) {
      if (Model.this instanceof SupervisedModel) {
        actual[0]=(float)responseChunk.atd(row);
      }
 else {
        for (int i=0; i < actual.length; ++i)         actual[i]=(float)chks[i].atd(row);
      }
      if (hasWeightsOrOffset) {
        _mb.perRow(preds,actual,weightsChunk.atd(row),offsetChunk.atd(row),Model.this);
      }
 else       _mb.perRow(preds,actual,Model.this);
    }
    for (int c=0; c < _npredcols; c++)     cpreds[c].addNum(p[c]);
  }
}
