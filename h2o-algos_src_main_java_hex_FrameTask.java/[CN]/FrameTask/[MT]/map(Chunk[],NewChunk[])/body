{
  if (_job != null && _job._key != null && !Job.isRunning(_job._key))   throw new RuntimeException("Job cancelled");
  final int nrows=chunks[0].len();
  final long offset=chunks[0].start();
  chunkInit();
  double[] nums=MemoryManager.malloc8d(_dinfo._nums);
  int[] cats=MemoryManager.malloc4(_dinfo._cats);
  double[] response=MemoryManager.malloc8d(_dinfo._responses);
  int start=0;
  int end=nrows;
  boolean contiguous=false;
  Random skip_rng=null;
  final int repeats=(int)Math.ceil(_useFraction);
  final float fraction=_useFraction / repeats;
  if (fraction < 1.0) {
    skip_rng=getDeterRNG(new Random().nextLong());
    if (contiguous) {
      final int howmany=(int)Math.ceil(fraction * nrows);
      if (howmany > 0) {
        start=skip_rng.nextInt(nrows - howmany);
        end=start + howmany;
      }
      assert(start < nrows);
      assert(end <= nrows);
    }
  }
  long[] shuf_map=null;
  if (_shuffle) {
    shuf_map=new long[end - start];
    for (int i=0; i < shuf_map.length; ++i)     shuf_map[i]=start + i;
    shuffleArray(shuf_map,new Random().nextLong());
  }
  for (int rrr=0; rrr < repeats; ++rrr) {
    OUTER:     for (int rr=start; rr < end; ++rr) {
      final int r=shuf_map != null ? (int)shuf_map[rr - start] : rr;
      if ((_dinfo._nfolds > 0 && (r % _dinfo._nfolds) == _dinfo._foldId) || (skip_rng != null && skip_rng.nextFloat() > _useFraction))       continue;
      for (      Chunk c : chunks)       if (c.isNA0(r))       continue OUTER;
      int i=0, ncats=0;
      for (; i < _dinfo._cats; ++i) {
        int c=(int)chunks[i].at80(r);
        if (_dinfo._catLvls != null) {
          c=Arrays.binarySearch(_dinfo._catLvls[i],c);
          if (c >= 0)           cats[ncats++]=c + _dinfo._catOffsets[i];
        }
 else         if (_dinfo._useAllFactorLevels)         cats[ncats++]=c + _dinfo._catOffsets[i];
 else         if (c != 0)         cats[ncats++]=c + _dinfo._catOffsets[i] - 1;
      }
      final int n=chunks.length - _dinfo._responses;
      for (; i < n; ++i) {
        double d=chunks[i].at0(r);
        if (_dinfo._normMul != null)         d=(d - _dinfo._normSub[i - _dinfo._cats]) * _dinfo._normMul[i - _dinfo._cats];
        nums[i - _dinfo._cats]=d;
      }
      for (i=0; i < _dinfo._responses; ++i) {
        response[i]=chunks[chunks.length - _dinfo._responses + i].at0(r);
        if (_dinfo._normRespMul != null)         response[i]=(response[i] - _dinfo._normRespSub[i]) * _dinfo._normRespMul[i];
      }
      if (outputs != null && outputs.length > 0)       processRow(offset + r,nums,ncats,cats,response,outputs);
 else       processRow(offset + r,nums,ncats,cats,response);
    }
  }
  chunkDone();
}
