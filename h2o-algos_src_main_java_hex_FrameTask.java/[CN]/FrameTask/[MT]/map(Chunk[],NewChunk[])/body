{
  if (_jobKey != null && !Job.isRunning(_jobKey))   throw new JobCancelledException();
  final int nrows=chunks[0]._len;
  final long offset=chunks[0].start();
  chunkInit();
  int start=0;
  int end=nrows;
  Random skip_rng=null;
  final int repeats=(int)Math.ceil(_useFraction);
  final float fraction=_useFraction / repeats;
  Random row_weight_rng=RandomUtils.getRNG(0xDECAF);
  if (fraction < 1.0) {
    skip_rng=RandomUtils.getRNG(new Random().nextLong());
  }
  long[] shuf_map=null;
  if (_shuffle) {
    shuf_map=new long[end - start];
    for (int i=0; i < shuf_map.length; ++i)     shuf_map[i]=start + i;
    ArrayUtils.shuffleArray(shuf_map,new Random().nextLong());
  }
  double num_processed_rows=0;
  DataInfo.Row row=_dinfo.newDenseRow();
  for (int rrr=0; rrr < repeats; ++rrr) {
    OUTER:     for (int rr=start; rr < end; ++rr) {
      final int r=shuf_map != null ? (int)shuf_map[rr - start] : rr;
      if (skip_rng != null && skip_rng.nextFloat() > fraction)       continue;
      row=_dinfo.extractDenseRow(chunks,r,row);
      if (!row.bad) {
        long seed=offset + rrr * (end - start) + r;
        row_weight_rng.setSeed(seed);
        for (int i=0; i < row.weight; ++i) {
          if (outputs != null && outputs.length > 0)           processRow(seed++,row,outputs);
 else           processRow(seed++,row);
        }
        double remainder=row.weight - (int)row.weight;
        if (remainder > 0 && row_weight_rng.nextDouble() < remainder) {
          if (outputs != null && outputs.length > 0)           processRow(seed++,row,outputs);
 else           processRow(seed++,row);
        }
      }
      num_processed_rows+=row.weight;
    }
  }
  chunkDone(num_processed_rows);
}
