{
  super(selfKey);
  _nfolds=_foldId=0;
  _predictor_transform=predictor_transform;
  _response_transform=response_transform;
  _responses=nResponses;
  _useAllFactorLevels=useAllFactorLevels;
  _catLvls=null;
  final Vec[] vecs=fr.vecs();
  final int n=vecs.length - _responses;
  if (n < 1)   throw new IllegalArgumentException("Training data must have at least one column.");
  int[] nums=MemoryManager.malloc4(n);
  int[] cats=MemoryManager.malloc4(n);
  int nnums=0, ncats=0;
  for (int i=0; i < n; ++i) {
    if (vecs[i].isEnum())     cats[ncats++]=i;
 else     nums[nnums++]=i;
  }
  _nums=nnums;
  _cats=ncats;
  for (int i=0; i < ncats; ++i)   for (int j=i + 1; j < ncats; ++j)   if (vecs[cats[i]].domain().length < vecs[cats[j]].domain().length) {
    int x=cats[i];
    cats[i]=cats[j];
    cats[j]=x;
  }
  Vec[] vecs2=vecs.clone();
  String[] names=fr._names.clone();
  _catOffsets=MemoryManager.malloc4(ncats + 1);
  _catMissing=new int[ncats];
  int len=_catOffsets[0]=0;
  for (int i=0; i < ncats; ++i) {
    Vec v=(vecs2[i]=vecs[cats[i]]);
    names[i]=fr._names[cats[i]];
    _catMissing[i]=v.naCnt() > 0 ? 1 : 0;
    _catOffsets[i + 1]=(len+=v.domain().length - (useAllFactorLevels ? 0 : 1) + (v.naCnt() > 0 ? 1 : 0));
  }
  if (predictor_transform != TransformType.NONE) {
    _normSub=MemoryManager.malloc8d(nnums);
    _normMul=MemoryManager.malloc8d(nnums);
    Arrays.fill(_normMul,1);
  }
 else   _normSub=_normMul=null;
  for (int i=0; i < nnums; ++i) {
    Vec v=(vecs2[i + ncats]=vecs[nums[i]]);
    names[i + ncats]=fr._names[nums[i]];
    if (predictor_transform == TransformType.STANDARDIZE) {
      _normSub[i]=v.mean();
      _normMul[i]=v.sigma() != 0 ? 1.0 / v.sigma() : 1.0;
    }
 else     if (predictor_transform == TransformType.NORMALIZE) {
      _normSub[i]=v.mean();
      _normMul[i]=(v.max() - v.min() > 0) ? 1.0 / (v.max() - v.min()) : 1.0;
    }
  }
  if (response_transform != TransformType.NONE && _responses > 0) {
    _normRespSub=MemoryManager.malloc8d(_responses);
    _normRespMul=MemoryManager.malloc8d(_responses);
    Arrays.fill(_normRespMul,1);
  }
 else   _normRespSub=_normRespMul=null;
  for (int i=0; i < _responses; ++i) {
    Vec v=(vecs2[nnums + ncats + i]=vecs[nnums + ncats + i]);
    if (response_transform == TransformType.STANDARDIZE) {
      _normRespSub[i]=v.mean();
      _normRespMul[i]=v.sigma() != 0 ? 1.0 / v.sigma() : 1.0;
    }
 else     if (response_transform == TransformType.NORMALIZE) {
      _normRespSub[i]=v.mean();
      _normRespMul[i]=(v.max() - v.min() > 0) ? 1.0 / (v.max() - v.min()) : 1.0;
    }
  }
  _adaptedFrame=new Frame(names,vecs2);
  _adaptedFrame.reloadVecs();
}
