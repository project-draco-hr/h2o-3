{
  SB model=new SB();
  final DeepLearningParameters p=model_info.get_params();
  bodySb.i().p("java.util.Arrays.fill(preds,0);").nl();
  final int cats=model_info().data_info()._cats;
  final int nums=model_info().data_info()._nums;
  if (nums > 0)   bodySb.i().p("java.util.Arrays.fill(NUMS,0);").nl();
  if (cats > 0)   bodySb.i().p("java.util.Arrays.fill(CATS,0);").nl();
  bodySb.i().p("int i = 0, ncats = 0;").nl();
  if (cats > 0) {
    bodySb.i().p("for(; i<" + cats + "; ++i) {").nl();
    bodySb.i(1).p("if (!Double.isNaN(data[i])) {").nl();
    bodySb.i(2).p("int c = (int) data[i];").nl();
    if (model_info().data_info()._useAllFactorLevels)     bodySb.i(2).p("CATS[ncats++] = c + CATOFFSETS[i];").nl();
 else     bodySb.i(2).p("if (c != 0) CATS[ncats++] = c + CATOFFSETS[i] - 1;").nl();
    bodySb.i(1).p("}").nl();
    bodySb.i().p("}").nl();
  }
  if (nums > 0) {
    bodySb.i().p("final int n = data.length;").nl();
    bodySb.i().p("for(; i<n; ++i) {").nl();
    bodySb.i(1).p("NUMS[i" + (cats > 0 ? "-" + cats : "") + "] = Double.isNaN(data[i]) ? 0 : ");
    if (model_info().data_info()._normMul != null) {
      bodySb.p("(data[i] - NORMSUB[i" + (cats > 0 ? "-" + cats : "") + "])*NORMMUL[i"+ (cats > 0 ? "-" + cats : "")+ "];").nl();
    }
 else {
      bodySb.p("data[i];").nl();
    }
    bodySb.i(0).p("}").nl();
  }
  bodySb.i().p("java.util.Arrays.fill(ACTIVATION[0],0);").nl();
  if (cats > 0) {
    bodySb.i().p("for (i=0; i<ncats; ++i) ACTIVATION[0][CATS[i]] = 1;").nl();
  }
  if (nums > 0) {
    bodySb.i().p("for (i=0; i<NUMS.length; ++i) {").nl();
    bodySb.i(1).p("ACTIVATION[0][CATOFFSETS[CATOFFSETS.length-1] + i] = Double.isNaN(NUMS[i]) ? 0 : NUMS[i];").nl();
    bodySb.i().p("}").nl();
  }
  boolean tanh=(p._activation == DeepLearningParameters.Activation.Tanh || p._activation == DeepLearningParameters.Activation.TanhWithDropout);
  boolean relu=(p._activation == DeepLearningParameters.Activation.Rectifier || p._activation == DeepLearningParameters.Activation.RectifierWithDropout);
  boolean maxout=(p._activation == DeepLearningParameters.Activation.Maxout || p._activation == DeepLearningParameters.Activation.MaxoutWithDropout);
  final String stopping=p._autoencoder ? "(i<=ACTIVATION.length-1)" : "(i<ACTIVATION.length-1)";
  bodySb.i().p("for (i=1; i<ACTIVATION.length; ++i) {").nl();
  bodySb.i(1).p("java.util.Arrays.fill(ACTIVATION[i],0);").nl();
  if (maxout) {
    bodySb.i(1).p("double rmax = 0;").nl();
    bodySb.i(1).p("for (int r=0; r<ACTIVATION[i].length; ++r) {").nl();
    bodySb.i(2).p("final int cols = ACTIVATION[i-1].length;").nl();
    bodySb.i(2).p("double cmax = Float.NEGATIVE_INFINITY;").nl();
    bodySb.i(2).p("for (int c=0; c<cols; ++c) {").nl();
    bodySb.i(3).p("if " + stopping + " cmax = Math.max(ACTIVATION[i-1][c] * WEIGHT[i][r*cols+c], cmax);").nl();
    bodySb.i(3).p("else ACTIVATION[i][r] += ACTIVATION[i-1][c] * WEIGHT[i][r*cols+c];").nl();
    bodySb.i(2).p("}").nl();
    bodySb.i(2).p("if " + stopping + " ACTIVATION[i][r] = Double.isInfinite(cmax) ? 0f : cmax;").nl();
    bodySb.i(2).p("ACTIVATION[i][r] += BIAS[i][r];").nl();
    bodySb.i(2).p("if " + stopping + " rmax = Math.max(rmax, ACTIVATION[i][r]);").nl();
    bodySb.i(1).p("}").nl();
    bodySb.i(2).p("for (int r=0; r<ACTIVATION[i].length; ++r) {").nl();
    bodySb.i(3).p("if (rmax > 1 ) ACTIVATION[i][r] /= rmax;").nl();
  }
 else {
    bodySb.i(1).p("int cols = ACTIVATION[i-1].length;").nl();
    bodySb.i(1).p("int rows = ACTIVATION[i].length;").nl();
    bodySb.i(1).p("int extra=cols-cols%8;").nl();
    bodySb.i(1).p("int multiple = (cols/8)*8-1;").nl();
    bodySb.i(1).p("int idx = 0;").nl();
    bodySb.i(1).p("float[] a = WEIGHT[i];").nl();
    bodySb.i(1).p("double[] x = ACTIVATION[i-1];").nl();
    bodySb.i(1).p("double[] y = BIAS[i];").nl();
    bodySb.i(1).p("double[] res = ACTIVATION[i];").nl();
    bodySb.i(1).p("for (int row=0; row<rows; ++row) {").nl();
    bodySb.i(2).p("double psum0 = 0, psum1 = 0, psum2 = 0, psum3 = 0, psum4 = 0, psum5 = 0, psum6 = 0, psum7 = 0;").nl();
    bodySb.i(2).p("for (int col = 0; col < multiple; col += 8) {").nl();
    bodySb.i(3).p("int off = idx + col;").nl();
    bodySb.i(3).p("psum0 += a[off    ] * x[col    ];").nl();
    bodySb.i(3).p("psum1 += a[off + 1] * x[col + 1];").nl();
    bodySb.i(3).p("psum2 += a[off + 2] * x[col + 2];").nl();
    bodySb.i(3).p("psum3 += a[off + 3] * x[col + 3];").nl();
    bodySb.i(3).p("psum4 += a[off + 4] * x[col + 4];").nl();
    bodySb.i(3).p("psum5 += a[off + 5] * x[col + 5];").nl();
    bodySb.i(3).p("psum6 += a[off + 6] * x[col + 6];").nl();
    bodySb.i(3).p("psum7 += a[off + 7] * x[col + 7];").nl();
    bodySb.i(2).p("}").nl();
    bodySb.i(2).p("res[row] += psum0 + psum1 + psum2 + psum3;").nl();
    bodySb.i(2).p("res[row] += psum4 + psum5 + psum6 + psum7;").nl();
    bodySb.i(2).p("for (int col = extra; col < cols; col++)").nl();
    bodySb.i(3).p("res[row] += a[idx + col] * x[col];").nl();
    bodySb.i(2).p("res[row] += y[row];").nl();
    bodySb.i(2).p("idx += cols;").nl();
    bodySb.i(1).p("}").nl();
    bodySb.i(1).p("if " + stopping + " {").nl();
    bodySb.i(2).p("for (int r=0; r<ACTIVATION[i].length; ++r) {").nl();
    if (tanh) {
      bodySb.i(3).p("ACTIVATION[i][r] = 1 - 2 / (1 + Math.exp(2*ACTIVATION[i][r]));").nl();
    }
 else     if (relu) {
      bodySb.i(3).p("ACTIVATION[i][r] = Math.max(0, ACTIVATION[i][r]);").nl();
    }
  }
  if (p._hidden_dropout_ratios != null) {
    bodySb.i(3).p("if (i<ACTIVATION.length-1) {").nl();
    bodySb.i(4).p("ACTIVATION[i][r] *= HIDDEN_DROPOUT_RATIOS[i-1];").nl();
    bodySb.i(3).p("}").nl();
  }
  bodySb.i(2).p("}").nl();
  if (!maxout)   bodySb.i(1).p("}").nl();
  if (_output.isClassifier()) {
    bodySb.i(1).p("if (i == ACTIVATION.length-1) {").nl();
    bodySb.i(2).p("double max = ACTIVATION[i][0];").nl();
    bodySb.i(2).p("for (int r=1; r<ACTIVATION[i].length; r++) {").nl();
    bodySb.i(3).p("if (ACTIVATION[i][r]>max) max = ACTIVATION[i][r];").nl();
    bodySb.i(2).p("}").nl();
    bodySb.i(2).p("double scale = 0;").nl();
    bodySb.i(2).p("for (int r=0; r<ACTIVATION[i].length; r++) {").nl();
    bodySb.i(3).p("ACTIVATION[i][r] = Math.exp(ACTIVATION[i][r] - max);").nl();
    bodySb.i(3).p("scale += ACTIVATION[i][r];").nl();
    bodySb.i(2).p("}").nl();
    bodySb.i(2).p("for (int r=0; r<ACTIVATION[i].length; r++) {").nl();
    bodySb.i(3).p("if (Double.isNaN(ACTIVATION[i][r]))").nl();
    bodySb.i(4).p("throw new RuntimeException(\"Numerical instability, predicted NaN.\");").nl();
    bodySb.i(3).p("ACTIVATION[i][r] /= scale;").nl();
    bodySb.i(3).p("preds[r+1] = ACTIVATION[i][r];").nl();
    bodySb.i(2).p("}").nl();
    bodySb.i(1).p("}").nl();
    bodySb.i().p("}").nl();
  }
 else   if (!p._autoencoder) {
    bodySb.i(1).p("if (i == ACTIVATION.length-1) {").nl();
    if (model_info().data_info()._normRespMul != null) {
      bodySb.i(2).p("preds[1] = (ACTIVATION[i][0] / NORMRESPMUL[0] + NORMRESPSUB[0]);").nl();
    }
 else {
      bodySb.i(2).p("preds[1] = ACTIVATION[i][0];").nl();
    }
    bodySb.i(2).p("preds[1] = " + new Distribution(model_info.get_params()._distribution,model_info.get_params()._tweedie_power).linkInvString("preds[1]") + ";").nl();
    bodySb.i(2).p("if (Double.isNaN(preds[1])) throw new RuntimeException(\"Predicted regression target NaN!\");").nl();
    bodySb.i(1).p("}").nl();
    bodySb.i().p("}").nl();
  }
 else {
    bodySb.i(1).p("if (i == ACTIVATION.length-1) {").nl();
    bodySb.i(2).p("for (int r=0; r<ACTIVATION[i].length; r++) {").nl();
    bodySb.i(3).p("if (Double.isNaN(ACTIVATION[i][r]))").nl();
    bodySb.i(4).p("throw new RuntimeException(\"Numerical instability, reconstructed NaN.\");").nl();
    bodySb.i(3).p("preds[r] = ACTIVATION[i][r];").nl();
    bodySb.i(2).p("}").nl();
    if (model_info().data_info()._nums > 0) {
      int ns=model_info().data_info().numStart();
      bodySb.i(2).p("for (int k=" + ns + "; k<"+ model_info().data_info().fullN()+ "; ++k) {").nl();
      bodySb.i(3).p("preds[k] = preds[k] / NORMMUL[k-" + ns + "] + NORMSUB[k-"+ ns+ "];").nl();
      bodySb.i(2).p("}").nl();
    }
    bodySb.i(1).p("}").nl();
    bodySb.i().p("}").nl();
  }
  fileCtxSb.p(model);
  if (_output.autoencoder)   return;
  if (_output.isClassifier()) {
    if (_parms._balance_classes)     bodySb.ip("hex.genmodel.GenModel.correctProbabilities(preds, PRIOR_CLASS_DISTRIB, MODEL_CLASS_DISTRIB);").nl();
    bodySb.ip("preds[0] = hex.genmodel.GenModel.getPrediction(preds, PRIOR_CLASS_DISTRIB, data, " + defaultThreshold() + ");").nl();
  }
 else {
    bodySb.ip("preds[0] = preds[1];").nl();
  }
}
