{
  if (!get_params()._autoencoder) {
    return super.scoreImpl(orig,adaptedFr,destination_key);
  }
 else {
    final int len=model_info().data_info().fullN();
    String prefix="reconstr_";
    assert(model_info().data_info()._responses == 0);
    String[] coefnames=model_info().data_info().coefNames();
    assert(len == coefnames.length);
    Frame adaptFrm=new Frame(adaptedFr);
    for (int c=0; c < len; c++)     adaptFrm.add(prefix + coefnames[c],adaptFrm.anyVec().makeZero());
    new MRTask(){
      @Override public void map(      Chunk chks[]){
        double tmp[]=new double[_output._names.length];
        float preds[]=new float[len];
        final Neurons[] neurons=DeepLearningTask.makeNeuronsForTesting(model_info);
        for (int row=0; row < chks[0]._len; row++) {
          float p[]=score_autoencoder(chks,row,tmp,preds,neurons);
          for (int c=0; c < preds.length; c++)           chks[_output._names.length + c].set(row,p[c]);
        }
      }
    }
.doAll(adaptFrm);
    int x=_output._names.length, y=adaptFrm.numCols();
    Frame f=adaptFrm.extractFrame(x,y);
    if (destination_key != null) {
      Key k=Key.make(destination_key);
      f=new Frame(k,f.names(),f.vecs());
      DKV.put(k,f);
    }
    makeMetricBuilder(null).makeModelMetrics(this,f,Double.NaN);
    return f;
  }
}
