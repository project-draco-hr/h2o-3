{
  dl.hide("_score_each_iteration","Not used by Deep Learning.");
  boolean classification=expensive || dl.nclasses() != 0 ? dl.isClassifier() : _loss == Loss.CrossEntropy;
  if (_hidden == null || _hidden.length == 0)   dl.error("_hidden","There must be at least one hidden layer.");
  for (  int h : _hidden)   if (h <= 0)   dl.error("_hidden","Hidden layer size must be positive.");
  if (!_autoencoder) {
    if (_valid == null)     dl.hide("_score_validation_samples","score_validation_samples requires a validation frame.");
    if (classification) {
      dl.hide("_regression_stop","regression_stop is used only with regression.");
    }
 else {
      dl.hide("_classification_stop","classification_stop is used only with classification.");
    }
    if (!classification && _valid != null || _valid == null)     dl.hide("_score_validation_sampling","score_validation_sampling requires classification and a validation frame.");
  }
  if (_activation != Activation.TanhWithDropout && _activation != Activation.MaxoutWithDropout && _activation != Activation.RectifierWithDropout)   dl.hide("_hidden_dropout_ratios","hidden_dropout_ratios requires a dropout activation function.");
  if (_hidden_dropout_ratios == null) {
  }
 else   if (_hidden_dropout_ratios.length != _hidden.length) {
    dl.error("_hidden_dropout_ratios","Must have " + _hidden.length + " hidden layer dropout ratios.");
  }
 else   if (_activation != Activation.TanhWithDropout && _activation != Activation.MaxoutWithDropout && _activation != Activation.RectifierWithDropout) {
    if (!_quiet_mode)     dl.hide("_hidden_dropout_ratios","Ignoring hidden_dropout_ratios because a non-dropout activation function was specified.");
  }
 else   if (ArrayUtils.maxValue(_hidden_dropout_ratios) >= 1 || ArrayUtils.minValue(_hidden_dropout_ratios) < 0) {
    dl.error("_hidden_dropout_ratios","Hidden dropout ratios must be >= 0 and <1.");
  }
  if (_input_dropout_ratio < 0 || _input_dropout_ratio >= 1)   dl.error("_input_dropout_ratio","Input dropout must be >= 0 and <1.");
  if (_score_duty_cycle < 0 || _score_duty_cycle > 1)   dl.error("_score_duty_cycle","Score duty cycle must be >= 0 and <=1.");
  if (_l1 < 0)   dl.error("_l1","L1 penalty must be >= 0.");
  if (_l2 < 0)   dl.error("_l2","L2 penalty must be >= 0.");
  if (H2O.CLOUD.size() == 1 && _replicate_training_data)   dl.hide("_replicate_training_data","replicate_training_data is only valid with cloud size greater than 1.");
  if (_single_node_mode && (H2O.CLOUD.size() == 1 || !_replicate_training_data))   dl.hide("_single_node_mode","single_node_mode is only used with multi-node operation with replicated training data.");
  if (_autoencoder)   dl.hide("_use_all_factor_levels","use_all_factor_levels is mandatory in combination with autoencoder.");
  if (getNumFolds() != 0)   dl.hide("_overwrite_with_best_model","overwrite_with_best_model is unsupported in combination with n-fold cross-validation.");
  if (_adaptive_rate) {
    dl.hide("_rate","rate is not used with adaptive_rate.");
    dl.hide("_rate_annealing","rate_annealing is not used with adaptive_rate.");
    dl.hide("_rate_decay","rate_decay is not used with adaptive_rate.");
    dl.hide("_momentum_start","momentum_start is not used with adaptive_rate.");
    dl.hide("_momentum_ramp","momentum_ramp is not used with adaptive_rate.");
    dl.hide("_momentum_stable","momentum_stable is not used with adaptive_rate.");
    dl.hide("_nesterov_accelerated_gradient","nesterov_accelerated_gradient is not used with adaptive_rate.");
  }
 else {
    dl.hide("_rho","rho is only used with adaptive_rate.");
    dl.hide("_epsilon","epsilon is only used with adaptive_rate.");
  }
  if (_initial_weight_distribution == InitialWeightDistribution.UniformAdaptive) {
    dl.hide("_initial_weight_scale","initial_weight_scale is not used if initial_weight_distribution == UniformAdaptive.");
  }
  if (getNumFolds() != 0)   dl.error("_n_folds","n_folds is not yet implemented.");
  if (_loss == null) {
    if (expensive || dl.nclasses() != 0) {
      dl.error("_loss","Loss function must be specified. Try CrossEntropy for categorical response (classification), MeanSquare, Absolute or Huber for numerical response (regression).");
    }
  }
 else   if (_loss != Loss.Automatic) {
    if (_autoencoder && _loss == Loss.CrossEntropy)     dl.error("_loss","Cannot use CrossEntropy loss for auto-encoder.");
    if (!classification && _loss == Loss.CrossEntropy)     dl.error("_loss","For CrossEntropy loss, the response must be categorical.");
  }
  if (!classification && _loss == Loss.CrossEntropy)   dl.error("_loss","For CrossEntropy loss, the response must be categorical. Either select MeanSquare, Absolute or Huber loss for regression, or use a categorical response.");
  if (_score_training_samples < 0)   dl.error("_score_training_samples","Number of training samples for scoring must be >= 0 (0 for all).");
  if (_score_validation_samples < 0)   dl.error("_score_validation_samples","Number of training samples for scoring must be >= 0 (0 for all).");
  if (_autoencoder && _sparsity_beta > 0) {
    if (_activation == Activation.Tanh || _activation == Activation.TanhWithDropout) {
      if (_average_activation >= 1 || _average_activation <= -1)       dl.error("_average_activation","Tanh average activation must be in (-1,1).");
    }
 else     if (_activation == Activation.Rectifier || _activation == Activation.RectifierWithDropout) {
      if (_average_activation <= 0)       dl.error("_average_activation","Rectifier average activation must be positive.");
    }
  }
  if (!_autoencoder && _sparsity_beta != 0)   dl.info("_sparsity_beta","Sparsity beta can only be used for autoencoder.");
  if (_autoencoder && _activation == Activation.Maxout)   dl.error("_activation","Maxout activation is not supported for auto-encoder.");
  if (_max_categorical_features < 1)   dl.error("_max_categorical_features","max_categorical_features must be at least 1.");
  if (!_sparse && _col_major) {
    dl.error("_col_major","Cannot use column major storage for non-sparse data handling.");
  }
  if (_sparse && _elastic_averaging) {
    dl.error("_elastic_averaging","Cannot use elastic averaging for sparse data handling.");
  }
  if (expensive) {
    if (!classification && _balance_classes) {
      dl.error("_balance_classes","balance_classes requires classification.");
    }
    if (_class_sampling_factors != null && !_balance_classes) {
      dl.error("_class_sampling_factors","class_sampling_factors requires balance_classes to be enabled.");
    }
    if (_replicate_training_data && null != train() && train().byteSize() > 1e10) {
      dl.error("_replicate_training_data","Compressed training dataset takes more than 10 GB, cannot run with replicate_training_data.");
    }
  }
  if (!_elastic_averaging) {
    dl.hide("_elastic_averaging_moving_rate","Elastic averaging is required for this parameter.");
    dl.hide("_elastic_averaging_regularization","Elastic averaging is required for this parameter.");
  }
}
