{
  boolean classification=dl.isClassifier();
  if (hidden == null || hidden.length == 0)   dl.error("hidden","There must be at least one hidden layer.");
  for (int i=0; i < hidden.length; ++i)   if (hidden[i] == 0)   dl.error("hidden","Hidden layer size must be >0.");
  if (_valid == null)   dl.hide("score_validation_samples","score_validation_samples requires a validation frame.");
  if (classification) {
    dl.hide("regression_stop","regression_stop is used only with regression.");
  }
 else {
    dl.hide("classification_stop","classification_stop is used only with classification.");
    dl.hide("max_confusion_matrix_size","max_confusion_matrix_size is used only with classification.");
    dl.hide("max_hit_ratio_k","max_hit_ratio_k is used only with classification.");
    dl.hide("balance_classes","balance_classes is used only with classification.");
  }
  if (classification && balance_classes) {
  }
 else {
    dl.hide("class_sampling_factors","class_sampling_factors requires both classification and balance_classes.");
  }
  if (classification && !balance_classes || !classification)   dl.hide("max_after_balance_size","max_after_balance_size required regression OR classification with balance_classes.");
  if (!classification && _valid != null || _valid == null)   dl.hide("score_validation_sampling","score_validation_sampling requires regression and a validation frame OR no validation frame.");
  if (activation != Activation.TanhWithDropout && activation != Activation.MaxoutWithDropout && activation != Activation.RectifierWithDropout)   dl.hide("hidden_dropout_ratios","hidden_dropout_ratios requires a dropout activation function.");
  if (hidden_dropout_ratios == null) {
    if (activation == Activation.TanhWithDropout || activation == Activation.MaxoutWithDropout || activation == Activation.RectifierWithDropout) {
      hidden_dropout_ratios=new double[hidden.length];
      if (!quiet_mode)       dl.info("hidden_dropout_ratios","Automatically setting all hidden dropout ratios to 0.5.");
      Arrays.fill(hidden_dropout_ratios,0.5);
    }
  }
 else   if (hidden_dropout_ratios.length != hidden.length) {
    dl.error("hidden_dropout_ratios","Must have " + hidden.length + " hidden layer dropout ratios.");
  }
 else   if (activation != Activation.TanhWithDropout && activation != Activation.MaxoutWithDropout && activation != Activation.RectifierWithDropout) {
    if (!quiet_mode)     dl.warn("hidden_dropout_ratios","Ignoring hidden_dropout_ratios because a non-dropout activation function was specified.");
  }
  if (input_dropout_ratio < 0 || input_dropout_ratio >= 1)   dl.error("input_dropout_ratio","Input dropout must be in [0,1).");
  if (H2O.CLOUD.size() == 1 && replicate_training_data) {
    dl.hide("replicate_training_data","replicate_training_data is only valid with cloud size greater than 1.");
    dl.info("replicate_training_data","Disabling replicate_training_data on 1 node.");
    replicate_training_data=false;
  }
  if (single_node_mode && (H2O.CLOUD.size() == 1 || !replicate_training_data)) {
    dl.hide("single_node_mode","single_node_mode is only used with multi-node operation with replicated training data.");
    dl.info("single_node_mode","Disabling single_node_mode (only for multi-node operation with replicated training data).");
    single_node_mode=false;
  }
  if (autoencoder)   dl.hide("use_all_factor_levels","use_all_factor_levels is unsupported in combination with autoencoder.");
  if (!use_all_factor_levels && autoencoder) {
    dl.warn("use_all_factor_levels","Enabling all_factor_levels for auto-encoders.");
    use_all_factor_levels=true;
  }
  if (n_folds != 0)   dl.hide("override_with_best_model","override_with_best_model is unsupported in combination with n-fold cross-validation.");
  if (override_with_best_model && n_folds != 0) {
    dl.warn("override_with_best_model","Disabling override_with_best_model in combination with n-fold cross-validation.");
    override_with_best_model=false;
  }
  if (adaptive_rate) {
    dl.hide("rate","rate is not used with adaptive_rate.");
    dl.hide("rate_annealing","rate_annealing is not used with adaptive_rate.");
    dl.hide("rate_decay","rate_decay is not used with adaptive_rate.");
    dl.hide("momentum_start","momentum_start is not used with adaptive_rate.");
    dl.hide("momentum_ramp","momentum_ramp is not used with adaptive_rate.");
    dl.hide("momentum_stable","momentum_stable is not used with adaptive_rate.");
    dl.hide("nesterov_accelerated_gradient","nesterov_accelerated_gradient is not used with adaptive_rate.");
  }
 else {
    dl.hide("rho","rho is only used with adaptive_rate.");
    dl.hide("epsilon","epsilon is only used with adaptive_rate.");
  }
  if (!quiet_mode) {
    if (adaptive_rate) {
      dl.info("adaptive_rate","Using automatic learning rate.  Ignoring the following input parameters: " + "rate, rate_decay, rate_annealing, momentum_start, momentum_ramp, momentum_stable, nesterov_accelerated_gradient.");
      momentum_start=0;
      momentum_stable=0;
    }
 else {
      dl.info("adaptive_rate","Using manual learning rate.  Ignoring the following input parameters: " + "rho, epsilon.");
      rho=0;
      epsilon=0;
    }
    if (initial_weight_distribution == InitialWeightDistribution.UniformAdaptive) {
      dl.hide("initial_weight_scale","initial_weight_scale is not used if initial_weight_distribution == UniformAdaptive.");
      dl.info("initial_weight_scale","Ignoring initial_weight_scale for UniformAdaptive weight distribution.");
    }
    if (n_folds != 0) {
      if (override_with_best_model) {
        dl.warn("override_with_best_model","Automatically disabling override_with_best_model, since the final model is the only scored model with n-fold cross-validation.");
        override_with_best_model=false;
      }
    }
  }
  if (loss == Loss.Automatic) {
    if (!classification) {
      if (!quiet_mode)       dl.info("loss","Automatically setting loss to MeanSquare for regression.");
      loss=Loss.MeanSquare;
    }
 else     if (autoencoder) {
      if (!quiet_mode)       dl.info("loss","Automatically setting loss to MeanSquare for auto-encoder.");
      loss=Loss.MeanSquare;
    }
 else {
      if (!quiet_mode)       dl.info("loss","Automatically setting loss to Cross-Entropy for classification.");
      loss=Loss.CrossEntropy;
    }
  }
  if (autoencoder && sparsity_beta > 0) {
    if (activation == Activation.Tanh || activation == Activation.TanhWithDropout) {
      if (average_activation >= 1 || average_activation <= -1)       dl.error("average_activation","Tanh average activation must be in (-1,1).");
    }
 else     if (activation == Activation.Rectifier || activation == Activation.RectifierWithDropout) {
      if (average_activation <= 0)       dl.error("average_activation","Rectifier average activation must be positive.");
    }
  }
  if (!classification && loss == Loss.CrossEntropy)   dl.error("loss","Cannot use CrossEntropy loss function for regression.");
  if (autoencoder && loss != Loss.MeanSquare)   dl.error("loss","Must use MeanSquare loss function for auto-encoder.");
  if (autoencoder && classification) {
    dl.error("classification","Can only use regression mode for auto-encoder.");
  }
  if (!autoencoder && sparsity_beta != 0)   dl.info("sparsity_beta","Sparsity beta can only be used for autoencoder.");
  if (autoencoder && _valid != null)   dl.error("validation_frame","Cannot specify a validation dataset for auto-encoder.");
  if (autoencoder && activation == Activation.Maxout)   dl.error("activation","Maxout activation is not supported for auto-encoder.");
  if (max_categorical_features < 1)   dl.error("max_categorical_features","max_categorical_features must be at least 1.");
  if (!sparse && col_major) {
    if (!quiet_mode)     dl.error("col_major","Cannot use column major storage for non-sparse data handling.");
  }
  if (!classification && balance_classes) {
    dl.error("balance_classes","balance_classes requires classification to be enabled.");
  }
  if (class_sampling_factors != null && !balance_classes) {
    dl.error("class_sampling_factors","class_sampling_factors requires balance_classes to be enabled.");
  }
  if (reproducible) {
    if (!quiet_mode)     Log.info("Automatically enabling force_load_balancing, disabling single_node_mode and replicate_training_data\nand setting train_samples_per_iteration to -1 to enforce reproducibility.");
    force_load_balance=true;
    single_node_mode=false;
    train_samples_per_iteration=-1;
    replicate_training_data=false;
  }
}
