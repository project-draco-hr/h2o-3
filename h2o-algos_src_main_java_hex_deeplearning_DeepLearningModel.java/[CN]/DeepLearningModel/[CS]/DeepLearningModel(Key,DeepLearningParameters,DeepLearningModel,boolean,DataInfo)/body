{
  super(destKey,parms == null ? (DeepLearningParameters)cp._parms.clone() : parms,(DeepLearningModelOutput)cp._output.clone());
  assert(_parms != cp._parms);
  model_info=cp.model_info.deep_clone();
  if (store_best_model) {
    model_info.data_info=dataInfo.deep_clone();
  }
 else {
    model_info.data_info=dataInfo;
    if (parms != null) {
      assert(_parms == parms);
      assert(_parms._checkpoint == parms._checkpoint);
      assert(_parms._checkpoint == cp._key);
    }
  }
  DKV.put(dataInfo);
  assert(get_params() != cp.model_info().get_params());
  actual_best_model_key=cp.actual_best_model_key;
  time_of_start=cp.time_of_start;
  total_run_time=cp.total_run_time;
  Log.info("setting total_run_time to cp.total_run_time: " + total_run_time);
  total_scoring_time=cp.total_scoring_time;
  training_rows=cp.training_rows;
  validation_rows=cp.validation_rows;
  _bestLoss=cp._bestLoss;
  epoch_counter=cp.epoch_counter;
  iterations=cp.iterations;
  scoringInfo=cp.scoringInfo.clone();
  for (int i=0; i < scoringInfo.length; ++i)   scoringInfo[i]=cp.scoringInfo[i].deep_clone();
  _output.errors=last_scored();
  makeWeightsBiases(destKey);
  _output._scoring_history=createScoringHistoryTable(scoringInfo);
  _output._variable_importances=calcVarImp(last_scored().variable_importances);
  _output._names=dataInfo._adaptedFrame.names();
  _output._domains=dataInfo._adaptedFrame.domains();
  assert(Arrays.equals(_key._kb,destKey._kb));
}
