def _model_build(x, y, validation_x, validation_y, algo_url, kwargs):
    if (algo_url == 'autoencoder'):
        if ('autoencoder' in kwargs.keys()):
            if kwargs['autoencoder']:
                if y:
                    raise ValueError('`y` should not be specified for autoencoder, remove `y` input.')
                algo_url = 'deeplearning'
    if (not x):
        raise ValueError('Missing features')
    x = _check_frame(x, y, y)
    if (validation_x is not None):
        validation_x = _check_frame(validation_x, validation_y, y)
    if ('weights_column' in kwargs.keys()):
        if (kwargs['weights_column'] not in x._col_names):
            if ('training_frame' not in kwargs.keys()):
                raise ValueError('must specify `training_frame` argument if `weights`not part of `x`')
            x = _add_col(x, kwargs['training_frame'], kwargs['weights_column'])
            assert (kwargs['weights_column'] in x._col_names)
        if (validation_x is not None):
            if (kwargs['weights_column'] not in validation_x._col_names):
                if ('validation_frame' not in kwargs.keys()):
                    raise ValueError('must specify `validation_frame` argument if `weights` not part of `validation_x`')
                x = _add_col(validation_x, kwargs['validation_frame'], kwargs['weights_column'])
                assert (kwargs['weights_column'] in validation_x._col_names)
    if ('offset_column' in kwargs.keys()):
        if (kwargs['offset_column'] not in x._col_names):
            if ('training_frame' not in kwargs.keys()):
                raise ValueError('must specify `training_frame` argument if `offset_column` not part of `x`')
            x = _add_col(x, kwargs['training_frame'], kwargs['offset_column'])
            assert (kwargs['offset_column'] in x._col_names)
        if (validation_x is not None):
            if (kwargs['offset_column'] not in validation_x._col_names):
                if ('validation_frame' not in kwargs.keys()):
                    raise ValueError('must specify `validation_frame` argument if `offset_column` not part of `validation_x`')
                x = _add_col(validation_x, kwargs['validation_frame'], kwargs['offset_column'])
                assert (kwargs['offset_column'] in validation_x._col_names)
    kwargs['training_frame'] = x._id
    if (validation_x is not None):
        kwargs['validation_frame'] = validation_x._id
    if (y is not None):
        kwargs['response_column'] = y._col_names[0]
    kwargs = dict([(k, (kwargs[k]._frame()._id if isinstance(kwargs[k], H2OFrame) else kwargs[k])) for k in kwargs if (kwargs[k] is not None)])
    job = H2OJob(H2OConnection.post_json(('ModelBuilders/' + algo_url), **kwargs), job_type=(algo_url + ' Model Build')).poll()
    if ('_rest_version' in kwargs.keys()):
        model_json = H2OConnection.get_json(('Models/' + job.dest_key), _rest_version=kwargs['_rest_version'])['models'][0]
    else:
        model_json = H2OConnection.get_json(('Models/' + job.dest_key))['models'][0]
    model_type = model_json['output']['model_category']
    if (model_type == 'Binomial'):
        from model.binomial import H2OBinomialModel
        model = H2OBinomialModel(job.dest_key, model_json)
    elif (model_type == 'Clustering'):
        from model.clustering import H2OClusteringModel
        model = H2OClusteringModel(job.dest_key, model_json)
    elif (model_type == 'Regression'):
        from model.regression import H2ORegressionModel
        model = H2ORegressionModel(job.dest_key, model_json)
    elif (model_type == 'Multinomial'):
        from model.multinomial import H2OMultinomialModel
        model = H2OMultinomialModel(job.dest_key, model_json)
    elif (model_type == 'AutoEncoder'):
        from model.autoencoder import H2OAutoEncoderModel
        model = H2OAutoEncoderModel(job.dest_key, model_json)
    elif (model_type == 'DimReduction'):
        from model.dim_reduction import H2ODimReductionModel
        model = H2ODimReductionModel(job.dest_key, model_json)
    else:
        print model_type
        raise NotImplementedError
    return model
