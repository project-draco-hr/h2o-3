{
  if (_parms._family == Family.multinomial)   return applyStrongRulesMultinomial();
  int P=_dinfo.fullN();
  int selected=0;
  _activeBC=_bc;
  _activeData=_dinfo;
  if (!_allIn && _alpha > 0) {
    final double rhs=_alpha * (2 * _lambda - _previousLambda);
    int[] cols=MemoryManager.malloc4(P);
    int j=0;
    int[] oldActiveCols=_activeData._activeCols == null ? new int[0] : _activeData.activeCols();
    for (int i=0; i < P; ++i) {
      if (j < oldActiveCols.length && i == oldActiveCols[j]) {
        cols[selected++]=i;
        ++j;
      }
 else       if (_ginfo._gradient[i] > rhs || _ginfo._gradient[i] < -rhs) {
        cols[selected++]=i;
      }
    }
    _allIn=_alpha == 0 || selected == P;
    if (!_allIn) {
      if (_intercept)       cols[selected++]=P;
      cols=Arrays.copyOf(cols,selected);
      _beta=ArrayUtils.select(_beta,cols);
      _ginfo=new GLMGradientInfo(_ginfo._likelihood,_ginfo._objVal,ArrayUtils.select(_ginfo._gradient,cols));
      _activeData=_dinfo.filterExpandedColumns(Arrays.copyOf(cols,selected));
      _activeBC=_bc.filterExpandedColumns(_activeData.activeCols());
      _gslvr=new GLMGradientSolver(_parms,_activeData,(1 - _alpha) * _lambda,_bc);
    }
  }
  return selected;
}
