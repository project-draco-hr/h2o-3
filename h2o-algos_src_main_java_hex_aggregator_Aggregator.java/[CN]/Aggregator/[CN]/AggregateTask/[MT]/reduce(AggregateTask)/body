{
  if (mrt == null || mrt._exemplars == null)   return;
  Exemplar[] exemplars=mrt._exemplars;
  long[] counts=mrt._counts;
  long localCounts=0;
  for (  long c : _counts)   localCounts+=c;
  long remoteCounts=0;
  for (  long c : counts)   remoteCounts+=c;
  for (int r=0; r < exemplars.length; ++r) {
    double[] data=exemplars[r].data;
    double distanceToNearestExemplar=Double.POSITIVE_INFINITY;
    int closestExemplarIndex=0;
    for (int it=0; it < _exemplars.length; ++it) {
      double[] e=_exemplars[it].data;
      double d=squaredEuclideanDistance(e,data,data.length);
      if (d < distanceToNearestExemplar) {
        distanceToNearestExemplar=d;
        closestExemplarIndex=it;
      }
      if (distanceToNearestExemplar < _delta)       break;
    }
    if (distanceToNearestExemplar < _delta) {
      _counts[closestExemplarIndex]+=counts[r];
      Vec.Writer vw=_fr.vecs()[_fr.vecs().length - 1].open();
      vw.set(exemplars[r].gid,_exemplars[closestExemplarIndex].gid);
    }
 else {
      Exemplar[] newExemplars=Arrays.copyOf(_exemplars,_exemplars.length + 1);
      newExemplars[_exemplars.length]=exemplars[r];
      _exemplars=newExemplars;
      exemplars[r]=null;
      long[] newCounts=new long[_counts.length + 1];
      System.arraycopy(_counts,0,newCounts,0,_counts.length);
      newCounts[newCounts.length - 1]=counts[r];
      _counts=newCounts;
    }
  }
  mrt._exemplars=null;
  mrt._counts=null;
  assert(_exemplars.length <= localCounts + remoteCounts);
  assert(_counts.length == _exemplars.length);
  long sum=0;
  for (int i=0; i < _counts.length; ++i) {
    sum+=_counts[i];
  }
  assert(sum == localCounts + remoteCounts);
  assert(_exemplars != null);
  assert(_counts != null);
}
