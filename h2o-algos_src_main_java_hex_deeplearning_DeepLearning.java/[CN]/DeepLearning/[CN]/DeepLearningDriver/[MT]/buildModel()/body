{
  Scope.enter();
  DeepLearningModel cp=null;
  if (_parms.checkpoint == null)   cp=initModel();
 else {
    final DeepLearningModel previous=DKV.get(_parms.checkpoint).get();
    if (previous == null)     throw new IllegalArgumentException("Checkpoint not found.");
    Log.info("Resuming from checkpoint.");
    if (_parms.n_folds != 0) {
      throw new UnsupportedOperationException("n_folds must be 0: Cross-validation is not supported during checkpoint restarts.");
    }
 else {
    }
    if (_parms._training_frame == null || !Arrays.equals(_parms._training_frame._key._kb,previous.model_info().get_params()._training_frame._key._kb)) {
      throw new IllegalArgumentException("source must be the same as for the checkpointed model.");
    }
    _parms.autoencoder=previous.model_info().get_params().autoencoder;
    if (!_parms.autoencoder && (_parms.response_column == null || !Arrays.equals(_parms._training_frame.vec(_parms.response_column)._key._kb,_parms._training_frame.vec(previous.model_info().get_params().response_column)._key._kb))) {
      throw new IllegalArgumentException("response_vec must be the same as for the checkpointed model.");
    }
    if (ArrayUtils.difference(_parms.ignored_columns,previous.model_info().get_params().ignored_columns).length != 0 || ArrayUtils.difference(previous.model_info().get_params().ignored_columns,_parms.ignored_columns).length != 0) {
      _parms.ignored_columns=previous.model_info().get_params().ignored_columns;
      Log.warn("Automatically re-using ignored_cols from the checkpointed model.");
    }
    if ((_parms._validation_frame == null) == (previous._parms._validation_frame != null) || (_parms._validation_frame != null && _parms._validation_frame._key != null && previous._parms._validation_frame != null && !Arrays.equals(_parms._validation_frame._key._kb,previous._parms._validation_frame._key._kb))) {
      throw new IllegalArgumentException("validation must be the same as for the checkpointed model.");
    }
    if (_parms.classification != previous.model_info().get_params().classification) {
      Log.warn("Automatically switching to " + ((_parms.classification=!_parms.classification) ? "classification" : "regression") + " (same as the checkpointed model).");
    }
    _parms.epochs+=previous.epoch_counter;
    Log.info("Adding " + String.format("%.3f",previous.epoch_counter) + " epochs from the checkpointed model.");
    try {
      final DataInfo dataInfo=prepareDataInfo(_parms);
      cp=new DeepLearningModel(previous,dest(),self(),dataInfo);
      cp.write_lock(self());
      final DeepLearningModel.DeepLearningParameters A=cp.model_info().get_params();
      Object B=_parms;
      for (      Field fA : A.getClass().getDeclaredFields()) {
        if (ArrayUtils.contains(cp_modifiable,fA.getName())) {
          if (!_parms.expert_mode && ArrayUtils.contains(expert_options,fA.getName()))           continue;
          for (          Field fB : B.getClass().getDeclaredFields()) {
            if (fA.equals(fB)) {
              try {
                if (fB.get(B) == null || fA.get(A) == null || !fA.get(A).toString().equals(fB.get(B).toString())) {
                  if (fA.get(A) == null && fB.get(B) == null)                   continue;
                  Log.info("Applying user-requested modification of '" + fA.getName() + "': "+ fA.get(A)+ " -> "+ fB.get(B));
                  fA.set(A,fB.get(B));
                }
              }
 catch (              IllegalAccessException e) {
                e.printStackTrace();
              }
            }
          }
        }
      }
      if (A.n_folds != 0) {
        Log.warn("Disabling cross-validation: Not supported when resuming training from a checkpoint.");
        A.n_folds=0;
      }
      cp.update(self());
    }
  finally {
      if (cp != null)       cp.unlock(self());
    }
  }
  trainModel(cp);
  int validlen=_parms._validation_frame != null ? _parms._validation_frame.vecs().length : 0;
  Key[] keep=new Key[_parms._training_frame.vecs().length + validlen + 6];
  for (int i=0; i < _parms._training_frame.vecs().length; ++i)   keep[i]=_parms._training_frame.vecs()[i]._key;
  keep[_parms._training_frame.vecs().length]=_parms._training_frame._key;
  for (int i=0; i < validlen; ++i)   keep[i]=_parms._validation_frame.vecs()[i]._key;
  if (_parms._validation_frame != null)   keep[_parms._training_frame.vecs().length + 1]=_parms._validation_frame._key;
  keep[_parms._training_frame.vecs().length + 2]=_dest;
  keep[_parms._training_frame.vecs().length + 3]=cp.actual_best_model_key;
  keep[_parms._training_frame.vecs().length + 4]=self();
  keep[_parms._training_frame.vecs().length + 5]=_progressKey;
  Scope.exit(keep);
}
