{
  Scope.enter();
  DeepLearningModel cp=null;
  if (_parms._checkpoint == null) {
    cp=new DeepLearningModel(dest(),_parms,new DeepLearningModel.DeepLearningModelOutput(DeepLearning.this),_train,_valid);
    cp.model_info().initializeMembers();
  }
 else {
    final DeepLearningModel previous=DKV.getGet(_parms._checkpoint);
    if (previous == null)     throw new IllegalArgumentException("Checkpoint not found.");
    Log.info("Resuming from checkpoint.");
    new ProgressUpdate("Resuming from checkpoint").fork(_progressKey);
    if (_parms._n_folds != 0)     throw new UnsupportedOperationException("n_folds must be 0: Cross-validation is not supported during checkpoint restarts.");
    _parms._autoencoder=previous.model_info().get_params()._autoencoder;
    if (!_parms._autoencoder && (_parms._response_column == null || !_parms._response_column.equals(previous.model_info().get_params()._response_column))) {
      throw new IllegalArgumentException("response_vec must be the same as for the checkpointed model.");
    }
    if (ArrayUtils.difference(_parms._ignored_columns,previous.model_info().get_params()._ignored_columns).length != 0 || ArrayUtils.difference(previous.model_info().get_params()._ignored_columns,_parms._ignored_columns).length != 0) {
      _parms._ignored_columns=previous.model_info().get_params()._ignored_columns;
      Log.warn("Automatically re-using ignored_cols from the checkpointed model.");
    }
    if ((_parms._valid == null) != (previous._parms._valid == null) || (_parms._valid != null && !_parms._valid.equals(previous._parms._valid))) {
      throw new IllegalArgumentException("validation must be the same as for the checkpointed model.");
    }
    if (isClassifier() != previous._output.isClassifier())     Log.warn("Automatically switching to " + (isClassifier() ? "regression" : "classification") + " (same as the checkpointed model).");
    _parms._epochs+=previous.epoch_counter;
    Log.info("Adding " + String.format("%.3f",previous.epoch_counter) + " epochs from the checkpointed model.");
    try {
      final DataInfo dinfo=new DataInfo(Key.make(),_train,_valid,_parms._autoencoder ? 0 : 1,_parms._autoencoder || _parms._use_all_factor_levels,_parms._autoencoder ? DataInfo.TransformType.NORMALIZE : DataInfo.TransformType.STANDARDIZE,isClassifier() ? DataInfo.TransformType.NONE : DataInfo.TransformType.STANDARDIZE,_parms._missing_values_handling == MissingValuesHandling.Skip);
      DKV.put(dinfo._key,dinfo);
      cp=new DeepLearningModel(dest(),previous,false,dinfo);
      cp.write_lock(self());
      final DeepLearningModel.DeepLearningParameters A=cp.model_info().get_params();
      Object B=_parms;
      for (      Field fA : A.getClass().getDeclaredFields()) {
        if (ArrayUtils.contains(cp_modifiable,fA.getName())) {
          for (          Field fB : B.getClass().getDeclaredFields()) {
            if (fA.equals(fB)) {
              try {
                if (fB.get(B) == null || fA.get(A) == null || !fA.get(A).toString().equals(fB.get(B).toString())) {
                  if (fA.get(A) == null && fB.get(B) == null)                   continue;
                  Log.info("Applying user-requested modification of '" + fA.getName() + "': "+ fA.get(A)+ " -> "+ fB.get(B));
                  fA.set(A,fB.get(B));
                }
              }
 catch (              IllegalAccessException e) {
                e.printStackTrace();
              }
            }
          }
        }
      }
      if (A._n_folds != 0) {
        Log.warn("Disabling cross-validation: Not supported when resuming training from a checkpoint.");
        A._n_folds=0;
      }
      cp.update(self());
    }
  finally {
      if (cp != null)       cp.unlock(self());
    }
  }
  trainModel(cp);
  List<Key> keep=new ArrayList<>();
  keep.add(dest());
  if (cp._output._model_metrics.length != 0)   keep.add(cp._output._model_metrics[cp._output._model_metrics.length - 1]);
  for (  Key k : Arrays.asList(cp._output.weights)) {
    keep.add(k);
    for (    Vec vk : ((Frame)DKV.getGet(k)).vecs()) {
      keep.add(vk._key);
    }
  }
  for (  Key k : Arrays.asList(cp._output.biases)) {
    keep.add(k);
    for (    Vec vk : ((Frame)DKV.getGet(k)).vecs()) {
      keep.add(vk._key);
    }
  }
  Scope.exit(keep.toArray(new Key[0]));
}
