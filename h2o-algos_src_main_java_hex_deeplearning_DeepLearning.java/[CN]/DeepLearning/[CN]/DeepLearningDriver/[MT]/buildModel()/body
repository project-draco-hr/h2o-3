{
  Scope.enter();
  DeepLearningModel cp=null;
  if (_parms._checkpoint == null) {
    cp=new DeepLearningModel(dest(),_parms,new DeepLearningModel.DeepLearningModelOutput(DeepLearning.this),_train,_valid);
    cp.model_info().initializeMembers();
  }
 else {
    final DeepLearningModel previous=DKV.getGet(_parms._checkpoint);
    if (previous == null)     throw new IllegalArgumentException("Checkpoint not found.");
    Log.info("Resuming from checkpoint.");
    DeepLearningModel.DeepLearningParameters oldP=previous._parms;
    DeepLearningModel.DeepLearningParameters newP=_parms;
    new ProgressUpdate("Resuming from checkpoint").fork(_progressKey);
    if (newP.getNumFolds() != 0)     throw new UnsupportedOperationException("n_folds must be 0: Cross-validation is not supported during checkpoint restarts.");
    if ((_parms._valid == null) != (previous._parms._valid == null) || (_parms._valid != null && !_parms._valid.equals(previous._parms._valid))) {
      throw new IllegalArgumentException("validation must be the same as for the checkpointed model.");
    }
    try {
      final DataInfo dinfo=makeDataInfo(_train,_valid,_parms);
      DKV.put(dinfo._key,dinfo);
      cp=new DeepLearningModel(dest(),_parms,previous,false,dinfo);
      cp.write_lock(self());
      final DeepLearningModel.DeepLearningParameters actualNewP=cp.model_info().get_params();
      assert(actualNewP != previous.model_info().get_params());
      assert(actualNewP != newP);
      assert(actualNewP != oldP);
      if (oldP._autoencoder != newP._autoencoder) {
        newP._autoencoder=oldP._autoencoder;
        Log.warn("Automatically " + (newP._autoencoder ? "enabling" : "disabling") + " autoencoder (same as the checkpointed model).");
      }
      if (!newP._autoencoder && (newP._response_column == null || !newP._response_column.equals(oldP._response_column))) {
        throw new IllegalArgumentException("Response column (" + newP._response_column + ") is not the same as for the checkpointed model: "+ oldP._response_column);
      }
      if (ArrayUtils.difference(newP._ignored_columns,oldP._ignored_columns).length != 0 || ArrayUtils.difference(newP._ignored_columns,oldP._ignored_columns).length != 0) {
        actualNewP._ignored_columns=oldP._ignored_columns;
        Log.warn("Automatically re-using ignored_cols from the checkpointed model.");
      }
      if (isClassifier() != previous._output.isClassifier())       Log.warn("Automatically switching to " + (isClassifier() ? "regression" : "classification") + " (same as the checkpointed model).");
      for (      Field fBefore : actualNewP.getClass().getDeclaredFields()) {
        if (ArrayUtils.contains(cp_modifiable,fBefore.getName())) {
          for (          Field fAfter : newP.getClass().getDeclaredFields()) {
            if (fBefore.equals(fAfter)) {
              try {
                if (fAfter.get(newP) == null || fBefore.get(actualNewP) == null || !fBefore.get(actualNewP).toString().equals(fAfter.get(newP).toString())) {
                  if (fBefore.get(actualNewP) == null && fAfter.get(newP) == null)                   continue;
                  Log.info("Applying user-requested modification of '" + fBefore.getName() + "': "+ fBefore.get(actualNewP)+ " -> "+ fAfter.get(newP));
                  fBefore.set(actualNewP,fAfter.get(newP));
                }
              }
 catch (              IllegalAccessException e) {
                e.printStackTrace();
              }
            }
          }
        }
      }
      cp.modifyParms(actualNewP,actualNewP,isClassifier());
      actualNewP._epochs+=previous.epoch_counter;
      Log.info("Adding " + String.format("%.3f",previous.epoch_counter) + " epochs from the checkpointed model.");
      if (actualNewP.getNumFolds() != 0) {
        Log.warn("Disabling cross-validation: Not supported when resuming training from a checkpoint.");
        H2O.unimpl("writing to n_folds field needs to be uncommented");
      }
      cp.update(self());
    }
  finally {
      if (cp != null)       cp.unlock(self());
    }
  }
  trainModel(cp);
  List<Key> keep=new ArrayList<>();
  keep.add(dest());
  if (cp._output._model_metrics.length != 0)   keep.add(cp._output._model_metrics[cp._output._model_metrics.length - 1]);
  if (cp._output.weights != null && cp._output.biases != null) {
    for (    Key k : Arrays.asList(cp._output.weights)) {
      keep.add(k);
      for (      Vec vk : ((Frame)DKV.getGet(k)).vecs()) {
        keep.add(vk._key);
      }
    }
    for (    Key k : Arrays.asList(cp._output.biases)) {
      keep.add(k);
      for (      Vec vk : ((Frame)DKV.getGet(k)).vecs()) {
        keep.add(vk._key);
      }
    }
  }
  Scope.exit(keep.toArray(new Key[0]));
}
