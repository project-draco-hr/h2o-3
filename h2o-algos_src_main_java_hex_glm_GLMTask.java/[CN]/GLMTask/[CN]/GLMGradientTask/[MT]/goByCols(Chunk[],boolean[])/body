{
  int numStart=_dinfo.numStart();
  double[] eta=computeEtaByCols(chks,skp);
  double[] b=_beta;
  double[] g=_gradient;
  Chunk offsetChunk=_dinfo._offset ? chks[_dinfo.offsetChunkId()] : new C0DChunk(0,chks[0]._len);
  Chunk weightChunk=_dinfo._weights ? chks[_dinfo.weightChunkId()] : new C0DChunk(1,chks[0]._len);
  Chunk responseChunk=chks[_dinfo.responseChunkId()];
  double eta_sum=0;
  for (int r=0; r < chks[0]._len; ++r) {
    if (skp[r] || responseChunk.isNA(r))     continue;
    double w=weightChunk.atd(r);
    if (w == 0 || Double.isNaN(w))     continue;
    _nobs++;
    _wsum+=w;
    double y=responseChunk.atd(r);
    double mu=_params.linkInv(eta[r]);
    _val.add(y,mu,w,offsetChunk.atd(r));
    _likelihood+=w * _params.likelihood(y,mu);
    double var=_params.variance(mu);
    if (var < 1e-6)     var=1e-6;
    eta[r]=w * (mu - y) / (var * _params.linkDeriv(mu));
    eta_sum+=eta[r];
  }
  if (_dinfo._intercept)   g[g.length - 1]=eta_sum;
  if (_dinfo._normMul != null && _dinfo._normSub != null)   for (int i=0; i < _dinfo._nums; ++i)   g[numStart + i]=-_dinfo._normSub[i] * _dinfo._normMul[i] * eta_sum;
  for (int i=0; i < _dinfo._cats; ++i) {
    Chunk c=chks[i];
    for (int r=0; r < c._len; ++r) {
      if (skp[r])       continue;
      int off=_dinfo.getCategoricalId(i,(int)chks[i].at8(r));
      if (off != -1)       g[off]+=eta[r];
    }
  }
  for (int i=0; i < _dinfo._nums; ++i) {
    Chunk c=chks[i + _dinfo._cats];
    for (int r=c.nextNZ(-1); r < c._len; r=c.nextNZ(r)) {
      if (skp[r] || c.isNA(r))       continue;
      double d=c.atd(r);
      if (_dinfo._normMul != null)       d=d * _dinfo._normMul[i];
      g[numStart + i]+=eta[r] * d;
    }
  }
  _skip=skp;
}
