{
  Row row=_dinfo.newDenseRow();
  double[] g=_gradient;
  double[] b=_beta;
  for (int rid=0; rid < chks[0]._len; ++rid) {
    if (skp[rid])     continue;
    row=_dinfo.extractDenseRow(chks,rid,row);
    if (row.weight == 0 || row.bad)     continue;
    _nobs++;
    _wsum+=row.weight;
    double eta=row.innerProduct(b) + row.offset;
    double mu=_params.linkInv(eta);
    _likelihood+=row.weight * _params.likelihood(row.response(0),mu);
    double var=_params.variance(mu);
    if (var < 1e-6)     var=1e-6;
    double gval=row.weight * (mu - row.response(0)) / (var * _params.linkDeriv(mu));
    for (int i=0; i < row.nBins; ++i)     g[row.binIds[i]]+=gval;
    int off=_dinfo.numStart();
    for (int j=0; j < _dinfo._nums; ++j)     g[j + off]+=row.numVals[j] * gval;
    if (_dinfo._intercept)     g[g.length - 1]+=gval;
  }
}
