{
  double t=_initialStep;
  _nobs=0;
  double[][] beta=_betaBase.clone();
  for (int i=0; i < beta.length; ++i)   beta[i]=beta[i].clone();
  Rows rows=_dinfo.rows(chks);
  double[] etas=new double[_betaBase.length];
  double[] etaOffsets=new double[etas.length];
  double[] exps=new double[_betaBase.length + 1];
  double[] likelihoods=new double[_nSteps];
  for (int i=0; i < _nSteps; i++) {
    for (int j=0; j < _betaBase.length; ++j) {
      double[] base=_betaBase[j];
      double[] b=beta[j];
      if (_direction2D != null) {
        double[] d=_direction2D[j];
        for (int k=0; k < base.length; ++k)         b[k]=base[k] + t * d[k];
      }
 else       if (j == _c) {
        for (int k=0; k < base.length; ++k)         b[k]=base[k] + t * _direction1D[k];
      }
      if (rows._sparse)       etaOffsets[j]=GLM.sparseOffset(b,_dinfo);
    }
    for (int j=0; j < rows._nrows; ++j) {
      Row row=rows.row(j);
      if (i == 0)       ++_nobs;
      double logSumExp=computeMultinomialEtas(row,beta,etas,etaOffsets,exps);
      likelihoods[i]-=row.weight * (etas[(int)row.response(0)] - logSumExp);
    }
    t*=_stepDec;
  }
  _likelihoods=likelihoods;
  _betaBase=null;
  _direction1D=null;
  _direction2D=null;
}
