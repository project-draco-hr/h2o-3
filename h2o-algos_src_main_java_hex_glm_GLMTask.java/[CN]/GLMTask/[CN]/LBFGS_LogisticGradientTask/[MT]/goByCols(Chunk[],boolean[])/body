{
  int numStart=_dinfo.numStart();
  double[] eta=computeEtaByCols(chks,skp);
  double[] g=_gradient;
  Chunk offsetChunk=null;
  int nxs=chks.length - 1;
  if (_dinfo._offset) {
    nxs-=1;
    offsetChunk=chks[nxs];
  }
  Chunk responseChunk=chks[nxs];
  Chunk weightsChunk=_dinfo._weights ? chks[_dinfo.weightChunkId()] : new C0DChunk(chks[0]._len,1);
  double eta_sum=0;
  for (int r=0; r < chks[0]._len; ++r) {
    double w=weightsChunk.atd(r);
    if (skp[r] || responseChunk.isNA(r))     continue;
    ++_nobs;
    double off=(_dinfo._offset ? offsetChunk.atd(r) : 0);
    double e=eta[r] + off;
switch (_params._family) {
case gaussian:
      double diff=e - responseChunk.atd(r);
    _likelihood+=w * diff * diff;
  eta[r]=diff;
break;
case binomial:
double y=-1 + 2 * responseChunk.atd(r);
double d=1 + Math.exp(-y * e);
_likelihood+=w * Math.log(d);
eta[r]=w * -y * (1 - 1.0 / d);
break;
default :
throw H2O.unimpl();
}
eta_sum+=eta[r];
}
if (_dinfo._intercept) g[g.length - 1]=eta_sum;
if (_dinfo._normMul != null && _dinfo._normSub != null) for (int i=0; i < _dinfo._nums; ++i) g[numStart + i]=-_dinfo._normSub[i] * _dinfo._normMul[i] * eta_sum;
for (int i=0; i < _dinfo._cats; ++i) {
Chunk c=chks[i];
for (int r=0; r < c._len; ++r) {
if (skp[r]) continue;
int off=_dinfo.getCategoricalId(i,(int)chks[i].at8(r));
if (off != -1) g[off]+=eta[r];
}
}
for (int i=0; i < _dinfo._nums; ++i) {
Chunk c=chks[i + _dinfo._cats];
for (int r=c.nextNZ(-1); r < c._len; r=c.nextNZ(r)) {
if (skp[r] || c.isNA(r)) continue;
double d=c.atd(r);
if (_dinfo._normMul != null) d=d * _dinfo._normMul[i];
g[numStart + i]+=eta[r] * d;
}
}
_skip=skp;
}
