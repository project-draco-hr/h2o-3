{
  double[][] eta=new double[_beta.length][];
  double[] obj=MemoryManager.malloc8d(_beta.length);
  boolean[] skp=MemoryManager.mallocZ(chks[0]._len);
  for (int i=0; i < eta.length; ++i)   eta[i]=MemoryManager.malloc8d(chks[0]._len);
  _gradient=new double[_beta.length][];
  for (int i=0; i < _gradient.length; ++i)   _gradient[i]=MemoryManager.malloc8d(_beta[i].length);
  int nxs=chks.length - 1;
  Chunk responseChunk=chks[nxs];
  Chunk offsetChunk=null;
  if (_dinfo._offset) {
    nxs-=1;
    offsetChunk=chks[nxs];
  }
  for (int i=0; i < _dinfo._cats; ++i) {
    Chunk c=chks[i];
    for (int r=0; r < c._len; ++r) {
      if (skp[r] || c.isNA(r)) {
        skp[r]=true;
        continue;
      }
      int off=(int)c.at8(r) + _dinfo._catOffsets[i];
      if (!_dinfo._useAllFactorLevels) {
        if (off == _dinfo._catOffsets[i])         continue;
        off-=1;
      }
      for (int j=0; j < eta.length; ++j)       eta[j][r]+=_beta[j][off];
    }
  }
  for (int i=_dinfo._cats; i < nxs; ++i) {
    Chunk c=chks[i];
    for (int r=0; r < c._len; ++r) {
      if (skp[r] || c.isNA(r)) {
        skp[r]=true;
        System.out.println("skipping row " + r);
        continue;
      }
      double d=c.atd(r);
      if (_dinfo._normMul != null)       d=(d - _dinfo._normSub[i - _dinfo._cats]) * _dinfo._normMul[i - _dinfo._cats];
      int numStart=_dinfo.numStart() - _dinfo._cats;
      for (int j=0; j < eta.length; ++j)       eta[j][r]+=_beta[j][numStart + i] * d;
    }
  }
  for (int r=0; r < chks[0]._len; ++r) {
    if (skp[r] || responseChunk.isNA(r))     continue;
    double off=_dinfo._offset ? offsetChunk.atd(r) : 0;
    double y=responseChunk.atd(r);
    for (int j=0; j < eta.length; ++j) {
      double offset=off + (_dinfo._intercept ? _beta[j][_beta[j].length - 1] : 0);
      double mu=_params.linkInv(eta[j][r] + offset);
      obj[j]+=_params.deviance(y,mu);
      double var=_params.variance(mu);
      if (var < 1e-6)       var=1e-6;
      eta[j][r]=(mu - y) / (var * _params.linkDeriv(mu));
      if (_dinfo._intercept)       _gradient[j][_gradient[j].length - 1]+=eta[j][r];
    }
  }
  for (int i=0; i < _dinfo._cats; ++i) {
    Chunk c=chks[i];
    for (int r=0; r < c._len; ++r) {
      if (skp[r])       continue;
      int off=(int)c.at8(r) + _dinfo._catOffsets[i];
      if (!_dinfo._useAllFactorLevels) {
        if (off == _dinfo._catOffsets[i])         continue;
        off-=1;
      }
      for (int j=0; j < eta.length; ++j)       _gradient[j][off]+=eta[j][r];
    }
  }
  for (int i=_dinfo._cats; i < nxs; ++i) {
    Chunk c=chks[i];
    for (int r=0; r < c._len; ++r) {
      if (skp[r] || c.isNA(r)) {
        skp[r]=true;
        continue;
      }
      double d=c.atd(r);
      if (_dinfo._normMul != null)       d=(d - _dinfo._normSub[i - _dinfo._cats]) * _dinfo._normMul[i - _dinfo._cats];
      int numStart=_dinfo.numStart() - _dinfo._cats;
      for (int j=0; j < eta.length; ++j)       _gradient[j][numStart + i]+=eta[j][r] * d;
    }
  }
  for (int i=0; i < _beta.length; ++i) {
    obj[i]*=_reg;
    for (int j=0; j < _beta[i].length; ++j)     _gradient[i][j]*=_reg;
  }
  _objVals=obj;
}
