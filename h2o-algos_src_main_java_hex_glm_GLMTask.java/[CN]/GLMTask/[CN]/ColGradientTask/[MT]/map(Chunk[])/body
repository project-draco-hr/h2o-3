{
  double[][] eta=new double[_beta.length][];
  double[] obj=MemoryManager.malloc8d(_beta.length);
  boolean[] skp=MemoryManager.mallocZ(chks[0]._len);
  for (int i=0; i < eta.length; ++i)   eta[i]=MemoryManager.malloc8d(chks[0]._len);
  _gradient=new double[_beta.length][];
  for (int i=0; i < _gradient.length; ++i)   _gradient[i]=MemoryManager.malloc8d(_beta[i].length);
  int nxs=chks.length - 1;
  Chunk responseChunk=chks[nxs];
  Chunk offsetChunk=null;
  if (_dinfo._offset) {
    nxs-=1;
    offsetChunk=chks[nxs];
  }
  for (int i=0; i < _dinfo._cats; ++i) {
    Chunk c=chks[i];
    for (int r=0; r < c._len; ++r) {
      if (skp[r] || c.isNA(r)) {
        skp[r]=true;
        continue;
      }
      int off=(int)c.at8(r) + _dinfo._catOffsets[i];
      if (!_dinfo._useAllFactorLevels) {
        if (off == _dinfo._catOffsets[i])         continue;
        off-=1;
      }
      for (int j=0; j < eta.length; ++j)       eta[j][r]+=_beta[j][off];
    }
  }
  final int numStart=_dinfo.numStart();
  if (_dinfo._normMul != null && _dinfo._normSub != null) {
    for (int j=0; j < eta.length; ++j) {
      double off=0;
      for (int i=0; i < _dinfo._nums; ++i)       off-=_beta[j][numStart + i] * _dinfo._normSub[i] * _dinfo._normMul[i];
      for (int r=0; r < chks[0]._len; ++r)       eta[j][r]+=off;
    }
  }
  for (int i=0; i < _dinfo._nums; ++i) {
    Chunk c=chks[i + _dinfo._cats];
    for (int r=c.nextNZ(-1); r < c._len; r=c.nextNZ(r)) {
      if (skp[r] || c.isNA(r)) {
        skp[r]=true;
        continue;
      }
      double d=c.atd(r);
      if (_dinfo._normMul != null)       d*=_dinfo._normMul[i];
      for (int j=0; j < eta.length; ++j)       eta[j][r]+=_beta[j][numStart + i] * d;
    }
  }
  double[] eta_sums=MemoryManager.malloc8d(eta.length);
  for (int r=0; r < chks[0]._len; ++r) {
    if (skp[r] || responseChunk.isNA(r))     continue;
    double off=(_dinfo._offset ? offsetChunk.atd(r) : 0);
    double y=responseChunk.atd(r);
    for (int j=0; j < eta.length; ++j) {
      double offset=off + (_dinfo._intercept ? _beta[j][_beta[j].length - 1] : 0);
      double mu=_params.linkInv(eta[j][r] + offset);
      obj[j]+=_params.deviance(y,mu);
      double var=_params.variance(mu);
      if (var < 1e-6)       var=1e-6;
      eta[j][r]=(mu - y) / (var * _params.linkDeriv(mu));
      eta_sums[j]+=eta[j][r];
    }
  }
  for (int j=0; j < _gradient.length; ++j) {
    if (_dinfo._intercept)     _gradient[j][_gradient[j].length - 1]=eta_sums[j];
    if (_dinfo._normMul != null && _dinfo._normSub != null)     for (int i=0; i < _dinfo._nums; ++i)     _gradient[j][numStart + i]=-_dinfo._normSub[i] * _dinfo._normMul[i] * eta_sums[j];
  }
  for (int i=0; i < _dinfo._cats; ++i) {
    Chunk c=chks[i];
    for (int r=0; r < c._len; ++r) {
      if (skp[r])       continue;
      int off=(int)c.at8(r) + _dinfo._catOffsets[i];
      if (!_dinfo._useAllFactorLevels) {
        if (off == _dinfo._catOffsets[i])         continue;
        off-=1;
      }
      for (int j=0; j < eta.length; ++j)       _gradient[j][off]+=eta[j][r];
    }
  }
  for (int i=0; i < _dinfo._nums; ++i) {
    Chunk c=chks[i + _dinfo._cats];
    for (int r=c.nextNZ(-1); r < c._len; r=c.nextNZ(r)) {
      if (skp[r] || c.isNA(r))       continue;
      double d=c.atd(r);
      if (_dinfo._normMul != null)       d=d * _dinfo._normMul[i];
      for (int j=0; j < eta.length; ++j)       _gradient[j][numStart + i]+=eta[j][r] * d;
    }
  }
  for (int i=0; i < _beta.length; ++i) {
    obj[i]*=_reg;
    for (int j=0; j < _beta[i].length; ++j)     _gradient[i][j]*=_reg;
  }
  _objVals=obj;
}
