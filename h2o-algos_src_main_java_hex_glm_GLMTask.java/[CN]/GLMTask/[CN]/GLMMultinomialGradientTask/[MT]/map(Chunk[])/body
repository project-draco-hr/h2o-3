{
  int rank=0;
  for (int i=0; i < _beta.length; ++i)   for (int j=0; j < _beta[i].length; ++j)   if (_beta[i][j] != 0)   ++rank;
  _gradient=new double[_beta.length * _beta[0].length];
  final int P=_beta[0].length;
  double[] etas=new double[_beta.length];
  double[] exps=new double[_beta.length + 1];
  double[] etaOffsets=new double[_beta.length];
  Rows rows=_dinfo.rows(chks);
  if (rows._sparse)   for (int i=0; i < _beta.length; ++i)   etaOffsets[i]=GLM.sparseOffset(_beta[i],_dinfo);
  for (int r=0; r < rows._nrows; ++r) {
    final Row row=rows.row(r);
    if (row.bad || row.weight == 0)     continue;
    _wsum+=row.weight;
    _nobs++;
    processRow(row,_beta,etas,etaOffsets,exps);
  }
  if (rows._sparse && _dinfo._normSub != null) {
    int off=_dinfo.numStart();
    for (int c=0; c < _beta.length; ++c) {
      double val=_gradient[(c + 1) * P - 1];
      for (int i=0; i < _dinfo._nums; ++i)       _gradient[c * P + off + i]-=val * _dinfo._normSub[i] * _dinfo._normMul[i];
    }
  }
}
