{
  double[][] etas=new double[chks[0]._len][_beta.length];
  double[] offsets=new double[_beta.length];
  for (int k=0; k < offsets.length; ++k)   offsets[k]=GLM.sparseOffset(_beta[k],_dinfo) + _beta[k][_beta[k].length - 1];
  int numOff=_dinfo.numStart();
  for (int i=0; i < chks[0]._len; ++i)   System.arraycopy(offsets,0,etas[i],0,etas[i].length);
  for (int cid=0; cid < _dinfo._cats; ++cid) {
    Chunk c=chks[cid];
    for (int rid=c.nextNZ(-1); rid < c._len; rid=c.nextNZ(rid)) {
      int id=_dinfo.getCategoricalId(cid,c.isNA(rid) ? _dinfo._catModes[cid] : (int)c.at8(rid));
      if (id >= 0)       for (int k=0; k < _beta.length; ++k)       etas[rid][k]+=_beta[k][id];
    }
  }
  Chunk.DVec dvec=new Chunk.DVec(chks[0].len());
  for (int cid=0; cid < _dinfo._nums; ++cid) {
    Chunk c=chks[cid + _dinfo._cats];
    double scale=_dinfo._normMul == null ? 1 : _dinfo._normMul[cid];
    c.asDoubles(dvec);
    for (int i=0; i < dvec.nVals; ++i) {
      int rid=dvec.ids[i];
      double d=dvec.vals[i] * scale;
      for (int k=0; k < _beta.length; ++k)       etas[rid][k]+=d * _beta[k][cid + numOff];
    }
  }
  int P=_beta[0].length;
  double[] exps=new double[_beta.length + 1];
  for (int i=0; i < etas.length; ++i) {
    double w=weight.atd(i);
    int y=(int)response.at8(i);
    double logSumExp=computeMultinomialEtas(_beta,etas[i],exps);
    _likelihood-=w * (etas[i][y] - logSumExp);
    for (int c=0; c < _beta.length; ++c)     etas[i][c]=w * (exps[c + 1] - (y == c ? 1 : 0));
  }
  for (int cid=0; cid < _dinfo._cats; ++cid) {
    Chunk c=chks[cid];
    for (int rid=c.nextNZ(-1); rid < c._len; rid=c.nextNZ(rid)) {
      int id=_dinfo.getCategoricalId(cid,c.isNA(rid) ? _dinfo._catModes[cid] : (int)c.at8(rid));
      if (id >= 0)       for (int k=0; k < _beta.length; ++k)       _gradient[k * P + id]+=etas[rid][k];
    }
  }
  double[] grad=new double[_beta.length];
  for (int cid=0; cid < chks.length; ++cid) {
    Chunk c=chks[cid];
    double scale=_dinfo._normMul == null ? 1 : _dinfo._normMul[cid];
    c.asDoubles(dvec);
    for (int i=0; i < dvec.nVals; ++i) {
      int rid=dvec.ids[i];
      double d=dvec.vals[i] * scale;
      double[] erid=etas[rid];
      for (int k=0; k < _beta.length; ++k)       grad[k]+=d * erid[k];
    }
    for (int k=0; k < _beta.length; ++k)     AtomicUtils.DoubleArray.add(_gradient,k * P + cid,grad[k]);
    Arrays.fill(grad,0);
  }
  for (int i=0; i < etas.length; ++i)   for (int k=0; k < _beta.length; ++k)   grad[k]+=etas[i][k];
  for (int k=0; k < _beta.length; ++k)   AtomicUtils.DoubleArray.add(_gradient,(k + 1) * P + -1,grad[k]);
}
