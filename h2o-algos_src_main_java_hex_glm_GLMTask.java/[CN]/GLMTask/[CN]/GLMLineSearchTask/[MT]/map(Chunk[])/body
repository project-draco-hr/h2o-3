{
  Chunk responseChunk=chks[_dinfo.responseChunkId()];
  boolean[] skip=MemoryManager.mallocZ(chks[0]._len);
  double[][] eta=new double[responseChunk._len][_nSteps];
  if (_dinfo._offset) {
    Chunk offsetChunk=chks[_dinfo.offsetChunkId()];
    for (int r=0; r < eta.length; ++r)     Arrays.fill(eta[r],offsetChunk.atd(r));
  }
  Chunk weightsChunk=_dinfo._weights ? chks[_dinfo.weightChunkId()] : new C0DChunk(1,chks[0]._len);
  double[] beta=_beta;
  double[] pk=_direction;
  for (int r=0; r < eta.length; ++r) {
    double b=beta[beta.length - 1];
    double t=pk[beta.length - 1] * _initStep;
    for (int j=0; j < _nSteps; ++j, t*=_step) {
      eta[r][j]+=b + t;
    }
  }
  for (int i=0; i < _dinfo._cats; ++i) {
    Chunk c=chks[i];
    for (int r=0; r < c._len; ++r) {
      if (skip[r] || c.isNA(r)) {
        skip[r]=true;
        continue;
      }
      int off=_dinfo.getCategoricalId(i,(int)c.at8(r));
      if (off != -1) {
        double t=pk[off] * _initStep;
        double b=beta[off];
        for (int j=0; j < _nSteps; ++j, t*=_step)         eta[r][j]+=b + t;
      }
    }
  }
  final int numStart=_dinfo.numStart();
  double[] off=new double[_nSteps];
  if (_dinfo._normMul != null && _dinfo._normSub != null) {
    for (int i=0; i < _dinfo._nums; ++i) {
      double b=beta[numStart + i];
      double s=pk[numStart + i] * _initStep;
      double d=_dinfo._normSub[i] * _dinfo._normMul[i];
      for (int j=0; j < _nSteps; ++j, s*=_step)       off[j]-=(b + s) * d;
    }
  }
  for (int i=0; i < _dinfo._nums; ++i) {
    Chunk c=chks[i + _dinfo._cats];
    for (int r=c.nextNZ(-1); r < c._len; r=c.nextNZ(r)) {
      if (skip[r] || c.isNA(r)) {
        skip[r]=true;
        continue;
      }
      double d=c.atd(r);
      if (d == 0)       continue;
      if (_dinfo._normMul != null)       d*=_dinfo._normMul[i];
      double b=beta[numStart + i];
      double s=pk[numStart + i] * _initStep;
      for (int j=0; j < _nSteps; ++j, s*=_step)       eta[r][j]+=(b + s) * d;
    }
  }
  _likelihoods=MemoryManager.malloc8d(_nSteps);
  for (int r=0; r < chks[0]._len; ++r) {
    double w=weightsChunk.atd(r);
    if (skip[r] || responseChunk.isNA(r))     continue;
    _nobs++;
    double y=responseChunk.atd(r);
    double yy=-1 + 2 * y;
    for (int i=0; i < _nSteps; ++i) {
      double e=eta[r][i] + off[i];
      if (_params._family == Family.binomial && _useFasterMetrics) {
        _likelihoods[i]+=w * Math.log(1 + Math.exp(-yy * e));
      }
 else {
        double mu=_params.linkInv(e);
        _likelihoods[i]+=w * _params.likelihood(y,mu);
      }
    }
  }
}
