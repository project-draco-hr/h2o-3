def exec_expr(node=None, execExpr=None, resultKey=None, timeoutSecs=10, ignoreH2oError=False, doFuns=False):
    if (not node):
        node = h2o_nodes.nodes[0]
    if doFuns:
        kwargs = {'funs': execExpr, }
    else:
        kwargs = {'ast': execExpr, }
    start = time.time()
    resultExec = h2o_cmd.runExec(node, timeoutSecs=timeoutSecs, ignoreH2oError=ignoreH2oError, **kwargs)
    verboseprint('exec took', (time.time() - start), 'seconds')
    print 'exec:', dump_json(resultExec)
    if ((resultExec['num_cols'] != 0) or (resultExec['num_rows'] != 0)):
        if (('funstr' in resultExec) and resultExec['funstr']):
            raise Exception(("cols and funstr shouldn't both be in resultExec: %s" % dump_json(resultExec)))
        else:
            print 'Frame return'
            if ((1 == 0) and (resultKey is None)):
                resultKey = resultExec['key']['name']
                kwargs = {'ast': resultKey, }
                resultExec = h2o_cmd.runExec(node, timeoutSecs=timeoutSecs, ignoreH2oError=ignoreH2oError, **kwargs)
                print 'exec key result:', dump_json(resultExec)
            inspect = h2o_cmd.runInspect(key=resultKey)
            print 'inspect key of result:', dump_json(inspect)
            result = inspect['frames'][0]['columns'][0]['mins'][0]
    elif (('funstr' in resultExec) and resultExec['funstr']):
        print 'function return'
        result = resultExec['funstr']
    else:
        print 'scalar return'
        result = resultExec['scalar']
    return (resultExec, result)
