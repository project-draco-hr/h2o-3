{
  if (colIdx < _nvs.length) {
    if (_ctypes[colIdx] == Vec.T_NUM) {
      addInvalidCol(colIdx);
      return;
    }
    if (_ctypes[colIdx] == Vec.T_BAD && ParseTime.attemptTimeParse(str) > 0)     _ctypes[colIdx]=Vec.T_TIME;
    if (_ctypes[colIdx] == Vec.T_BAD) {
      int old=str.get_off();
      ParseTime.attemptUUIDParse0(str);
      ParseTime.attemptUUIDParse1(str);
      if (str.get_off() != -1)       _ctypes[colIdx]=Vec.T_UUID;
      str.setOff(old);
    }
    if (_ctypes[colIdx] == Vec.T_TIME) {
      long l=ParseTime.attemptTimeParse(str);
      if (l == Long.MIN_VALUE)       addInvalidCol(colIdx);
 else {
        int time_pat=ParseTime.decodePat(l);
        l=ParseTime.decodeTime(l);
        addNumCol(colIdx,l,0);
        _nvs[_col]._timCnt[time_pat]++;
      }
    }
 else     if (_ctypes[colIdx] == Vec.T_UUID) {
      long lo=ParseTime.attemptUUIDParse0(str);
      long hi=ParseTime.attemptUUIDParse1(str);
      if (str.get_off() == -1) {
        lo=C16Chunk._LO_NA;
        hi=C16Chunk._HI_NA;
      }
      if (colIdx < _nCols)       _nvs[_col=colIdx].addUUID(lo,hi);
    }
 else     if (_ctypes[colIdx] == Vec.T_STR) {
      _nvs[_col=colIdx].addStr(str);
    }
 else {
      if (!_enums[colIdx].isMapFull()) {
        int id=_enums[_col=colIdx].addKey(str);
        if (_ctypes[colIdx] == Vec.T_BAD && id > 1)         _ctypes[colIdx]=Vec.T_ENUM;
        _nvs[colIdx].addEnum(id);
      }
 else {
        _ctypes[_col=colIdx]=Vec.T_STR;
        enumCol2StrCol(colIdx);
        _nvs[colIdx].addStr(str);
      }
    }
  }
}
