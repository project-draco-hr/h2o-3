{
  ByteVec vec=getByteVec(key);
  final int chunkStartIdx=_fileChunkOffsets[_lo];
  byte[] zips=vec.getFirstBytes();
  ZipUtil.Compression cpr=ZipUtil.guessCompressionMethod(zips);
  byte[] bits=ZipUtil.unzipBytes(zips,cpr,_gblSetup._chunk_size);
  ParseSetup localSetup=_gblSetup.guessSetup(bits,0);
  localSetup._chunk_size=_gblSetup._chunk_size;
  if (!localSetup._is_valid) {
    _errors=localSetup._errors;
    chunksAreLocal(vec,chunkStartIdx,key);
    return;
  }
 else   if (!localSetup.isCompatible(_gblSetup)) {
    return;
  }
  boolean has_hdr=false;
  if (_gblSetup._check_header == 1 && localSetup._check_header == 1)   has_hdr=true;
  if (has_hdr) {
    for (int i=0; has_hdr && i < localSetup._column_names.length; ++i)     has_hdr=localSetup._column_names[i].equalsIgnoreCase(_gblSetup._column_names[i]);
    if (!has_hdr)     localSetup._check_header=-1;
  }
  try {
switch (cpr) {
case NONE:
      if (localSetup._parse_type._parallelParseSupported) {
        DParse dp=new DParse(_vg,localSetup,_vecIdStart,chunkStartIdx,this,key,vec.nChunks());
        addToPendingCount(1);
        dp.setCompleter(this);
        dp.asyncExec(vec);
        for (int i=0; i < vec.nChunks(); ++i)         _chunk2Enum[chunkStartIdx + i]=vec.chunkKey(i).home_node().index();
      }
 else {
        InputStream bvs=vec.openStream(_job_key);
        _dout[_lo]=streamParse(bvs,localSetup,makeDout(localSetup,chunkStartIdx,vec.nChunks()),bvs);
        chunksAreLocal(vec,chunkStartIdx,key);
      }
    break;
case ZIP:
{
    InputStream bvs=vec.openStream(_job_key);
    ZipInputStream zis=new ZipInputStream(bvs);
    ZipEntry ze=zis.getNextEntry();
    if (ze != null && !ze.isDirectory())     _dout[_lo]=streamParse(zis,localSetup,makeDout(localSetup,chunkStartIdx,vec.nChunks()),bvs);
 else     zis.close();
    chunksAreLocal(vec,chunkStartIdx,key);
    break;
  }
case GZIP:
{
  InputStream bvs=vec.openStream(_job_key);
  _dout[_lo]=streamParse(new GZIPInputStream(bvs),localSetup,makeDout(localSetup,chunkStartIdx,vec.nChunks()),bvs);
  chunksAreLocal(vec,chunkStartIdx,key);
  break;
}
}
}
 catch (IOException ioe) {
throw new RuntimeException(ioe);
}
catch (H2OParseException pe) {
throw new H2OParseException(key,pe);
}
}
