{
  int n=_dout.length - 1;
  while (_dout[n] == null && n != 0)   --n;
  for (int i=0; i <= n; ++i) {
    if (_dout[i] == null) {
      _dout[i]=_dout[n];
      n--;
      while (n > i && _dout[n] == null)       n--;
    }
  }
  if (n < _dout.length - 1)   _dout=Arrays.copyOf(_dout,n + 1);
  if (_dout.length == 1) {
    _vecs=_dout[0]._vecs;
    return;
  }
  int nCols=0;
  for (  FVecDataOut dout : _dout)   nCols=Math.max(dout._vecs.length,nCols);
  AppendableVec[] res=new AppendableVec[nCols];
  int nchunks=0;
  for (  FVecDataOut dout : _dout)   nchunks+=dout.nChunks();
  long[] espc=MemoryManager.malloc8(nchunks);
  for (int i=0; i < res.length; ++i) {
    res[i]=new AppendableVec(_vg.vecKey(_vecIdStart + i),_setup._chunkSize,espc,0);
    res[i].setTypes(MemoryManager.malloc1(nchunks));
  }
  for (int i=0; i < _dout.length; ++i)   for (int j=0; j < _dout[i]._vecs.length; ++j)   res[j].setSubRange(_dout[i]._vecs[j]);
  if ((res.length + _vecIdStart) < _reservedKeys) {
    Future f=_vg.tryReturnKeys(_vecIdStart + _reservedKeys,_vecIdStart + res.length);
    if (f != null)     try {
      f.get();
    }
 catch (    InterruptedException e) {
    }
catch (    ExecutionException e) {
    }
  }
  _vecs=res;
}
