def __getitem__(self, i):
    '\n    Column selection via integer, string(name)\n    Column selection via slice returns a subset of the H2OFrame\n\n    :param i: An int, str, slice, H2OVec, or list/tuple\n    :return: An H2OVec, an H2OFrame, or scalar depending on the input slice.\n    '
    if ((self._vecs is None) or (self._vecs == [])):
        raise ValueError('Frame Removed')
    if isinstance(i, int):
        return self._vecs[i]
    if isinstance(i, str):
        return self._find(i)
    if isinstance(i, slice):
        return H2OFrame(vecs=self._vecs[i])
    if isinstance(i, H2OVec):
        self._len_check(i)
        return H2OFrame(vecs=[x.row_select(i) for x in self._vecs])
    if (isinstance(i, list) or (isinstance(i, tuple) and (len(i) != 2))):
        vecs = []
        for it in i:
            if isinstance(it, int):
                vecs.append(self._vecs[it])
            elif isinstance(it, str):
                vecs.append(self._find(it))
            else:
                raise NotImplementedError
        return H2OFrame(vecs=vecs)
    if isinstance(i, tuple):
        veckeys = [str(v._expr._data) for v in self._vecs]
        left = Expr(veckeys)
        rite = Expr((i[0], i[1]))
        res = Expr('[', left, rite, length=2)
        if ((not isinstance(i[0], int)) or (not isinstance(i[1], int))):
            return res
        res.eager()
        if res.is_local():
            return res._data
        j = h2o.frame(res._data)
        return map(list, zip(*[c['data'] for c in j['frames'][0]['columns'][:]]))[0][0]
    raise NotImplementedError(('Slicing by unknown type: ' + str(type(i))))
