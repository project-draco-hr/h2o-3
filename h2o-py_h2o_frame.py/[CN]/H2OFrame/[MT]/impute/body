def impute(self, column, method, combine_method, by, inplace):
    '\n    Impute a column in this H2OFrame.\n\n    :param column: The column to impute\n    :param method: How to compute the imputation value.\n    :param combine_method: For even samples and method="median", how to combine quantiles.\n    :param by: Columns to group-by for computing imputation value per groups of columns.\n    :param inplace: Impute inplace?\n    :return: the imputed frame.\n    '
    col_id = (-1)
    if isinstance(column, (unicode, str)):
        col_id = self._find_idx(column)
    elif isinstance(column, int):
        col_id = column
    elif isinstance(column, H2OVec):
        try:
            col_id = [(a._name == v._name) for a in self].index(True)
        except:
            raise ValueError('No column found to impute.')
    if (isinstance(method, list) and (len(method) > 1)):
        if self[col_id].isfactor():
            method = 'mode'
        else:
            method = 'mean'
    elif isinstance(method, list):
        method = method[0]
    if (isinstance(combine_method, list) and (len(combine_method) > 1)):
        combine_method = 'interpolate'
    if (combine_method == 'lo'):
        combine_method = 'low'
    if (combine_method == 'hi'):
        combine_method = 'high'
    if (method == 'median'):
        if (by is not None):
            raise ValueError('Unimplemented: No `by` and `median`. Please select a different method (e.g. `mean`).')
    if (self[col_id].isfactor() and (method not in ['ffill', 'bfill', 'mode'])):
        raise ValueError('Column is categorical, method must not be mean or median.')
    gb_cols = '()'
    if (by is not None):
        if (not isinstance(by, list)):
            by = [by]
        if isinstance(by[0], (unicode, str)):
            by = [self._find_idx(name) for name in by]
        elif isinstance(by[0], int):
            by = by
        elif isinstance(by[0], H2OVec):
            by = [[(a._name == v._name) for a in self].index(True) for v in by]
        else:
            raise ValueError('`by` is not a supported type')
    if (by is not None):
        gb_cols = (('(llist #' + ' #'.join([str(b) for b in by])) + ')')
    key = self.send_frame()
    tmp_key = H2OFrame.py_tmp_key()
    if inplace:
        expr = '(h2o.impute %{} #{} "{}" "{}" {} %TRUE'.format(key, col_id, method, combine_method, gb_cols)
        h2o.rapids(expr)
        h2o.delete(key)
        return self
    else:
        expr = '(= !{} (h2o.impute %{} #{} "{}" "{}" {} %FALSE))'.format(tmp_key, key, col_id, method, combine_method, gb_cols)
        h2o.rapids(expr)
        h2o.delete(key)
        j = h2o.frame(tmp_key)
        fr = j['frames'][0]
        rows = fr['rows']
        veckeys = fr['vec_ids']
        cols = fr['columns']
        colnames = [col['label'] for col in cols]
        vecs = H2OVec.new_vecs(zip(colnames, veckeys), rows)
        h2o.delete(tmp_key)
        return H2OFrame(vecs=vecs)
