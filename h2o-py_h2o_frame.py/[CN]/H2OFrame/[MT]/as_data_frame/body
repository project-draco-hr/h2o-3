def as_data_frame(self, use_pandas=True):
    "\n    Obtain the dataset as a python-local object (pandas frame if possible, list otherwise)\n\n    :param use_pandas: A flag specifying whether or not to return a pandas DataFrame.\n    :return: A local python object (a list of lists of strings, each list is a row, if use_pandas=False, otherwise a\n    pandas DataFrame) containing this self._newExpr instance's data.\n    "
    url = (((((('http://' + h2o.H2OConnection.ip()) + ':') + str(h2o.H2OConnection.port())) + '/3/DownloadDataset?frame_id=') + urllib.quote(self.frame_id)) + '&hex_string=false')
    response = urllib2.urlopen(url)
    if (h2o.can_use_pandas() and use_pandas):
        import pandas
        df = pandas.read_csv(response, low_memory=False)
        time_cols = []
        category_cols = []
        if (self.types is not None):
            for col_name in self.names:
                xtype = self.type(col_name)
                if (xtype.lower() == 'time'):
                    time_cols.append(col_name)
                elif (xtype.lower() == 'enum'):
                    category_cols.append(col_name)
            if time_cols:
                from datetime import datetime
                sample_timestamp = 1380610868
                utc_offset = (1000 * (datetime.utcfromtimestamp(sample_timestamp) - datetime.fromtimestamp(sample_timestamp)).total_seconds())
                try:
                    df[time_cols] = (df[time_cols] - utc_offset).astype('datetime64[ms]')
                except pandas.tslib.OutOfBoundsDatetime:
                    pass
            for cat_col in category_cols:
                df[cat_col] = df[cat_col].astype('category')
        return df
    else:
        cr = csv.reader(response)
        return [([''] if (row == []) else row) for row in cr]
