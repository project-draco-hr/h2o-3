def as_data_frame(self, nrows=None, skiprows=None, ncols=None, use_pandas=True):
    "\n    Obtain the dataset as a python-local object (pandas frame if possible, list otherwise)\n\n    :param nrows: The number of rows for pandas to read. Default is None, which reads all rows.\n    :param skiprows: A list of rows to skip. Default is None, which skips no rows.\n    :param ncols: The number of columns for pandas to read. Default is None, which reads all columns.\n    :param use_pandas: A flag specifying whether or not to return a pandas DataFrame.\n    :return: A local python object (a list of lists of strings, each list is a row, if use_pandas=False, otherwise a\n    pandas DataFrame) containing this H2OFrame instance's data.\n    "
    self._eager()
    url = (((((('http://' + h2o.H2OConnection.ip()) + ':') + str(h2o.H2OConnection.port())) + '/3/DownloadDataset?frame_id=') + urllib.quote(self._id)) + '&hex_string=false')
    response = urllib2.urlopen(url)
    if (h2o.can_use_pandas() and use_pandas):
        import pandas
        df = pandas.read_csv(response, low_memory=False, nrows=nrows, skiprows=skiprows, usecols=(None if (ncols is None) else range(ncols)))
        time_cols = []
        category_cols = []
        if (self.types is not None):
            for col_name in self.names[:ncols]:
                type = self.types[col_name]
                if (type.lower() == 'time'):
                    time_cols.append(col_name)
                elif (type.lower() == 'enum'):
                    category_cols.append(col_name)
            if time_cols:
                from datetime import datetime
                sample_timestamp = 1380610868
                utc_offset = (1000 * (datetime.utcfromtimestamp(sample_timestamp) - datetime.fromtimestamp(sample_timestamp)).total_seconds())
                try:
                    df[time_cols] = (df[time_cols] - utc_offset).astype('datetime64[ms]')
                except pandas.tslib.OutOfBoundsDatetime:
                    pass
            for cat_col in category_cols:
                df[cat_col] = df[cat_col].astype('category')
        return df
    else:
        cr = csv.reader(response)
        rows = [([''] if (row == []) else row[:ncols]) for row in cr]
        return (([rows[0]] + rows[(skiprows[(-1)] + 1):]) if skiprows else rows[:(None if (nrows is None) else (nrows + 1))])
