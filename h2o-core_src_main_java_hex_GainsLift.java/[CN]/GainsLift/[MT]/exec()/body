{
  init();
  QuantileModel qm=null;
  Scope.enter();
  Frame frame=null;
  try {
    labels=labels.toCategoricalVec();
    frame=new Frame(Key.make(),new String[]{"predicted"},new Vec[]{preds});
    DKV.put(frame);
    if (!labels.group().equals(preds.group())) {
      preds=labels.align(preds);
      Scope.track(preds._key);
      if (weight != null) {
        weight=labels.align(weight);
        Scope.track(weight._key);
      }
    }
    QuantileModel.QuantileParameters qp=new QuantileModel.QuantileParameters();
    qp._train=frame._key;
    qp._probs=new double[GROUPS];
    for (int i=0; i < GROUPS; ++i) {
      qp._probs[i]=(GROUPS - i - 1.) / GROUPS;
    }
    if (weight != null)     throw H2O.unimpl("Quantile cannot handle weights yet.");
    Quantile q=new Quantile(qp);
    qm=q.trainModel().get();
    GainsTask gt=new GainsTask(qm._output._quantiles[0],labels.length());
    if (weight != null)     gt.doAll(labels,preds,weight);
 else     gt.doAll(labels,preds);
    response_rates=gt.response_rates();
    avg_response_rate=gt.avg_response_rate();
    positive_responses=gt.responses();
  }
  finally {
    if (qm != null)     qm.remove();
    if (frame != null)     DKV.remove(frame._key);
    Scope.exit();
  }
  Log.info(createTwoDimTable());
}
