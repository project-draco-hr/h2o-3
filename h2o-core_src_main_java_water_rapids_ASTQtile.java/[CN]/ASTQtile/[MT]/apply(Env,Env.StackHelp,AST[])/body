{
  QuantileModel.QuantileParameters parms=new QuantileModel.QuantileParameters();
  Frame fr=stk.track(asts[1].exec(env)).getFrame();
  Frame fr_wkey=new Frame(fr);
  DKV.put(fr_wkey);
  parms._train=fr_wkey._key;
  parms._probs=((ASTNumList)asts[2]).expand();
  for (  double d : parms._probs)   if (d < 0 || d > 1)   throw new IllegalArgumentException("Probability must be between 0 and 1: " + d);
  String inter=asts[3].exec(env).getStr();
  parms._combine_method=QuantileModel.CombineMethod.valueOf(inter.toUpperCase());
  QuantileModel q=new Quantile(parms).trainModel().get();
  DKV.remove(fr_wkey._key);
  Vec[] vecs=new Vec[1 + fr.numCols()];
  String[] names=new String[vecs.length];
  vecs[0]=Vec.makeCon(null,parms._probs);
  names[0]="Probs";
  for (int i=0; i < fr.numCols(); ++i) {
    vecs[i + 1]=Vec.makeCon(null,q._output._quantiles[i]);
    names[i + 1]=fr._names[i] + "Quantiles";
  }
  q.delete();
  return new ValFrame(new Frame(names,vecs));
}
