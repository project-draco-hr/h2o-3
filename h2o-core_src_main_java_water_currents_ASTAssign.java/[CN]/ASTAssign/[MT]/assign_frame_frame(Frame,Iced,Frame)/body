{
  if (rowz instanceof Frame) {
    throw H2O.unimpl();
  }
  ASTNumList rows=(ASTNumList)rowz;
  if (dst.numCols() != src.numCols())   throw new IllegalArgumentException("Source and destination frames must have the same count of columns");
  long nrows=rows.cnt();
  if (src.numRows() != nrows)   throw new IllegalArgumentException("Requires same count of rows in the number-list (" + nrows + ") as in the source ("+ src.numRows()+ ")");
  Vec[] dvecs=dst.vecs();
  Vec[] svecs=src.vecs();
  if (dst.numRows() == nrows && rows.isDense()) {
    new MRTask(){
      @Override public void map(      Chunk[] cs){
        int len=cs.length >> 1;
        for (int i=0; i < len; i++) {
          Chunk cdst=cs[i];
          Chunk csrc=cs[i + len];
          cdst.replaceAll(csrc.deepCopy());
        }
      }
    }
.doAll(new Frame().add(dst).add(src));
    Futures fs=new Futures();
    for (int col=0; col < dvecs.length; col++)     dvecs[col].copyMeta(svecs[col],fs);
    fs.blockForPending();
    if (dst._key != null)     throw H2O.unimpl();
    return;
  }
  for (int col=0; col < dvecs.length; col++)   if (dvecs[col].get_type() != svecs[col].get_type())   throw new IllegalArgumentException("Columns must be the same type; column " + col + ", \'"+ dst._names[col]+ "\', is of type "+ dvecs[col].get_type_str()+ " and the source is "+ svecs[col].get_type_str());
  if (nrows == 1) {
    long drow=(long)rows.expand()[0];
    for (int col=0; col < dvecs.length; col++)     dvecs[col].set(drow,svecs[col].at(0));
    return;
  }
  throw H2O.unimpl();
}
