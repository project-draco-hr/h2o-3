{
  Frame dst=stk.track(asts[1].exec(env)).getFrame();
  Val vsrc=stk.track(asts[2].exec(env));
  ASTNumList cols=check(dst.numCols(),asts[3]);
  Iced rows=(asts[4] instanceof ASTNumList) ? check(dst.numRows(),asts[4]) : stk.track(asts[4].exec(env)).getFrame();
  if (cols.cnt() == 1 && cols.max() - 1 == dst.numCols()) {
    dst=new Frame(dst._names.clone(),dst.vecs().clone());
    dst.add(Frame.defaultColName(dst.numCols()),dst.anyVec().makeCon(Double.NaN));
  }
  Frame slice=new ASTColSlice().apply(env,stk,new AST[]{null,new ASTFrame(dst),cols}).getFrame();
switch (vsrc.type()) {
case Val.NUM:
    assign_frame_scalar(slice,rows,vsrc.getNum());
  break;
case Val.FRM:
assign_frame_frame(slice,rows,vsrc.getFrame());
break;
default :
throw new IllegalArgumentException("Source must be a Frame or Number, but found a " + vsrc.getClass());
}
return new ValFrame(dst);
}
