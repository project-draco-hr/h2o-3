{
  if (_hist == null)   _hist=new History(_historySz,beta.length);
  beta=beta.clone();
  int iter=0;
  boolean doLineSearch=true;
  int ls_switch=0;
  final double gEps=Math.min(_gradEps * beta.length,Math.max(MathUtils.l2norm2(ginfo._gradient) * 1e-1,1e-15));
  while (pm.progress(beta,ginfo) && MathUtils.l2norm2(ginfo._gradient) > gEps && iter != _maxIter) {
    double[] pk=_hist.getSearchDirection(ginfo._gradient);
    if (ArrayUtils.hasNaNsOrInfs(pk)) {
      Log.warn("LBFGS: Got NaNs in search direction.");
      break;
    }
    double lsVal=Double.POSITIVE_INFINITY;
    if (doLineSearch) {
      LineSearchSol ls=gslvr.doLineSearch(ginfo,beta,pk,24,.5);
      if (ls.step == 1) {
        if (++ls_switch == 2) {
          ls_switch=0;
          doLineSearch=false;
        }
      }
 else {
        ls_switch=0;
      }
      if (ls.madeProgress || _hist._k < 2) {
        lsVal=ls.objVal;
        ArrayUtils.wadd(beta,pk,ls.step);
      }
 else       break;
    }
 else     ArrayUtils.add(beta,pk);
    GradientInfo newGinfo=gslvr.getGradient(beta);
    if (doLineSearch && !(Double.isNaN(lsVal) && Double.isNaN(newGinfo._objVal)) && Math.abs(lsVal - newGinfo._objVal) > 1e-10 * lsVal)     throw new IllegalArgumentException("L-BFGS: Got invalid gradient solver, objective values from line-search and gradient tasks differ, " + lsVal + " != "+ newGinfo._objVal);
    if (!doLineSearch)     if (!admissibleStep(1,ginfo._objVal,newGinfo._objVal,pk,ginfo._gradient)) {
      if (++ls_switch == 2) {
        doLineSearch=true;
        ls_switch=0;
      }
      if (ginfo._objVal < newGinfo._objVal && (newGinfo._objVal - ginfo._objVal > .001 * ginfo._objVal)) {
        doLineSearch=true;
        ArrayUtils.subtract(beta,pk,beta);
        continue;
      }
    }
 else     ls_switch=0;
    ++iter;
    _hist.update(pk,newGinfo._gradient,ginfo._gradient);
    ginfo=newGinfo;
  }
  return new Result(iter,beta,ginfo);
}
