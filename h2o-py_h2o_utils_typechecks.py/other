u'\nUtilities for checking types and validity of variables.\n\nThe primary purpose of this module is to facilitate testing whether some variable has the desired type. Such testing\ncomes in two flavors: as the ``is_type()`` function, and the ``assert_is_type()`` assert. The latter should be used\nfor checking types of input variables in public methods / functions. Its advantage over simple ``assert is_type()``\nconstruct is that: firstly it composes the error message in case of failure, and secondly it throws an\n:class:`H2OTypeError` exception instead of an ``AssertionError``, which is both more precise, and more user-friendly\n(in the sense that it produces much nicer error message).\n\nGeneral interface of this module is:\n\n    assert_is_type(var, type1, ..., typeN)\n    assert_satisfies(var, condition)\n    assert_matches(var, regular_expression)\n    if is_type(var, type1, ..., typeN): ...\n\nThe ``typeI`` items here deserve a more thorough explanation. They could be:\n\n    # Plain types\n    assert_is_type(flag, bool) # note that in Python ``bool`` is a subclass of ``int``\n    assert_is_type(port, int)  # ``int`` and ``str`` will work on Py2 as if you were on Py3\n    assert_is_type(text, str)  # (i.e. they\'ll also match ``long`` and ``unicode`` respectively)\n    assert_is_type(hls, H2OLocalServer)\n    assert_is_type(arr, list, tuple, set)\n    assert_is_type(json, dict)\n    assert_is_type(asdffkj, object)  # in Python ``object`` is equivalent to ``any``\n\n    # "numeric" is a special type, meaning ``U(int, float)``\n    assert_is_type(x, numeric)\n\n    # Literals are matched by value\n    assert_is_type(v, None)\n    assert_is_type(scheme, "http", "https", "ftp")\n    assert_is_type(dir, -1, 0, 1)\n\n    # Testing lists\n    assert_is_type(arr, [numeric])   # List of numbers\n    assert_is_type(arr2, [[float]])  # List of lists of floats (i.e. a 2-dimensional array)\n    assert_is_type(arr, list)        # Generic list, same as ``[object]``\n    assert_is_type(arr, [int, str])  # List of either ints or strings, same as ``[U(int, str)]``\n\n    # Sets follow the same semantic as lists, only use curly braces ``{}`` instead of square ones\n    assert_is_type(s, {str})  # Set of string values\n    assert_is_type(s, set)    # Generic set, same as ``{object}``\n\n    # Tuples\n    assert_is_type(t, tuple)  # any tuple\n    assert_is_type(t, (int, int, int, [str]))  # Test for a 4-tuple having first 3 ints and last an array of strings\n    assert_is_type(t, Tuple(int))  # tuple of ints of arbitrary length\n\n    # Dictionaries\n    assert_is_type(t, dict)  # any dictionary\n    assert_is_type(cols, {str: H2OFrame})  # Same as Map<str, H2OFrame> in Java\n    assert_is_type(vals, {str: U(numeric, str)})  # Dictionary with string keys and ``U(numeric, str)`` values\n    # Dictionary whose key-value pairs match either ``(ktype1, vtype1)``, or ..., or ``(ktypeN, vtypeN)``\n    assert_is_type(foo, {ktype1: vtype1, ..., ktypeN: vtypeN})\n    # Here we test whether ``xyz`` has keys of the specified types. For example ``xyz = {"foo": 1, "bar": 2}`` will\n    # pass the test, whereas ``xyz = {"foo": 0, "kaboom": None}`` will not.\n    assert_is_type(xyz, {"foo": int, "bar": U(int, float, None), "baz": bool})\n\n    # Functions and lambda-expressions\n    assert_is_type(progress, I(numeric, lambda x: 0 <= x <= 1))\n    assert_is_type(x, None, "N/A", I(float, math.isnan))\n    assert_is_type(matrix, I([[numeric]], lambda v: all(len(vi) == len(v[0]) for vi in v)))\n    assert_is_type(a, lambda t: issubclass(t, object))\n\nAs you have noticed, we define a number of special classes to facilitate type construction::\n\n    # Union / intersection / negation\n    U(str, int, float)     # denotes a type which can be either a string, or an integer, or a float\n    I(Widget, Renderable)  # denotes a class which is both a Widget and a Renderable (it uses multiple inheritance)\n    NOT(None)              # denotes any type except None\n    # Intersection and negation are best used together:\n    I(int, NOT(0))         # integer which is not zero\n\n    # ``Tuple`` may be used to denote tuples with variable number of arguments (same as lists)\n    Tuple(int)             # tuple with any number of integer elements\n\n    # ``Dict`` is a dictionary type which should match exactly (i.e. each key must be present in tested variable)\n    Dict(error=str)        # dictionary with only one key "error" with string value\n\n    # ``BoundInt``, ``BoundNumeric`` are numbers that are bound from below below and/or above\n    BoundInt(1, 100)\n    BoundNumeric(0, 1)\n\n    # Lazy class references: these types can be used anywhere without having to load the corresponding modules. Their\n    # resolution is deferred until the run time, and if the module cannot be loaded no exception will be raised (but\n    # of course the type check will fail).\n    h2oframe          # Same as H2OFrame\n    pandas_dataframe  # Same as pandas.DataFrame\n    numpy_ndarray     # Same as numpy.ndarray\n\n    # An enum. This is similar to a mere union of strings, except that we match case-insensitively\n    Enum("case1", "case2", ...)\n\n\n:copyright: (c) 2016 H2O.ai\n:license:   Apache License Version 2.0 (see LICENSE for details)\n'
from __future__ import absolute_import, division, print_function, unicode_literals
import importlib
import io
import re
import sys
import tokenize
from types import BuiltinFunctionType, FunctionType
from h2o.exceptions import H2OTypeError, H2OValueError
from h2o.utils.compatibility import *
from h2o.utils.compatibility import PY2, viewitems
__all__ = (u'U', u'I', u'NOT', u'Tuple', u'Dict', u'MagicType', u'BoundInt', u'BoundNumeric', u'Enum', u'numeric', u'h2oframe', u'pandas_dataframe', u'numpy_ndarray', u'assert_is_type', u'assert_matches', u'assert_satisfies', u'is_type')
if PY2:
    from h2o.utils.compatibility import _native_unicode, _native_long
    _str_type = (str, _native_unicode)
    _int_type = (int, _native_long)
    _num_type = (int, _native_long, float)
    _primitive_type = (str, int, float, bool, _native_unicode, _native_long)
else:
    _str_type = str
    _int_type = int
    _num_type = (int, float)
    _primitive_type = (str, int, float, bool, bytes)
_enum_mangle_pattern = re.compile(u'[^a-z]+')
numeric = U(int, float)
u'Number, either integer or real.'
h2oframe = _LazyClass(u'h2o', u'H2OFrame')
pandas_dataframe = _LazyClass(u'pandas', u'DataFrame')
numpy_ndarray = _LazyClass(u'numpy', u'ndarray')
