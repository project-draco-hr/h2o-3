{
  Word2VecModel model=null;
  long start, stop, lastCnt=0;
  long tstart, tstop;
  float tDiff;
  try {
    Scope.enter();
    _parms.read_lock_frames(Word2Vec.this);
    init(true);
    model=new Word2VecModel(dest(),_parms,new Word2VecOutput(Word2Vec.this));
    model.delete_and_lock(_key);
    Log.info("Word2Vec: Starting to train model.");
    tstart=System.currentTimeMillis();
    for (int i=0; i < _parms._epochs; i++) {
      start=System.currentTimeMillis();
      model.setModelInfo(new WordVectorTrainer(model.getModelInfo()).doAll(_parms.train()).getModelInfo());
      stop=System.currentTimeMillis();
      model.getModelInfo().updateLearningRate();
      model.update(_key);
      Job.update(1,_key);
      tDiff=(float)(stop - start) / 1000;
      Log.info("Epoch " + i + " "+ tDiff+ "s  Words trained/s: "+ (model.getModelInfo().getTotalProcessed() - lastCnt) / tDiff);
      lastCnt=model.getModelInfo().getTotalProcessed();
    }
    tstop=System.currentTimeMillis();
    Log.info("Total time :" + ((float)(tstop - tstart)) / 1000f);
    Log.info("Finished training the Word2Vec model.");
    model.buildModelOutput();
    done();
  }
 catch (  Throwable t) {
    Job thisJob=DKV.getGet(_key);
    if (thisJob._state == JobState.CANCELLED) {
      Log.info("Job cancelled by user.");
    }
 else {
      t.printStackTrace();
      failed(t);
      throw t;
    }
  }
 finally {
    updateModelOutput();
    if (model != null)     model.unlock(_key);
    _parms.read_unlock_frames(Word2Vec.this);
    Scope.exit();
  }
  tryComplete();
}
