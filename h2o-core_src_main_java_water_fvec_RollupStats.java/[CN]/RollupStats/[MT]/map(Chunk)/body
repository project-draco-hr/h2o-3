{
  _size=c.byteSize();
  Arrays.fill(_mins,Double.MAX_VALUE);
  Arrays.fill(_maxs,-Double.MAX_VALUE);
  boolean isUUID=c._vec.isUUID();
  boolean isString=c._vec.isString();
  BufferedString vs=new BufferedString();
  if (isString)   _isInt=false;
  long checksum=0;
  long start=c._start;
  long l=81985529216486895L;
  double min=c.min(), max=c.max();
  if (min == max) {
    double d=min;
    _checksum=(c.hasFloat() ? Double.doubleToRawLongBits(d) : (long)d) * c._len;
    Arrays.fill(_mins,d);
    Arrays.fill(_maxs,d);
    if (d == Double.POSITIVE_INFINITY)     _pinfs++;
 else     if (d == Double.NEGATIVE_INFINITY)     _ninfs++;
 else {
      if (d != 0)       _nzCnt=c._len;
      _mean=d;
      _rows=c._len;
    }
    _isInt=((long)d) == d;
    _sigma=0;
    return this;
  }
  if (min == 0 && max == 1) {
    int zs=c._len - c.sparseLen();
    int nans=0;
    for (int i=c.nextNZ(-1); i < c._len; i=c.nextNZ(i))     if (c.isNA(i))     nans++;
 else     if (c.at8(i) == 0)     zs++;
    int os=c._len - zs - nans;
    _nzCnt=os;
    _naCnt=nans;
    for (int i=0; i < Math.min(_mins.length,zs); i++) {
      min(0);
      max(0);
    }
    for (int i=0; i < Math.min(_mins.length,os); i++) {
      min(1);
      max(1);
    }
    _rows=zs + os;
    _mean=(double)os / _rows;
    _sigma=zs * (0.0 - _mean) * (0.0 - _mean) + os * (1.0 - _mean) * (1.0 - _mean);
    return this;
  }
  if (isUUID) {
    for (int i=c.nextNZ(-1); i < c._len; i=c.nextNZ(i)) {
      if (c.isNA(i))       _naCnt++;
 else {
        long lo=c.at16l(i), hi=c.at16h(i);
        if (lo != 0 || hi != 0)         _nzCnt++;
        l=lo ^ 37 * hi;
      }
      if (l != 0)       checksum^=(17 * (start + i)) ^ 23 * l;
    }
  }
 else   if (isString) {
    for (int i=c.nextNZ(-1); i < c._len; i=c.nextNZ(i)) {
      if (c.isNA(i))       _naCnt++;
 else {
        _nzCnt++;
        l=c.atStr(vs,i).hashCode();
      }
      if (l != 0)       checksum^=(17 * (start + i)) ^ 23 * l;
    }
  }
 else {
    double sum=0;
    for (int i=c.nextNZ(-1); i < c._len; i=c.nextNZ(i)) {
      double d=c.atd(i);
      if (Double.isNaN(d))       _naCnt++;
 else {
        l=c.hasFloat() ? Double.doubleToRawLongBits(d) : c.at8(i);
        if (d == Double.POSITIVE_INFINITY)         _pinfs++;
 else         if (d == Double.NEGATIVE_INFINITY)         _ninfs++;
 else {
          if (d != 0)           _nzCnt++;
          min(d);
          max(d);
          sum+=d;
          _rows++;
          if (_isInt && ((long)d) != d)           _isInt=false;
        }
      }
      if (l != 0)       checksum^=(17 * (start + i)) ^ 23 * l;
    }
    if (Double.isNaN(_mean))     _mean=sum;
 else     _mean+=sum;
  }
  _checksum=checksum;
  if (c.isSparse()) {
    int zeros=c._len - c.sparseLen();
    for (int i=0; i < Math.min(_mins.length,zeros); i++) {
      min(0);
      max(0);
    }
    _rows+=zeros;
  }
  if (isUUID || isString) {
    Arrays.fill(_mins,Double.NaN);
    Arrays.fill(_maxs,Double.NaN);
    _mean=_sigma=Double.NaN;
  }
 else   if (!Double.isNaN(_mean) && _rows > 0) {
    final double mean=_mean=_mean / _rows;
    int zeros=c._len - c.sparseLen();
    double sigma=mean * mean * zeros;
    for (int i=c.nextNZ(-1); i < c._len; i=c.nextNZ(i)) {
      double d=c.atd(i);
      if (!Double.isNaN(d)) {
        d-=mean;
        sigma+=d * d;
      }
    }
    _sigma=sigma;
  }
  return this;
}
