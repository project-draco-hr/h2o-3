{
  _checksum=0;
  long start=c._start;
  long l=81985529216486895L;
  _size=c.byteSize();
  _mins=new double[5];
  Arrays.fill(_mins,Double.MAX_VALUE);
  _maxs=new double[5];
  Arrays.fill(_maxs,-Double.MAX_VALUE);
  boolean isUUID=c._vec.isUUID();
  boolean isString=c._vec.isString();
  ValueString vs=new ValueString();
  if (isString)   _isInt=false;
  for (int i=c.nextNZ(-1); i < c._len; i=c.nextNZ(i)) {
    if (c.isNA0(i)) {
      _naCnt++;
    }
 else     if (isUUID) {
      long lo=c.at16l0(i), hi=c.at16h0(i);
      if (lo != 0 || hi != 0)       _nzCnt++;
      l=lo ^ 37 * hi;
    }
 else     if (isString) {
      _nzCnt++;
      l=c.atStr0(vs,i).hashCode();
    }
 else {
      double d=c.at0(i);
      l=c.hasFloat() ? Double.doubleToRawLongBits(d) : c.at80(i);
      if (d == Double.POSITIVE_INFINITY)       _pinfs++;
 else       if (d == Double.NEGATIVE_INFINITY)       _ninfs++;
 else {
        if (d != 0)         _nzCnt++;
        min(d);
        max(d);
        _mean+=d;
        _rows++;
        if (_isInt && ((long)d) != d)         _isInt=false;
      }
    }
    if (l != 0)     _checksum^=(17 * (start + i)) ^ 23 * l;
  }
  if (c.isSparse()) {
    int zeros=c._len - c.sparseLen();
    for (int i=0; i < Math.min(_mins.length,zeros); i++) {
      min(0);
      max(0);
    }
    _rows+=zeros;
  }
  if (isUUID || isString) {
    _mean=_sigma=Double.NaN;
  }
 else   if (!Double.isNaN(_mean) && _rows > 0) {
    _mean=_mean / _rows;
    for (int i=0; i < c._len; i++) {
      if (!c.isNA0(i)) {
        double d=c.at0(i) - _mean;
        _sigma+=d * d;
      }
    }
  }
  return this;
}
