{
  _size=c.byteSize();
  _mins=new double[5];
  Arrays.fill(_mins,Double.MAX_VALUE);
  _maxs=new double[5];
  Arrays.fill(_maxs,-Double.MAX_VALUE);
  boolean isUUID=c._vec._isUUID;
  for (int i=c.nextNZ(-1); i < c.len(); i=c.nextNZ(i)) {
    if (c.isNA0(i)) {
      _naCnt++;
      _nzCnt++;
    }
 else     if (isUUID) {
      if (c.at16l0(i) != 0 || c.at16h0(i) != 0)       _nzCnt++;
    }
 else {
      double d=c.at0(i);
      if (d == Double.POSITIVE_INFINITY)       _pinfs++;
 else       if (d == Double.NEGATIVE_INFINITY)       _ninfs++;
 else {
        if (d != 0)         _nzCnt++;
        min(d);
        max(d);
        _mean+=d;
        _rows++;
        if (_isInt && ((long)d) != d)         _isInt=false;
      }
    }
  }
  if (c.isSparse()) {
    int zeros=c.len() - c.sparseLen();
    for (int i=0; i < Math.min(_mins.length,zeros); i++) {
      min(0);
      max(0);
    }
    _rows+=zeros;
  }
  if (isUUID) {
    _mean=_sigma=Double.NaN;
  }
 else   if (!Double.isNaN(_mean) && _rows > 0) {
    _mean=_mean / _rows;
    for (int i=0; i < c.len(); i++) {
      if (!c.isNA0(i)) {
        double d=c.at0(i) - _mean;
        _sigma+=d * d;
      }
    }
  }
  return this;
}
